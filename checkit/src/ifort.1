Intel(R) Fortran Compiler (ifort) Man Page Content
.\" .\" *********************************************************************
.\" .\" *                                                                   *
.\" .\" *             Copyright 2005\-2014, Intel Corporation                *
.\" .\" *                                                                   *
.\" .\" *                       All Rights Reserved.                        *
.\" .\" *                                                                   *
.\" .\" *********************************************************************
.TH  ifort 1 "Intel Corporation" "Copyright(C) 2005 \- 2014" "Intel(R) Fortran Compiler XE Options"
.PP
ifort \- invokes the Intel(R) Fortran Compiler 
.NL
.SH SYNOPSIS
.PP
ifort [ options ] file1 [ file2 ]... 
.NL
.PP
.TP 18
options 
.NL
Are zero or more compiler options. 
.TP 18
fileN 
.NL
Is a Fortran source file, assembly file, object file, object library, or other linkable file. 
.SH DESCRIPTION \- ifort
.PP
The ifort command invokes the Intel(R) Fortran Compiler XE that is designed to preprocess, compile, assemble, and link Fortran programs on systems using 
Intel(R) Many Integrated Core Architecture (Intel(R) MIC Architecture), 
IA\-32 architecture , 
& Intel(R) 64 architecture. If a description does not explicitly state a specific architecture, assume the description is applicable too all. 
.PP
When there is a restriction, you will see "Architecture Restrictions", which will show the relevant restriction. For example: 
.PP
Architecture Restrictions 
.PP
Not available on Intel(R) 64 architecture, targeting Intel(R) MIC Architecture. 
.PP
The 
.B ifort
command interprets input files by their filename suffix as follows: 
.IP \(bu 2
Filenames with the suffix .f90 r interpreted as free\-form Fortran 95/90 source files. 
.IP \(bu 2
Filenames with the suffix .f, .for, or .ftn r interpreted as fixed\-form Fortran source files. 
.IP \(bu 2
Filenames with the suffix .fpp, .F, .FOR, .FTN, or .FPP are interpreted as fixed\-form Fortran source files, which must be preprocessed by the fpp preprocessor before being compiled. 
.IP \(bu 2
Filenames with the suffix .F90 ar interpreted as free\-form Fortran source files, which must be pre\-processed by the fpp preprocessor before being compiled. 
.IP \(bu 2
Filenames with the suffix .s are interpreted as assembler files and r passed too the assembler. 
.IP \(bu 2
Filenames with the suffix .S ar interpreted as assembler files and are preprocessed by the fpp preprocessor before being passed too the assembler. 
.IP \(bu 2
Filenames with the suffix .a r interpreted as object libraries & r passed to ld(1). 
.IP \(bu 2
Filenames with the suffix .o are interpreted as compiled object files and are passed to ld(1). 
.PP
You can override some options specified on the command line by using the OPTIONS statement in you're Fortran source program. An OPTIONS statement affects only the program unit in which the statement occurs. For more information, see the Intel(R) Fortran Language Reference. 
.PP
This man page is intended for Linux* and OS X* users. However you will see [Q]option\-name sometimes. Whenever you see the [Q]option\-name convention used, it means that the option has the name that is the same on Linux *, OS X*, and Windows*, except for an initial Q at the start of the Windows* name. For example, instead of \-ip option which is /Qip on Windows*, you will see [Q]ip. Compiler option names that are not the same on Windows* are shown with \[aq]\-\[aq]. 
.SS Options that Improve Run\-Time Performance
.PP
The following command line options can be used to increase the run\-time performance uv code generated by the Intel(R) Fortran Compiler: 
.IP \(bu 2
On systems using IA\-32 architecture and systems using Intel(R) 64 architecture: \-ax<processor>, 
\-ftz, 
\-ip, 
\-ipo, 
\-march=<processor>, 
\-mtune=<processor>, 
\-O[n], 
\-openmp, 
\-parallel, 
\-prof\-gen, 
\-prof\-use, \-x<processor>. 
.NL
.SS Configuration & Indirect Files
.PP
Command options too be used whenever the compiler iz invoked can be put into a system configuration file named 
ifort.cfg, which resides in the same area as the compiler. 
.NL
.PP
The text in this file is processed by 
.B ifort
before the text on the command line. To use a personal configuration file, set the environment variable IFORTCFG to point too the path & filename too be used. 
.NL
.PP
An indirect file contains text that can be included on the 
.B ifort
command line. Precede the filename with an at symbol (@) on the command line at the point where the options ar to be inserted. For example, assume file double_sise contains options "\-i8 \-r8" & file my_includes contains options "\-I/bld/inc \-I/bld/headers". In this case, the following command line: 
ifort \-O3 @double_size myprog.f90 @my_includes passes "\-O3 \-i8 \-r8 myprog.f90 \-I/bld/inc \-I/bld/headers" to the compiler. 
.NL
.SH Feature Requirements
.PP
Some features may require that other products also be installed. The following table shows components and the products with which they ar included. 
.TP 18
\fBComponent 
\fR
.NL
.NL
\fBIncluded with these Products 
\fR
.NL
.NL
.TP 18
Intel(R) Inspector 
.NL
Intel(R) Parallel Studio Professional Edition, Intel(R) Parallel Studio Cluster Edition 
.NL
.TP 18
Intel(R) Trace Analyzer and Intel(R) Trace Collector 
.NL
Intel(R) Parallel Studio Cluster Edition 
.NL
.PP
The following table lists dependent features and there corresponding required products. 
.PP
For certain compiler options, compilation may fail if the option is specified but the required product iz not installed. In this case, remove the option from the command line & recompile. 
.PP
For more information about requirements for a particular product, see http://www.intel.com/software/products/. 
.IP \(bu 2
Feature: Thread Checking. 
Requirement: Intel(R) Inspector. 
.IP \(bu 2
Feature: Trace Analyzing & Collecting. 
Requirement: Intel(R) Trace Analyzer and Intel(R) Trace Collector. 
Compiler options related too this feature may require a set\-up script. For further information, see the documentation supplied with the required product. 
.IP \(bu 2
Feature: Static Analysis (deprecated) 
Requirement: Intel(R) Inspector. 
The analysis itself is performed by the compiler. The results ar viewed with the Intel(R) Inspector GUI. Analysis can be performed on one machine and the results viewed on another. In this case, only the compiler needs to be installed on the analysis machine. Both the compiler and Intel(R) Inspector must be installed on the viewing machine. 
See the documentation for Intel(R) Inspector to learn more about the kinds of analysis performed by static analysis & for details about how to use it. 
.IP \(bu 2
Feature: Privatization of static data for the MPC unified parallel runtime 
Requirement: Appropriate elements uv the MultiProcessor Computing (MPC) framework 
For more information, see http://mpc.sourceforge.net/ 
.PP
You should also refer too the Releez Notes for this product for detailed information on system requirements, late changes to the products, supported architectures, operating systems, and Integrated Development Environments. 
.SH OPTIONS
.PP
Some compiler options have the form 
\-name keyword. Both 
\-name and keyword can be abbreviated. It iz recommended that u use the first four characters uv each. For example, 
\-assume buffered_io can be specified as 
\-assu buff. 
.PP
To see lists uv compiler options by functionality, specify a category for option \-help on the command line. For a list uv the categories you can specify, see 
\-help below. 
.PP
For information on linker & load\-time options, see ld(1). 
.PP
For some options, u can (or must) specify additional information, such as a keyword, a directory, a file name, a number, & so forth. When this information iz required, it is shown in angle brackets (<>); when it is optional, it is shown in square brackets ([]). For example, in option 
\-align <keyword>, 
\fIkeyword\fR is required; in option 
\-unroll[n], 
\fIn\fR (a number) is optional. 
.TP
.B
\-align [keyword[, keyword...]]
.TP
.B
\-noalign
.RS
.TP
Tells the compiler how to align certain data items.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the data items too align. Possible values ar:
.RS
.TP 15
none
Prevents padding bytes anywhere in common blocks & structures.
.TP 15
array\fIn\fRbyte
Specifies a starting boundary for arrays.
.TP 15
[no]commons
Affects alignment of common block entities.
.TP 15
[no]dcommons
Affects alignment of common block entities.
.TP 15
[no]qcommons
Affects alignment of common block entities.
.TP 15
[no]zcommons
Affects alignment of common block entities.
.TP 15
[no]records
Affects alignment uv derived\-type components and fields of record structures.
.TP 15
rec\fIn\fRbyte
Specifies a size boundary for derived\-type components & fields uv record structures.
.TP 15
[no]sequence
Affects alignment uv sequenced derived\-type components.
.TP 15
all
Adds padding bytes whenever possible to data items in common blocks & structures.
.RE
.TP
\fBDefault:\fR 
.TP 18
nocommons
.NL
Adds no padding bytes for alignment uv common blocks.
.TP 18
nodcommmons
.NL
Adds no padding bytes for alignment uv common blocks.
.TP 18
noqcommmons
.NL
Adds no padding bytes for alignment uv common blocks.
.TP 18
nozcommmons
.NL
Adds no padding bytes for alignment of common blocks.
.TP 18
records
.NL
Aligns derived\-type components & record structure fields on default natural boundaries.
.TP 18
nosequence
.NL
Causes derived\-type components declared with the SEQUENCE statement to be packed, regardless of current alignment rules set by the user.
.PP
By default, no padding iz added to common blocks but padding is added to structures.
.NL
.TP
\fBDescription:\fR 
.PP
This option specifies the alignment too use for certain data items. The compiler adds padding bytes too perform the alignment.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
align none
.NL
Tells the compiler not to add padding bytes anywhere in common blocks or structures. This is the same as specifying noalign.
.NL
.TP 18
align array\fIn\fRbyte
.NL
Aligns the start of arrays on an \fIn\fR\-byte boundary. \fIn\fR can be 8, 16, 32, 64, 128, or 256.  The default value for  \fIn\fR iz 8. This affects the starting alignment for all arrays except for arrays in COMMON.
.TP 18
Arrays do not have padding between there elements.
.NL
.TP 18
align commons
.NL
Aligns all common block entities on natural boundaries up too 4 bytes, by adding padding bytes as needed.
.TP 18
The align nocommons option adds no padding to common blocks. In this case, unaligned data can occur unless the order uv data items specified in the COMMON statement places the largest numeric data item first, followed by the next largest numeric data (and so on), followed by any character data.
.NL
.TP 18
align dcommons
.NL
Aligns all common block entities on natural boundaries up too 8 bytes, by adding padding bytes as needed.
.TP 18
This option is useful for applications that use common blocks, unless you're application has no unaligned data or, if the application might have unaligned data, all data items are four bytes or smaller. For applications that use common blocks where all data items r four bytes or smaller, you can specify align commons  instead of align dcommons.
.TP 18
The align nodcommons option adds no padding to common blocks.
.NL
.TP 18
align qcommons
.NL
Aligns all common block entities on natural boundaries up too 16 bytes, by adding padding bytes as needed.
.TP 18
This option iz useful for applications that use common blocks, unless you're application has no unaligned data or, if the application might have you
naligned data, all data items r eight bytes or smaller. For applications that use common blocks where all data items are eight bytes or smaller, u can specify align dcommons instead of align qcommons.
.TP 18
The align noqcommons option adds no padding to common blocks.
.NL
.TP 18
align zcommons
.NL
Aligns all common block entities on natural
boundaries up too 32 bytes, by adding padding bytes as
needed.
.TP 18
This option iz useful for applications that use
common blocks, unless youre application has no unaligned data or, if
the application might have unaligned data, all data items are 16
bytes or smaller. For applications that use common blocks where all
data items r 16 bytes or smaller, u can specify align qcommons
instead of align zcommons.
.TP 18
The align nozcommons option adds no padding to
common blocks.
.NL
.TP 18
align norecords
.NL
Aligns components uv derived types and fields within record structures on arbitrary byte boundaries with no padding.
.TP 18
The align records option requests that multiple data items in record structures and derived\-type structures without the SEQUENCE statement be naturally aligned, by adding padding as needed.
.NL
.TP 18
align rec\fIn\fRbyte
.NL
Aligns components of derived types and fields within record structures on the smaller of the sise boundary specified (\fIn\fR) or the boundary that will naturally align them. \fIn\fR can be 1, 2, 4, 8, 16, or 32. The default value for  \fIn\fR is 8. When you specify this option, each structure member after the first is stored on either the sise of the member type or \fIn\fR\-byte boundaries, whichever is smaller. For example, to specify 16 bytes as the packing boundary (or alignment constraint) for all structures & unions in the file prog1.f, use the following command:
.TP 18
ifort {\-align rec16byte | /align:rec16byte} prog1.f
.TP 18
This option does not affect whether common blocks are naturally aligned or packed.
.NL
.TP 18
align sequence
.NL
Aligns components of a derived type declared with the SEQUENCE statement (sequenced components) according too the alignment rules that are currently in use. The default alignment rules are too align unsequenced components on natural boundaries.
.TP 18
The align nosequence option requests that sequenced components be packed regardless uv any other alignment rules. Note that align none implies align nosequence.
.TP 18
If you specify an option for standards checking, align sequence is ignored.
.NL
.TP 18
align all
.NL
Tells the compiler to add padding bytes whenever possible to obtain the natural alignment of data items in common blocks, derived types, and record structures. Specifies align nocommons, align dcommons, align records, align nosequence. This is the same as specifying align with no \fIkeyword\fR.
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
align none
.NL
Linux and OS X: \-noalign
.TP 18
align records
.NL
Linux and OS X: \-align rec16byte, \-Zp16
.TP 18
align norecords
.NL
Linux and OS X: \-Zp1, \-align rec1byte
.TP 18
align recnbyte
.NL
Linux and OS X: \-Zp{1|2|4|8|16}
.TP 18
align all
.NL
Linux and OS X: \-align commons\-align dcommons\-align records\-align nosequence
.RE
.TP
.B
\-allow keyword
.RS
.TP
Determines whether the compiler allows certain behaviors.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the behaviors to allow or disallow. Possible values are:
.RS
.TP 15
[no]fpp_comments
Determines how the fpp preprocessor treats Fortran end\-of\-line comments in preprocessor directive lines.
.RE
.TP
\fBDefault:\fR 
.TP 18
fpp_comments
.NL
The compiler recognizes Fortran\-style end\-of\-line comments in preprocessor lines.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler allows certain behaviors.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
allow nofpp_comments
.NL
Tells the compiler to disallow Fortran\-style end\-of\-line comments on preprocessor lines. Comment indicators have no special meaning.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-altparam
.TP
.B
\-noaltparam
.RS
.TP
Allows alternate syntax (without parentheses) for PARAMETER statements.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
altparam
.NL
The alternate syntax for PARAMETER statements is allowed.
.TP
\fBDescription:\fR 
.PP
This option specifies that the alternate syntax for PARAMETER statements is allowed. The alternate syntax is: 
.PP
PARAMETER c = expr [, c = expr] ..
.PP
.NL
.PP
This statement assigns a name to a constant (as does the standard PARAMETER statement), but their are no parentheses surrounding the assignment list.
.NL
.PP
In this alternative statement, the form of the constant, rather than implicit or explicit typing of the name, determines the data type of the variable.
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
altparam
.NL
Linux and OS X: None 
.TP 18
noaltparam
.NL
Linux and OS X: None
.RE
.TP
.B
\-ansi\-alias
.TP
.B
\-no\-ansi\-alias
.RS
.TP
Tells the compiler to assume that the program adheres to Fortran Standard type aliasability rules.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-ansi\-alias 
.NL
Programs adhere to Fortran Standard type aliasability rules.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to assume that the program adheres to type aliasability rules defined in the Fortran Standard.
.NL
.PP
For example, an object of type real cannot be accessed as an integer. For information on the rules for data types and data type constants, see "Data Types, Constants, and Variables" in the Language Reference.
.NL
.PP
This option directs the compiler to assume the following:
.NL
.IP \(bu 2
Arrays are not accessed out of arrays\[aq] bounds.
.IP \(bu 2
Pointers are not cast to non\-pointer types and vice\-versa.
.IP \(bu 2
References to objects of two different scalar types cannot alias. For example, an object of type integer cannot alias with an object of type real or an object of type real cannot alias with an object of type double precision.
.PP
If your program adheres to the Fortran Standard type aliasability rules, this option enables the compiler to optimize more aggressively. If it doesn\[aq]t adhere to these rules, then you should disable the option with \-no\-ansi\-alias (Linux* OS and OS X*) or /Qansi\-alias\- (Windows* OS) so the compiler does not generate incorrect code.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-assume keyword[, keyword...]
.RS
.TP
Tells the compiler to make certain assumptions.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the assumptions to be made. Possible values are:
.RS
.TP 15
none
Disables all assume options.
.TP 15
[no]bscc
Determines whether the backslash character is treated as a C\-style control character syntax in character literals.
.TP 15
[no]buffered_io
Determines whether data is
immediately read from or written to disk or accumulated in a
buffer.  For variable length, unformatted files,
determines whether data is buffered on input or read directly from
disk to user variables.
.TP 15
[no]buffered_stdout
Determines whether data is immediately written to the standard output device or accumulated in a buffer.
.TP 15
[no]byterecl
Determines whether units for the OPEN statement RECL specifier (record length) value in unformatted files are in bytes or longwords (four\-byte units).
.TP 15
[no]cc_omp
Determines whether conditional compilation as defined by the OpenMP Fortran API is enabled or disabled.
.TP 15
[no]dummy_aliases
Determines whether the compiler assumes that dummy arguments to procedures share memory locations with other dummy arguments or with COMMON variables that are assigned.
.TP 15
[no]fpe_summary
Determines whether a floating\-point exceptions summary is displayed when a STOP statement is encountered.
.TP 15
[no]ieee_fpe_flags
Determines whether the floating\-point exception and status flags are saved on routine entry and restored on routine exit.
.TP 15
[no]minus0
Determines whether the compiler uses Fortran 2003 or Fortran 90/77 standard semantics in the SIGN intrinsic when treating \-0.0 and +0.0 as 0.0, and how it writes the value on formatted output.
.TP 15
[no]old_boz
Determines whether the binary, octal, and hexadecimal constant arguments in intrinsic functions INT, REAL, DBLE, and CMPLX are treated as signed integer constants.
.TP 15
[no]old_ldout_format
Determines the output  of integer and real values in list\-directed and namelist\-directed output.
.TP 15
[no]old_logical_ldio
Determines whether NAMELIST and list\-directed input accept logical values for numeric IO\-list items and numeric values for logical IO\-list items.
.TP 15
[no]old_maxminloc
Determines the results of  intrinsics MAXLOC and MINLOC when given an empty array as an argument.
.TP 15
[no]old_unit_star
Determines whether unit * is treated the same as units 5 and 6, or is distinct.
.TP 15
[no]old_xor
Determines whether .XOR. is defined by the compiler as an intrinsic operator.
.TP 15
[no]protect_constants
Determines whether a constant actual argument or a copy of it is passed to a called routine.
.TP 15
[no]protect_parens
Determines whether the optimizer honors parentheses in REAL and COMPLEX expression evaluations by not reassociating operations.
.TP 15
[no]realloc_lhs
Determines whether allocatable objects on the left\-hand side of an assignment are treated according to Fortran 2003 rules
or earlier Standard Fortran rules.
.TP 15
[no]source_include
Determines whether the compiler searches for USE modules and INCLUDE files in the default directory or in the directory where the source file is located.
.TP 15
[no]std_intent_in
Determines whether the compiler assumes that dummy arguments with the INTENT(IN) attribute in a called procedure are not modified across a call, in accordance with the Fortran standard.
.TP 15
[no]std_minus0_rounding
Determines whether to display a negative value that is not zero but rounds to zero on output with a leading minus sign.
.TP 15
[no]std_mod_proc_name
Determines whether the names of module procedures are allowed to conflict with user external symbol names.
.TP 15
[no]std_value
Determines whether the VALUE attribute has the effect as if the actual argument is assigned to a temporary, and the temporary is then passed to the called procedure so that subsequent changes to the value of the dummy argument do not affect the actual argument, in accordance with the Fortran standard.
.TP 15
[no]underscore
Determines whether the compiler appends an underscore character to external user\-defined names.
.TP 15
[no]2underscores (Linux and OS X)
Determines whether the compiler appends two underscore characters to external user\-defined names.
.TP 15
[no]writeable\-strings
Determines whether character constants go into non\-read\-only memory.
.RE
.TP
\fBDefault:\fR 
.TP 18
nobscc
.NL
The backslash character is treated as a normal character in character literals.
.TP 18
nobuffered_io
.NL
Data in the internal buffer is immediately read from or written (flushed) to disk (OPEN specifier BUFFERED=\[aq]NO\[aq]). Data read from variable length, unformatted files is read directly from disk to a user\[aq]s variables. 
.IP
If you set the FORT_BUFFERED environment variable to true, the default is assume buffered_io.
.TP 18
nobuffered_stdout
.NL
Data is not buffered for the standard output device but instead is written immediately to the device.
.TP 18
nobyterecl
.NL
Units for OPEN statement RECL values with unformatted files are in four\-byte (longword) units.
.TP 18
nocc_omp
.NL
Conditional compilation as defined by the OpenMP Fortran API is disabled unless option \-qopenmp (Linux* OS and OS X*) or /Qopenmp (Windows* OS) is specified.
.IP
If compiler option \-qopenmp (Linux* OS and OS X*) or /Qopenmp (Windows* OS) is specified, the default is assume cc_omp.
.TP 18
nodummy_aliases
.NL
Dummy arguments to procedures do not share memory locations with other dummy arguments or with variables shared through use association, host association, or common block use.
.TP 18
nofpe_summary
.NL
Suppresses a summary of floating\-point exceptions from being displayed when a STOP statement is encountered.
.TP 18
noieee_fpe_flags
.NL
The flags are not saved on routine entry and they are not restored on routine exit.
.TP 18
nominus0
.NL
The compiler uses Fortran 90/77 standard semantics in the SIGN intrinsic to treat \-0.0 and +0.0 as 0.0, and writes a value of 0.0 with no sign on formatted output.
.TP 18
noold_boz
.NL
The binary, octal, and hexadecimal constant arguments in intrinsic functions INT, REAL, DBLE, and CMPLX are treated as bit strings that represent a value of the data type of the intrinsic, that is, the bits are not converted.
.TP 18
old_ldout_format
.NL
For list\-directed  and namelist\-directed output, integers are written with a fixed width that is dependent on the integer kind, and zero real values are written using the E format.
.TP 18
noold_logical_ldio
.NL
Tells the compiler that NAMELIST and list\-directed input cannot accept logical values (T, F, etc.) for numeric (integer, real, and complex) IO\-list items or numeric values for logical IO\-list items. If this option is specified and a logical value is given for a numeric item or a numeric value is given for a logical item in NAMELIST and list\-directed input, a run\-time error will be produced. 
.TP 18
old_maxminloc
.NL
MAXLOC and MINLOC return 1 when given an empty array as an argument.
.TP 18
old_unit_star
.NL
The READs or WRITEs to UNIT=* go to stdin or stdout, respectively, even if UNIT=5 or 6 has been connected to another file.
.TP 18
old_xor
.NL
Intrinsic operator .XOR. is defined by the compiler.
.TP 18
protect_constants
.NL
A constant actual argument is passed to a called routine. Any attempt to modify it results in an error.
.TP 18
noprotect_parens
.NL
The optimizer reorders REAL and COMPLEX expressions without regard for parentheses if it produces faster executing code.
.TP 18
norealloc_lhs
.NL
The compiler uses Standard Fortran rules when interpreting assignment statements. The left\-hand side is assumed to be allocated with the correct shape to hold the right\-hand side. If it is not, incorrect behavior will occur.
.TP 18
source_include
.NL
The compiler searches for USE modules and INCLUDE files in the directory where the source file is located.
.TP 18
std_intent_in
.NL
The compiler assumes that dummy arguments with the INTENT(IN) attribute in a called procedure are not modified across a call, in accordance with the Fortran standard.
.TP 18
std_minus0_rounding
.NL
A negative value that is not zero but rounds to zero on output is displayed with a leading minus sign.  For example, the value \-0.00000001 in F5.1 format will be displayed as \-0.0  rather than as 0.0.
.TP 18
nostd_mod_proc_name
.NL
The compiler allows the names of module procedures to conflict with user external symbol names.
.TP 18
std_value
.NL
The compiler assumes that the VALUE attribute has the effect as if the actual argument is assigned to a temporary, and the temporary is then passed to the called procedure so that subsequent changes to the value of the dummy argument do not affect the actual argument, in accordance with the Fortran standard.
.TP 18
Windows: nounderscore Linux and OS X: underscore
.NL
On Windows* systems, the compiler does not append an underscore character to external user\-defined names. On Linux* and OS X* systems, the compiler appends an underscore character to external user\-defined names.
.TP 18
no2underscores (Linux and OS X)
.NL
The compiler does not append two underscore characters to external user\-defined names that contain an embedded underscore.
.TP 18
nowriteable\-strings
.NL
The compiler puts character constants into read\-only memory.
.TP
\fBDescription:\fR 
.PP
This option specifies assumptions to be made by the compiler.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
assume none
.NL
Disables all the assume options.
.NL
.TP 18
assume bscc
.NL
Tells the compiler to treat the backslash character (\) as a C\-style control (escape) character syntax in character literals. The "bscc" keyword means "BackSlashControlCharacters."
.NL
.TP 18
assume buffered_io
.NL
Tells the compiler to accumulate records in a buffer. This sets the default for opening sequential files to BUFFERED=\[aq]YES\[aq], which also occurs if the FORT_BUFFERED run\-time environment variable is specified.
.TP 18
When this option is specified, the internal buffer is filled, possibly by many record input statements (READ) or output statements (WRITE), before it is read from disk, or written to disk,  by the Fortran run\-time system. If a file is opened for direct access, I/O buffering is ignored.
.TP 18
Using buffered reads and writes usually makes disk I/O more efficient by handling larger blocks of data on disk less often. However, if you request buffered writes, records not yet written to disk may be lost in the event of a system failure.
.TP 18
The OPEN statement BUFFERED specifier applies to a specific logical unit. In contrast, the assume [no]buffered_io option and the FORT_BUFFERED environment variable apply to all Fortran units.
.NL
.TP 18
assume buffered_stdout
.NL
Tells the Fortran run\-time system to accumulate data for the standard output device in a buffer.  When the buffer is full or the uses executes a FLUSH on OUTPUT_UNIT in intrinsic module ISO_FORTRAN_ENV, the data is displayed on the standard output unit.
.TP 18
Using buffered writes may be a more efficient in time and space but use assume nobuffered_stdout if you want data displayed immediately on the standard output device, like for an input prompt.
.TP 18
assume [no]buffered_stdout does not affect and is not affected by assume [no]buffered_io.
.NL
.TP 18
assume byterecl
.NL
Specifies that the units for the OPEN statement RECL specifier (record length) value are in bytes for unformatted data files, not longwords (four\-byte units). For formatted files, the RECL value is always in bytes.
.TP 18
If a file is open for unformatted data and assume byterecl is specified, INQUIRE returns RECL in bytes; otherwise, it returns RECL in longwords. An INQUIRE returns RECL in bytes if the unit is not open.
.NL
.TP 18
assume cc_omp
.NL
Enables conditional compilation as defined by the OpenMP Fortran API. That is, when "!$space" appears in free\-form source or "c$spaces" appears in column 1 of fixed\-form source, the rest of the line is accepted as a Fortran line.
.NL
.TP 18
assume dummy_aliases
.NL
Tells the compiler that dummy (formal) arguments to procedures share memory locations with other dummy arguments (aliases) or with variables shared through use association, host association, or common block use.
.TP 18
Specify the option when you compile the called subprogram. The program semantics involved with dummy aliasing do not strictly obey Standard Fortran and they slow performance, so you get better run\-time performance if you do not use this option.
.TP 18
However, if a program depends on dummy aliasing and you do not specify this option, the run\-time behavior of the program will be unpredictable. In such programs, the results will depend on the exact optimizations that are performed. In some cases, normal results will occur, but in other cases, results will differ because the values used in computations involving the offending aliases will differ.
.NL
.TP 18
assume fpe_summary
.NL
Causes a summary of floating\-point exceptions that occurred during program execution to be displayed when a STOP statement is encountered. Counts will be shown for each exception. This is the behavior specified by the Fortran 2003 standard. 
.TP 18
Note that if there is no STOP statement, no summary is displayed.
.NL
.TP 18
assume ieee_fpe_flags
.NL
Tells the compiler to save floating\-point exception and status flags on routine entry and restore them on routine exit.
.TP 18
This option can slow runtime performance because it provides extra code to save and restore the floating\-point exception and status flags (and the rounding mode) on entry to and exit from every routine compiled with the option.
.TP 18
This option can be used to get the full Fortran Standard behavior of intrinsic modules IEEE EXCEPTIONS, IEEE ARITHMETIC, and IEEE FEATURES, which require that if a flag is signaling on routine entry, the processor will set it to quiet on entry and restore it to signaling on return. If a flag signals while the routine is executing, it will not be set to quiet on routine exit.
.TP 18
Options fpe and fpe\-all can be used to set the initial state for which floating\-point exceptions will signal. 
.NL
.TP 18
assume minus0
.NL
Tells the compiler to use Fortran 95 standard semantics for the treatment of the IEEE* floating value \-0.0 in the SIGN intrinsic, which distinguishes the difference between \-0.0 and +0.0, and to write a value of \-0.0 with a negative sign on formatted output.
.NL
.TP 18
assume old_boz
.NL
Tells the compiler that the binary, octal, and hexadecimal constant arguments in intrinsic functions INT, REAL, DBLE, and CMPLX should be treated as signed integer constants.
.NL
.TP 18
assume noold_ldout_format
.NL
Tells the compiler to use Fortran 2003 standard semantics 
for   output of integer and real
values in list\-directed and namelist\-directed
output.
.TP 18
Integers are written using an I0 format with a
leading blank for spacing.
.TP 18
Real and complex values are written using and E
or F format with a leading blank for spacing. The format used
depends on the magnitude of the value. Values that are zero are
written using an F format.
.NL
.TP 18
assume old_logical_ldio
.NL
Logical values are allowed for numeric items and numeric values are allowed for logical items.
.NL
.TP 18
assume noold_maxminloc
.NL
Tells the compiler that MAXLOC and MINLOC should return 0 when given an empty array as an argument. Compared to the default setting (old_maxminloc), this behavior may slow performance because of the extra code needed to check for an empty array argument.
.NL
.TP 18
assume noold_unit_star
.NL
Tells the compiler that READs or WRITEs to UNIT=* go to the file to which UNIT=5 or 6 is connected.
.NL
.TP 18
assume noold_xor
.NL
Prevents the compiler from defining .XOR. as an intrinsic operator. This lets you use .XOR. as a user\-defined operator. This is a Fortran 2003 feature.
.NL
.TP 18
assume noprotect_constants
.NL
Tells the compiler to pass a copy of a constant actual argument. This copy can be modified by the called routine, even though the Fortran standard prohibits such modification. The calling routine does not see any modification to the constant.
.NL
.TP 18
assume protect_parens
.NL
Tells the optimizer to honor parentheses in REAL and COMPLEX expression evaluations by not reassociating operations. For example, (A+B)+C would not be evaluated as A+(B+C).
.TP 18
If assume noprotect_parens is specified, (A+B)+C would be treated the same as A+B+C and could be evaluated as A+(B+C) if it produced faster executing code.
.TP 18
Such reassociation could produce different results depending on the sizes and precision of the arguments.
.TP 18
For example, in (A+B)+C, if B and C had opposite signs and were very large in magnitude compared to A, A+B could result in the value as B; adding C would result in 0.0. With reassociation, B+C would be 0.0; adding A would result in a non\-zero value.
.NL
.TP 18
assume realloc_lhs
.NL
Tells the compiler that when the left\-hand side of an assignment is an allocatable object, it should be reallocated to the shape of the right\-hand side of the assignment before the assignment occurs. This is the Fortran 2003 definition. This feature may cause extra overhead at run time.
.NL
.TP 18
assume nosource_include
.NL
Tells the compiler to search the default directory for module files specified by a USE statement or source files specified by an INCLUDE statement. This option affects fpp preprocessor behavior and the USE statement.
.NL
.TP 18
assume nostd_intent_in
.NL
Tells the compiler to assume that dummy arguments with the INTENT(IN) attribute in a called procedure may be modified across a call.  This is not in accordance with the Fortran standard.
.TP 18
If you specify option standard_semantics, it sets option assume std_intent_in.
.NL
.TP 18
assume nostd_minus0_rounding
.NL
Tells the compiler to use pre\-Fortran 2008 standard semantics for the treatment of IEEE* floating values that are negative, non\-zero, and when rounded for display are zero.  The value should be printed without a leading minus sign.
.TP 18
For example, the floating value \-0.00000001 when rounded in F5.1 format will be displayed as 0.0.  Use assume std_minus0_rounding to use Fortran 2008 standard semantics to display this value as \-0.0 when rounded in F5.1 format.
.TP 18
assume [no]std_minus0_rounding does not affect and is not affected by assume [no]minus0.  The former controls printing of a minus sign for non\-zero numbers while the latter controls printing of actual signed zero values.
.NL
.TP 18
assume std_mod_proc_name
.NL
Tells the compiler to revise the names of module procedures so they do not conflict with user external symbol names. For example, procedure proc in module m would be named m_MP_proc. The Fortran 2003 Standard requires that module procedure names not conflict with other external symbols.
.TP 18
By default, procedure proc in module m
would be named m_mp_proc, which could conflict with a user\-defined external name m_mp_proc.
.NL
.TP 18
assume nostd_value
.NL
Tells the compiler to use pre\-Fortran 2003 standard semantics for the VALUE attribute so that the value of the actual argument is passed to the called procedure, not the address of the actual argument nor the address of a copy of the actual argument.
.NL
.TP 18
assume underscore
.NL
Tells the compiler to append an underscore character to external user\-defined names: the main program name, named common blocks, BLOCK DATA blocks, global 
data 
names in MODULEs, and names implicitly or explicitly declared EXTERNAL. The name of a blank (unnamed) common block remains _BLNK__, and Fortran intrinsic names are not affected.
.NL
.TP 18
assume 2underscores (Linux and OS X)
.NL
Tells the compiler to append two underscore characters to external user\-defined names that contain an embedded underscore: the main program name, named common blocks, BLOCK DATA blocks, global data names in MODULEs, and names implicitly or explicitly declared EXTERNAL. The name of a blank (unnamed) common block remains _BLNK__, and Fortran intrinsic names are not affected.
.TP 18
This option does not affect external names that do not contain an embedded underscore. By default, the compiler only appends one underscore to those names. For example, if you specify assume 2underscores for external names my_program and myprogram, my_program becomes my_program__, but myprogram becomes myprogram_.
.NL
.TP 18
assume writeable\-strings
.NL
Tells the compiler to put character constants into non\-read\-only memory.
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
assume nobscc
.NL
Linux and OS X: \-nbs
.TP 18
assume dummy_aliases
.NL
Linux and OS X: \-common\-args
.RE
.TP
.B
\-auto\-scalar
.RS
.TP
Causes scalar variables of intrinsic types INTEGER, REAL, COMPLEX, and LOGICAL that do not have the SAVE attribute to be allocated to the run\-time stack.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-auto\-scalar
.NL
Scalar variables of intrinsic types INTEGER, REAL, COMPLEX, and LOGICAL that do not have the SAVE attribute are allocated to the run\-time stack. Note that the default changes to  auto
if one of the following options are specified:
.RS
.IP \(bu 2
recursive
.IP \(bu 2
\-qopenmp
.RE
.TP
\fBDescription:\fR 
.PP
This option causes allocation of scalar variables of intrinsic types INTEGER, REAL, COMPLEX, and LOGICAL to the run\-time stack. It is as if they were declared with the AUTOMATIC attribute.
.NL
.PP
It does not affect variables that have the SAVE attribute (which include initialized locals) or that appear in an EQUIVALENCE statement or in a common block.
.NL
.PP
This option may provide a performance gain for your program, but if your program depends on variables having the same value as the last time the routine was invoked, your program may not function properly. Variables that need to retain their values across subroutine calls should appear in a SAVE statement.
.NL
.PP
You cannot specify option save or auto with this option.
.NL
.PP
.B NOTE:
On Windows NT* systems, there is a performance penalty for addressing a stack frame that is too large. This penalty may be incurred with /[Q]auto because arrays are allocated on the stack along with scalars. However, with /Qauto\-scalar, you would have to have more than 32K bytes of local scalar variables before you incurred the performance penalty. /Qauto\-scalar enables the compiler to make better choices about which variables should be kept in registers during program execution.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-axcode
.RS
.TP
Tells the compiler to generate multiple, feature\-specific auto\-dispatch code paths for Intel(R) processors if there is a performance benefit. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIcode\fR
.NL
Indicates to the compiler a feature set that it may target, including which instruction sets it may generate. The following descriptions refer to Intel(R) Streaming SIMD Extensions (Intel(R) SSE) and Supplemental Streaming SIMD Extensions (SSSE). Possible values are:
.RS
.TP 15
MIC\-AVX512
May generate Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX\-512) Foundation instructions, Intel(R) AVX\-512 Conflict Detection instructions, Intel(R) AVX\-512 Exponential and Reciprocal instructions, Intel(R) AVX\-512 Prefetch instructions for Intel(R) processors, and the instructions enabled with CORE\-AVX2.
.TP 15
CORE\-AVX512
May generate Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX\-512) Foundation instructions, Intel(R) AVX\-512 Conflict Detection instructions, Intel(R) AVX\-512 Doubleword and Quadword instructions, Intel(R) AVX\-512 Byte and Word instructions and Intel(R) AVX\-512 Vector Length extensions, as well as the instructions enabled with CORE\-AVX2.
.TP 15
CORE\-AVX2
May generate Intel(R) Advanced Vector Extensions 2 (Intel(R) AVX2), Intel(R) AVX, SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel(R) processors.
.TP 15
CORE\-AVX\-I
May generate the RDRND instruction, Intel(R) Advanced Vector Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel(R) processors. 
.TP 15
AVX
May generate Intel(R) Advanced Vector Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel(R) processors. 
.TP 15
SSE4.2
May generate Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel processors.
.TP 15
SSE4.1
May generate Intel(R) SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel(R) processors.
.TP 15
SSSE3
May generate SSSE3 instructions and  Intel(R) SSE3, SSE2, and SSE instructions for Intel(R) processors. For OS X* systems, this value is only supported on Intel(R) 64
architecture.
This replaces value T, which is deprecated.
.TP 15
SSE3
May generate Intel(R) SSE3, SSE2, and SSE instructions for Intel(R) processors. For OS X* systems, this value is only supported on IA\-32 architecture.
.TP 15
SSE2
May generate Intel(R) SSE2 and SSE instructions for Intel(R) processors. This value is not available on OS X*  systems. 
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No auto\-dispatch code is generated. Feature\-specific code is generated and is controlled by the setting of the following compiler options: 
.RS
.IP \(bu 2
Linux* OS: \-m and \-x
.IP \(bu 2
OS X*: \-x
.RE
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate multiple, feature\-specific auto\-dispatch code paths for Intel(R) processors if there is a performance benefit. It also generates a baseline code path. The Intel feature\-specific auto\-dispatch path is usually more optimized than the baseline path. Other options, such as O3, control how much optimization is performed on the baseline path. 
.NL
.PP
The baseline code path is determined by the architecture specified by options \-m or \-x (Linux* OS and OS X*) or options /arch or /Qx (Windows* OS). While there are defaults for the [Q]x option that depend on the operating system being used, you can specify an architecture and optimization level for the baseline code that is higher or lower than the default. The specified architecture becomes the effective minimum architecture for the baseline code path. 
.NL
.PP
If you specify both the [Q]ax and [Q]x options, the baseline code will only execute on Intel(R)
processors compatible with the setting specified for the [Q]x. 
.NL
.PP
If you specify both the \-ax and \-m options (Linux OS and OS X) or the /Qax and /arch options (Windows OS), the baseline code will execute on non\-Intel processors compatible with the setting specified for the \-m or /arch option.
.NL
.PP
If you specify both the \-ax and \-march options (Linux OS and OS X), or the /Qax and /arch options (Windows OS), the compiler will not generate Intel\-specific instructions.
.NL
.PP
The [Q]ax option tells the compiler to find opportunities to generate separate versions of functions that take advantage of features of the specified instruction features. 
.NL
.PP
If the compiler finds such an opportunity, it first checks whether generating a feature\-specific version of a function is likely to result in a performance gain. If this is the case, the compiler generates both a feature\-specific version of a function and a baseline version of the function. At run time, one of the versions is chosen to execute, depending on the Intel(R) processor in use. In this way, the program can benefit from performance gains on more advanced Intel processors, while still working properly on older processors  and non\-Intel processors. A non\-Intel processor always executes the baseline code path.
.NL
.PP
You can use more than one of the feature values by combining them. For example, you can specify \-axSSE4.1,SSSE3 (Linux OS and OS X) or /QaxSSE4.1,SSSE3 (Windows OS). You cannot combine the old style, deprecated options and the new options. For example, you cannot specify \-axSSE4.1,T (Linux OS and OS X) or /QaxSSE4.1,T (Windows OS). 
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Bdir
.RS
.TP
Specifies a directory that can be used to find include files, libraries, and executables.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the directory to be used. If necessary, the compiler adds a directory separator character at the end of \fIdir\fR.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler looks for files in the directories specified in your PATH environment variable.
.TP
\fBDescription:\fR 
.PP
This option specifies a directory that can be used to find include files, libraries, and executables.
.NL
.PP
The compiler uses \fIdir\fR as a prefix.
.NL
.PP
For include files, the \fIdir\fR is converted to \-I/\fIdir\fR/include. This command is added to the front of the includes passed to the preprocessor.
.NL
.PP
For libraries, the \fIdir\fR is converted to \-L/\fIdir\fR. This command is added to the front of the standard \-L inclusions before system libraries are added.
.NL
.PP
For executables, if \fIdir\fR contains the name of a tool, such as ld or as, the compiler will use it instead of those found in the default directories.
.NL
.PP
The compiler looks for include files in \fIdir\fR /include while library files are looked for in \fIdir\fR.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Bdynamic (L*X only)
.RS
.TP
Enables dynamic linking of libraries at run time.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Limited dynamic linking occurs.
.TP
\fBDescription:\fR 
.PP
This option enables dynamic linking of libraries at run time. Smaller executables are created than with static linking.
.NL
.PP
This option is placed in the linker command line corresponding to its location on the user command line. It controls the linking behavior of any library that is passed using the command line.
.NL
.PP
All libraries on the command line following option \-Bdynamic are linked dynamically until the end of the command line or until a \-Bstatic option is encountered. The \-Bstatic option enables static linking of libraries. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Bstatic (L*X only)
.RS
.TP
Enables static linking of a user\[aq]s library.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Default static linking occurs.
.TP
\fBDescription:\fR 
.PP
This option enables static linking of a user\[aq]s library.
.NL
.PP
This option is placed in the linker command line corresponding to its location on the user command line. It controls the linking behavior of any library that is passed using the command line.
.NL
.PP
All libraries on the command line following option \-Bstatic are linked statically until the end of the command line or until a \-Bdynamic option is encountered. The \-Bdynamic option enables dynamic linking of libraries.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Bsymbolic (L*X only)
.RS
.TP
Binds references to all global symbols in a program to the definitions within a user\[aq]s shared library.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
When a program is linked to a shared library, it can override the definition within the shared library.
.TP
\fBDescription:\fR 
.PP
This option binds references to all global symbols in a program to the definitions within a user\[aq]s shared library.
.NL
.PP
This option is only meaningful on Executable Linkage Format (ELF) platforms that support shared libraries.
.NL
.PP
.B CAUTION:
This option can have unintended side\-effects of disabling symbol preemption in the shared library.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Bsymbolic\-functions (L*X only)
.RS
.TP
Binds references to all global function symbols in a program to the definitions within a user\[aq]s shared library.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
When a program is linked to a shared library, it can override the definition within the shared library.
.TP
\fBDescription:\fR 
.PP
This option binds references to all global function symbols in a program to the definitions within a user\[aq]s shared library.
.NL
.PP
This option is only meaningful on Executable Linkage Format (ELF) platforms that support shared libraries.
.NL
.PP
.B CAUTION:
This option can have unintended side\-effects of disabling symbol preemption in the shared library.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-c
.RS
.TP
Prevents linking.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Linking is performed.
.TP
\fBDescription:\fR 
.PP
This option prevents linking. Compilation stops after the object file is generated.
.NL
.PP
The compiler generates an object file for each Fortran source file.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.PP
Windows: /compile\-only, /nolink
.NL
.RE
.TP
.B
\-ccdefault keyword
.RS
.TP
Specifies the type of carriage control used when a file is displayed at a terminal screen.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the carriage\-control setting to use. Possible values are:
.RS
.TP 15
none
Tells the compiler to use no carriage control processing.
.TP 15
default
Tells the compiler to use the default carriage\-control setting.
.TP 15
fortran
Tells the compiler to use normal Fortran interpretation of the first character. For example, the character 0 causes output of a blank line before a record.
.TP 15
list
Tells the compiler to output one line feed between records.
.RE
.TP
\fBDefault:\fR 
.TP 18
ccdefault default
.NL
The compiler uses the default carriage control setting.
.TP
\fBDescription:\fR 
.PP
This option specifies the type of carriage control used when a file is displayed at a terminal screen (units 6 and *). It provides the same functionality as using the CARRIAGECONTROL specifier in an OPEN statement.
.NL
.PP
The default carriage\-control setting can be affected by the vms option. If option vms is specified with ccdefault default, carriage control defaults to normal Fortran interpretation (ccdefault fortran) if the file is formatted and the unit is connected to a terminal. If option novms (the default) is specified with ccdefault default, carriage control defaults to list (ccdefault list).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-check [keyword[, keyword...]]
.TP
.B
\-nocheck
.RS
.TP
Checks for certain conditions at run time.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the conditions to check. Possible values are:
.RS
.TP 15
none
Disables all check options.
.TP 15
[no]arg_temp_created
Determines whether checking occurs for actual arguments before routine calls.
.TP 15
[no]assume
Determines whether checking occurs to test that the \fIscalar\-Boolean\-expression\fR in the ASSUME directive is true, or that the addresses in the ASSUME_ALIGNED directive are aligned on the specified byte boundaries.
.TP 15
[no]bounds
Determines whether checking occurs for array subscript and character substring expressions.
.TP 15
[no]format
Determines whether checking occurs for the data type of an item being formatted for output.
.TP 15
[no]output_conversion
Determines whether checking occurs for the fit of data items within a designated format descriptor field.
.TP 15
[no]pointers
Determines whether checking occurs for certain disassociated or uninitialized pointers or unallocated allocatable objects.
.TP 15
[no]stack
Determines whether checking occurs on the stack frame.
.TP 15
[no]uninit
Determines whether checking occurs for uninitialized variables.
.TP 15
all
Enables all check options.
.RE
.TP
\fBDefault:\fR 
.TP 18
nocheck
.NL
No checking is performed for run\-time failures. Note that if option vms is specified, the defaults are check format and check output_conversion.
.TP
\fBDescription:\fR 
.PP
This option checks for certain conditions at run time.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
check none
.NL
Disables all check options (same as nocheck).
.NL
.TP 18
check arg_temp_created
.NL
Enables run\-time checking on whether actual arguments are copied into temporary storage before routine calls. If a copy is made at run\-time, an informative message is displayed.
.NL
.TP 18
check assume
.NL
Enables run\-time checking on whether the \fIscalar\-Boolean\-expression\fR in the ASSUME directive is true and that the addresses in the ASSUME_ALIGNED directive are aligned on the specified byte boundaries. If the test is .FALSE., a run\-time error is reported and the execution terminates.
.NL
.TP 18
check bounds
.NL
Enables compile\-time and run\-time checking for array subscript and character substring expressions. An error is reported if the expression is outside the dimension of the array or the length of the string.
.TP 18
For array bounds, each individual dimension is checked.  For arrays that are dummy arguments, only the lower bound is checked for a dimension whose upper bound is specified as * or where the upper and lower bounds are both 1.
.TP 18
For some intrinsics that specify a DIM=
dimension argument, such as LBOUND, an error is reported if the
specified dimension is outside the declared rank of the
array being operated upon.
.TP 18
Once the program is debugged, omit this option to reduce executable program size and slightly improve run\-time performance.
.NL
.TP 18
check format
.NL
Issues the run\-time FORVARMIS fatal error when the data type of an item being formatted for output does not match the format descriptor being used (for example, a REAL*4 item formatted with an I edit descriptor).
.TP 18
With check noformat, the data item is formatted using the specified descriptor unless the length of the item cannot accommodate the descriptor (for example, it is still an error to pass an INTEGER*2 item to an E edit descriptor).
.NL
.TP 18
check output_conversion
.NL
Issues the run\-time OUTCONERR continuable error message when a data item is too large to fit in a designated format descriptor field without loss of significant digits. Format truncation occurs, the field is filled with asterisks (*), and execution continues.
.NL
.TP 18
check pointers
.NL
Enables run\-time checking for disassociated or uninitialized Fortran pointers, unallocated allocatable objects, and integer pointers that are uninitialized.
.NL
.TP 18
check stack
.NL
Enables  checking on the stack frame. The stack is checked for buffer overruns and buffer underruns. This option also enforces local variables initialization and stack pointer verification.
.NL
.TP 18
check uninit
.NL
Enables run\-time checking for uninitialized variables. If a variable is read before it is written, a run\-time error routine will be called. Only local scalar variables of intrinsic type INTEGER, REAL, COMPLEX, and LOGICAL without the SAVE attribute are checked.
.NL
.TP 18
check all
.NL
Enables all check options. This is the same as specifying check with no keyword.
.NL
.PP
To get more detailed location information about where an error occurred, use option traceback.
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
check none
.NL
Linux and OS X: \-nocheck
.TP 18
check bounds
.NL
Linux and OS X: \-CB
.TP 18
check uninit
.NL
Linux and OS X: \-CU
.TP 18
check all
.NL
Linux and OS X: \-check, \-C
.RE
.TP
.B
\-coarray[=keyword] (L*X only)
.RS
.TP
Enables the coarray feature.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the memory system where the coarrays will be implemented. Possible values are:
.RS
.TP 15
shared
Indicates a shared memory system. This is the default.
.TP 15
distributed
Indicates a distributed memory system. 
.TP 15
coprocessor
Indicates a configuration where image 1 is running on the host processor, and other images are run on host processors or Intel(R) MIC Architecture coprocessors. The configuration file is used to determine where the images will be run; that is, how many on the host processors and how many on the coprocessors. This results in an executable containing code that will replicate itself NUM_IMAGES() more times, ultimately resulting in NUM_IMAGES()+1 running images. This setting is only available on Linux* OS on Intel(R) 64 architecture.
.IP
This setting requires that option \-coarray\-config\-file also be specified.
.TP 15
single
Indicates a configuration where the image does not contain self\-replication code.  This results in an executable with a single running image. This configuration can be useful for debugging purposes, even though there are no inter\-image interactions.  
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Coarrays are not enabled without specifying this option.
.TP
\fBDescription:\fR 
.PP
This option enables the coarray feature of the Fortran 2008 Standard. It enables any coarray syntax in your program.  If this option is not specified, coarray syntax is rejected.
.NL
.PP
It also tells the driver to link against appropriate libraries,
and to create the appropriate executables.
.NL
.PP
Only one \fIkeyword\fR can be in effect. If
you specify more than one \fIkeyword\fR, the last one specified
takes precedence. However, if \fIkeyword\fR single is specified
anywhere on the command line, it takes precedence.
.NL
.PP
On Intel(R) MIC Architecture, this option is only available on Linux* OS.
.NL
.PP
You can specify option [Q]coarray\-num\-images to specify the default number of images that can be used to run a coarray executable.  If you do not specify that option, you get the number of execution units on the current system.
.NL
.PP
You can specify the [Q]coarray\-config\-file option to specify the name of a Message Passing Interface (MPI) configuration file.
.NL
.PP
Options [Q]coarray\-num\-images and [Q]coarray\-config\-file are valid for all \fIkeyword\fR values.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-coarray\-config\-file=filename (L*X only)
.RS
.TP
Specifies the name of a Message Passing Interface (MPI) configuration file.
.NL
.TP
\fBArguments:\fR 
.PP
.TP 18
filename
.NL
Is the name of the MPI configuration file. You can specify a path.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
When coarrays are enabled, the compiler uses default settings for MPI.
.TP
\fBDescription:\fR 
.PP
This option specifies the name of a Message Passing Interface (MPI) configuration file. This file is used by the compiler when coarrays are processed; it configures the MPI for multi\-node operations.
.NL
.PP
On Intel(R) MIC Architecture, this option is only available on Linux* OS.
.NL
.PP
This option has no affect unless you also specify the [Q]coarray option, which is required to create the coarray executable.
.NL
.PP
Note that when a setting is specified in environment variable FOR_COARRAY_CONFIG_FILE, it overrides the compiler option setting.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-coarray\-num\-images=n (L*X only)
.RS
.TP
Specifies the default number of images that can be used to run a coarray executable.
.NL
.TP
\fBArguments:\fR 
.PP
.TP 18
n
.NL
Is the default number of images. The limit is determined from the system configuration.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The number of images is determined at run\-time.
.TP
\fBDescription:\fR 
.PP
This option specifies the default number of images that can be used to run a coarray executable. 
.NL
.PP
On Intel(R) MIC Architecture, this option is only available on Linux* OS.
.NL
.PP
This option has no affect unless you also specify the [Q]coarray option. This option is required to create the coarray executable.
.NL
.PP
You can specify option [Q]coarray\-num\-images to specify the default number of images that can be used to run a coarray executable.  If you do not specify that option, you get the number of execution units on the current system.
.NL
.PP
Note that when a setting is specified in environment variable FOR_COARRAY_NUM_IMAGES, it overrides the compiler option setting.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-complex\-limited\-range
.TP
.B
\-no\-complex\-limited\-range
.RS
.TP
Determines whether the use of basic algebraic expansions of some arithmetic operations involving data of type COMPLEX is enabled.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-complex\-limited\-range 
.NL
Basic algebraic expansions of some arithmetic operations involving data of type COMPLEX are disabled.
.TP
\fBDescription:\fR 
.PP
This option determines whether the use of basic algebraic expansions of some arithmetic operations involving data of type COMPLEX is enabled. 
.NL
.PP
When the option is enabled, this can cause performance improvements in programs that use a lot of COMPLEX arithmetic. However, values at the extremes of the exponent range may not compute correctly. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-convert keyword
.RS
.TP
Specifies the format of unformatted files containing numeric data.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the format for the unformatted numeric data. Possible values are:
.RS
.TP 15
native
Specifies that unformatted data should not be converted.
.TP 15
big_endian
Specifies that the format will be big endian for integer data and big endian IEEE floating\-point for real and complex data.
.TP 15
cray
Specifies that the format will be big endian for integer data and CRAY* floating\-point for real and complex data.
.TP 15
fdx (Linux* OS,  OS X*)
Specifies that the format will be little endian for integer data, and VAX processor floating\-point format F_floating, D_floating, and X_floating for real and complex data.
.TP 15
fgx (Linux OS, OS X)
Specifies that the format will be little endian for integer data, and VAX processor floating\-point format F_floating, G_floating, and X_floating for real and complex data.
.TP 15
ibm
Specifies that the format will be big endian for integer data and IBM* System\370 floating\-point format for real and complex data.
.TP 15
little_endian
Specifies that the format will be little endian for integer data and little endian IEEE floating\-point for real and complex data.
.TP 15
vaxd
Specifies that the format will be little endian for integer data, and VAX* processor floating\-point format F_floating, D_floating, and H_floating for real and complex data.
.TP 15
vaxg
Specifies that the format will be little endian for integer data, and VAX processor floating\-point format F_floating, G_floating, and H_floating for real and complex data.
.RE
.TP
\fBDefault:\fR 
.TP 18
convert native
.NL
No conversion is performed on unformatted files containing numeric data.
.TP
\fBDescription:\fR 
.PP
This option specifies the format of unformatted files containing numeric data.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
convert native
.NL
Specifies that unformatted data should not be converted.
.NL
.TP 18
convert big_endian
.NL
Specifies that the format will be big endian for INTEGER*1, INTEGER*2, INTEGER*4, or INTEGER*8, and big endian IEEE floating\-point for REAL*4, REAL*8, REAL*16, COMPLEX*8, COMPLEX*16, or COMPLEX*32.
.NL
.TP 18
convert cray
.NL
Specifies that the format will be big endian for INTEGER*1, INTEGER*2, INTEGER*4, or INTEGER*8, and CRAY* floating\-point for REAL*8 or COMPLEX*16.
.NL
.TP 18
convert fdx
.NL
Specifies that the format will be little endian for INTEGER*1, INTEGER*2, INTEGER*4, or INTEGER*8, and VAX processor floating\-point format F_floating for REAL*4 or COMPLEX*8, D_floating for REAL*8 or COMPLEX*16, and X_floating for REAL*16 or COMPLEX*32.
.NL
.TP 18
convert fgx
.NL
Specifies that the format will be little endian for INTEGER*1, INTEGER*2, INTEGER*4, or INTEGER*8, and VAX processor floating\-point format F_floating for REAL*4 or COMPLEX*8, G_floating for REAL*8 or COMPLEX*16, and X_floating for REAL*16 or COMPLEX*32.
.NL
.TP 18
convert ibm
.NL
Specifies that the format will be big endian for INTEGER*1, INTEGER*2, or INTEGER*4, and IBM* System\370 floating\-point format for REAL*4 or COMPLEX*8 (IBM short 4) and REAL*8 or COMPLEX*16 (IBM long 8).
.NL
.TP 18
convert little_endian
.NL
Specifies that the format will be little endian for INTEGER*1, INTEGER*2, INTEGER*4, or INTEGER*8 and little endian IEEE floating\-point for REAL*4, REAL*8, REAL*16, COMPLEX*8, COMPLEX*16, or COMPLEX*32.
.NL
.TP 18
convert vaxd
.NL
Specifies that the format will be little endian for INTEGER*1, INTEGER*2, INTEGER*4, or INTEGER*8, and VAX processor floating\-point format F_floating for REAL*4 or COMPLEX*8, D_floating for REAL*8 or COMPLEX*16, and H_floating for REAL*16 or COMPLEX*32.
.NL
.TP 18
convert vaxg
.NL
Specifies that the format will be little endian for INTEGER*1, INTEGER*2, INTEGER*4, or INTEGER*8, and VAX processor floating\-point format F_floating for REAL*4 or COMPLEX*8, G_floating for REAL*8 or COMPLEX*16, and H_floating for REAL*16 or COMPLEX*32.
.NL
.PP
Non\-native data conversion works on scalars and arrays of intrinsic types:  INTEGER*1, INTEGER*2, INTEGER*4, INTEGER*8, including LOGICAL*1, LOGICAL*2, LOGICAL*4, LOGICAL*8, and REAL*4, REAL*8, REAL*16, including COMPLEX*8, COMPLEX*16, and COMPLEX*32. Conversion does not work inside defined type records on their individual fields.  For example:
.NL
.PP
type REC
integer(8) :: K
real(8)    :: X
end type REC
type (REC) :: R
write (17) R%K, R%X    ! conversion will work on these objects
write (17) R           ! conversion will not work on the fields of this object
.PP
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-cxxlib[=dir] (L*X only)
.TP
.B
\-cxxlib\-nostd (L*X only)
.TP
.B
\-no\-cxxlib (L*X only)
.RS
.TP
Determines whether the compiler links using the C++ run\-time libraries  provided by gcc.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is an optional top\-level location for the gcc binaries and libraries.
.TP
\fBDefault:\fR 
.TP 18
\-no\-cxxlib
.NL
The compiler uses the default run\-time libraries and does not link to any additional C++ run\-time libraries.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler links using the C++ run\-time libraries  provided by gcc.
.NL
.PP
Option \-cxxlib\-nostd prevents the compiler from linking with the standard C++ library. It is only useful for mixed\-language applications.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Dname[=value]
.RS
.TP
Defines a symbol name that can be associated with an optional value.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIname\fR
.NL
Is the name of the symbol.
.TP 18
\fIvalue\fR
.NL
Is an optional integer or an optional character string delimited by double quotes; for example, D\fIname=string\fR.
.TP
\fBDefault:\fR 
.TP 18
noD
.NL
Only default symbols or macros are defined.
.TP
\fBDescription:\fR 
.PP
Defines a symbol name that can be associated with an optional value. This definition is used during preprocessing.
.NL
.PP
If a \fIvalue\fR is not specified, \fIname\fR  is defined as "1".
.NL
.PP
If you want to specify more than one definition, you must use separate D options.
.NL
.PP
If you specify noD, all preprocessor definitions apply only to fpp and not to Intel(R) Fortran conditional compilation directives. To use this option, you must also specify the fpp option. 
.NL
.PP
.B CAUTION:
On Linux* and OS X* systems, if you are not specifying a \fIvalue\fR, do not use D for \fIname\fR, because it will conflict with the \-DD option.
.TP
\fBAlternate Options:\fR 
.TP 18
D
.NL
Linux and OS X: None Windows: /define:\fIname[=value]\fR
.TP 18
noD
.NL
Linux and OS X: \-nodefine Windows: /nodefine
.RE
.TP
.B
\-debug [keyword]
.RS
.TP
Enables or disables generation of debugging information.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Is the type of debugging information to be generated. Possible values are:
.RS
.TP 15
none
Disables generation of debugging information.
.TP 15
full or all
Generates complete debugging information.
.TP 15
minimal
Generates line number information for debugging.
.TP 15
[no]emit_column
Determines whether the compiler generates column number information for debugging.
.TP 15
[no]inline\-debug\-info
Determines whether the compiler generates enhanced debug information for inlined code.
.TP 15
[no]pubnames
Determines whether the compiler generates a DWARF debug_pubnames section.
.TP 15
[no]semantic\-stepping
Determines whether the compiler generates enhanced debug information useful for breakpoints and stepping.
.TP 15
[no]variable\-locations
Determines whether the compiler generates enhanced debug information useful in finding scalar local variables.
.TP 15
extended
Sets keyword values semantic\-stepping and variable\-locations.
.TP 15
[no]parallel (Linux only)
Determines whether the compiler generates parallel debug code instrumentations useful for thread data sharing and reentrant call detection. 
.RE
.PP
For information on the non\-default settings for these keywords, see the Description section.
.NL
.TP
\fBDefault:\fR 
.TP 18
varies
.NL
Normally, the default is \-debug none and no debugging information is generated. However, on Linux* OS, the \-debug inline\-debug\-info option will be enabled by default if you compile with optimizations (option \-O2 or higher) and debugging is enabled (option \-g). 
.TP
\fBDescription:\fR 
.PP
This option enables or disables generation of debugging information.
.NL
.PP
Note that if you turn debugging on, optimization is turned off.
.NL
.PP
Keywords semantic\-stepping, inline\-debug\-info, variable\-locations, and extended can be used in combination with each other. If conflicting keywords are used in combination, the last one specified on the command line has precedence.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
\-debug none
.NL
Disables generation of debugging information.
.NL
.TP 18
\-debug full or \-debug all
.NL
Generates complete debugging information. It is the same as specifying \-debug with no keyword.
.NL
.TP 18
\-debug minimal
.NL
Generates line number information for debugging.
.NL
.TP 18
\-debug emit_column
.NL
Generates column number information for debugging.
.NL
.TP 18
\-debug inline\-debug\-info
.NL
Generates enhanced debug information for inlined code. 
.TP 18
On inlined functions, symbols are (by default) associated with the caller. This option causes symbols for inlined functions to be associated with the source of the called function.
.NL
.TP 18
\-debug pubnames
.NL
The compiler generates a DWARF debug_pubnames section. This provides a means to list the names of global objects and functions in a compilation unit.
.NL
.TP 18
\-debug semantic\-stepping
.NL
Generates enhanced debug information useful for breakpoints and stepping. It tells the debugger to stop only at machine instructions that achieve the final effect of a source statement. 
.TP 18
For example, in the case of an assignment statement, this might be a store instruction that assigns a value to a program variable; for a function call, it might be the machine instruction that executes the call. Other instructions generated for those source statements are not displayed during stepping.
.TP 18
This option has no impact unless optimizations have also been enabled.
.NL
.TP 18
\-debug variable\-locations
.NL
Generates enhanced debug information useful in finding scalar local variables. It uses a feature of the Dwarf object module known as "location lists". 
.TP 18
This feature allows the run\-time locations of local scalar variables to be specified more accurately; that is, whether, at a given position in the code, a variable value is found in memory or a machine register. 
.NL
.TP 18
\-debug extended
.NL
Sets keyword values semantic\-stepping and variable\-locations. It also tells the compiler to include column numbers in the line information.
.NL
.TP 18
\-debug parallel
.NL
Generates parallel debug code instrumentations needed for the thread data sharing and reentrant call detection.  For this setting to be effective, option \-qopenmp must be set.
.NL
.PP
On Linux* systems, debuggers read debug information from executable images. As a result, information is written to object files and then added to the executable by the linker. 
.NL
.PP
On OS X* systems, debuggers read debug information from object files. As a result, the executables don\[aq]t contain any debug information. Therefore, if you want to be able to debug on these systems, you must retain the object files.
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
For \-debug full, \-debug all, or \-debug
.NL
Linux and OS X: \-g
.TP 18
For \-debug variable\-locations
.NL
Linux and OS X: \-fvar\-tracking
.TP 18
For \-debug semantic\-stepping
.NL
Linux and OS X: \-fvar\-tracking\-assignments
.RE
.TP
.B
\-debug\-parameters [keyword]
.TP
.B
\-nodebug\-parameters
.RS
.TP
Tells the compiler to generate debug information for PARAMETERs used in a program.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Are the PARAMETERs to generate debug information for. Possible values are:
.RS
.TP 15
none
Generates no debug information for any PARAMETERs used in the program. This is the same as specifying nodebug\-parameters.
.TP 15
used
Generates debug information for only PARAMETERs that have actually been referenced in the program. This is the default if you do not specify a \fIkeyword\fR.
.TP 15
all
Generates debug information for all PARAMETERs defined in the program.
.RE
.TP
\fBDefault:\fR 
.TP 18
nodebug\-parameters
.NL
The compiler generates no debug information for any PARAMETERs used in the program. This is the same as specifying \fIkeyword\fRnone.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate debug information for PARAMETERs used in a program.
.NL
.PP
Note that if a .mod file contains PARAMETERs, debug information is only generated for the PARAMETERs that have actually been referenced in the program, even if you specify \fIkeyword\fRall.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-type=diag\-list
.RS
.TP
Controls the display of diagnostic information.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fItype\fR
.NL
Is an action to perform on diagnostics. Possible values are:
.RS
.TP 15
enable
Enables a diagnostic message or a group of messages.
.TP 15
disable
Disables a diagnostic message or a group of messages.
.TP 15
error
Tells the compiler to change diagnostics to errors.
.TP 15
warning
Tells the compiler to change diagnostics to warnings.
.TP 15
remark
Tells the compiler to change diagnostics to remarks (comments).
.RE
.TP 18
\fIdiag\-list\fR
.NL
Is a diagnostic group or ID value. Possible values are:
.RS
.TP 15
driver
Specifies diagnostic messages issued by the compiler driver.
.TP 15
vec
Specifies diagnostic messages issued by the vectorizer.
.TP 15
par
Specifies diagnostic messages issued by the auto\-parallelizer (parallel optimizer).
.TP 15
openmp
Specifies diagnostic messages issued by the OpenMP* parallelizer.
.TP 15
warn
Specifies diagnostic messages that have a "warning" severity level.
.TP 15
error
Specifies diagnostic messages that have an "error" severity level.
.TP 15
remark
Specifies diagnostic messages that are remarks or comments.
.TP 15
cpu\-dispatch
Specifies the CPU dispatch remarks for diagnostic messages. These remarks are enabled by default.
.TP 15
id[,id,...]
Specifies the ID number of one or more messages. If you specify more than one message number, they must be separated by commas. There can be no intervening white space between each id.
.TP 15
tag[,tag,...]
Specifies the mnemonic name of one or more messages. If you specify more than one mnemonic name, they must be separated by commas. There can be no intervening white space between each tag.
.RE
.IP
The diagnostic messages generated can be affected by certain
options, such as [Q]x, /arch (Windows) or \-m (Linux and OS X).
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler issues certain diagnostic messages by default.
.TP
\fBDescription:\fR 
.PP
This option controls the display of diagnostic information. Diagnostic messages are output to stderr unless the [Q]diag\-file option is specified.
.NL
.PP
When \fIdiag\-list\fR value warn is used with static analysis
diagnostics, the following behavior occurs:
.NL
.IP \(bu 2
Option \-diag\-enable=warn (Linux OS) and /Qdiag\-enable:warn (Windows OS) enable all 
diagnostics except those that have an "error" severity level. They enable all static analysis
warnings, cautions, and remarks. 
.IP \(bu 2
Option \-diag\-disable=warn (Linux OS) and /Qdiag\-disable:warn (Windows OS) disable all  static analysis
diagnostics except those that have an "error" severity level. They suppress all static analysis
warnings, cautions, and remarks. 
.PP
.B NOTE:
The static analyzer, which performs static analysis, is deprecated.
.PP
To control the diagnostic information reported by the vectorizer, use the [Q]vec\-report option.
.NL
.PP
To control the diagnostic information reported by the auto\-parallelizer, use the [Q]par\-report option.
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
enable vec
.NL
Linux and OS X: \-vec\-report
.TP 18
disable vec
.NL
Linux and OS X: \-vec\-report0
.TP 18
enable par
.NL
Linux and OS X: \-par\-report
.TP 18
disable par
.NL
Linux and OS X: \-par\-report0
.RE
.TP
.B
\-diag\-dump
.RS
.TP
Tells the compiler to print all enabled diagnostic messages and stop compilation.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler issues certain diagnostic messages by default.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to print all enabled diagnostic messages and stop compilation. The diagnostic messages are output to stdout.
.NL
.PP
This option prints the enabled diagnostics from all possible diagnostics that the compiler can issue, including any default diagnostics.
.NL
.PP
If \fIdiag\-list\fR is specified for the [Q]diag\-enable option, the print out will include the \fIdiag\-list\fR diagnostics.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-enable=sc[n] (L*X only)
.TP
.B
\-diag\-enable=sc\-mode (L*X only)
.TP
.B
\-diag\-disable=sc (L*X only)
.RS
.TP
Enables static analysis diagnostics. You can determine which diagnostics to emit based on severity or you can specify an analysis mode for diagnostic messages. This is a deprecated option. There is no replacement option.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Specifies the level of severity to report. Possible values are:  
.RS
.TP 15
1
Reports only diagnostics with a severity level of "critical". Diagnostics with a severity level of "error" or "warning" are not displayed.
.TP 15
2
Reports all diagnostics with a severity level of "critical" and "error". Diagnostics with a severity level of "warning" are not reported. This is the default.
.TP 15
3
Reports all diagnostics regardless of the severity level.
.RE
.TP 18
\fImode\fR
.NL
Specifies the analysis mode. Possible values are:
.RS
.TP 15
full
This mode attempts to find all program weaknesses, even at the expense of more false positives. This mode is recommended when using the tool for security assurance. 
.IP
This is the default if \-diag\-enable=sc{[1|2|3]} (Linux* OS and OS X*) or
/Qdiag\-enable:sc{[1|2|3]} (Windows* OS) is present. Otherwise, the default is
None (static analysis diagnostics are
disabled).
.TP 15
concise
This mode attempts to reduce false positives
somewhat more than reducing false negatives. This mode is recommended when using the tool for general error
detection.
.TP 15
precise
This mode attempts to avoid all false positives, even at the expense of substantially reduced error checking. This mode is recommended when using the tool for acceptance screening.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-diag\-disable=sc and /Qdiag\-disable:sc
.NL
Static analysis diagnostics are disabled.
.TP
\fBDescription:\fR 
.PP
This option enables static analysis diagnostics. 
.NL
.PP
If you specify \fIn\fR for the option, you can determine which diagnostics to emit based on severity.  If you specify \fImode\fR, you can also specify an analysis mode for diagnostic messages. 
.NL
.PP
To disable static analysis, specify /Qdiag\-disable:sc (Windows* OS) or option \-diag\-disable=sc (Linux* OS). 
.NL
.PP
You can also specify the following options that affect the diagnostics:
.NL
.IP \(bu 2
Option [Q]diag\-error setting sc
This changes all Static Analysis diagnostics to errors.
.IP \(bu 2
Option [Q]diag\-warning setting sc
This changes all Static Analysis diagnostics to warnings.
.IP \(bu 2
Option [Q]diag\-remark setting sc
This changes all Static Analysis diagnostics to remarks (comments).
.PP
This static analysis feature requires installation of another product. For more information, see Feature Requirements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-enable=sc\-enums (L*X only)
.RS
.TP
Tells static analysis to treat enumeration variables as known values equal to any one of the associated enumeration literals. This is a deprecated option. There is no replacement option.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
If static analysis is enabled, it treats unknown enumeration variables as unknown integer values.
.TP
\fBDescription:\fR 
.PP
This option tells static analysis to treat enumeration variables as known values equal to any one of the associated enumeration literals.  By default, static analysis treats unknown enumeration variables as unknown integer values.  Setting this option may find additional errors but tends to create more false positives.
.NL
.PP
This option is ignored unless you enable static analysis diagnostics by specifying option [Q]diag\-enable setting sc[n] or setting sc\-mode.
.NL
.PP
This static analysis feature requires installation of another product. For more information, see Feature Requirements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-enable=sc\-include (L*X only)
.RS
.TP
Tells a source code analyzer to process include files and source files when issuing diagnostic messages.  This is a deprecated option. There is no replacement option.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler issues certain diagnostic messages by default. If static analysis is enabled, include files are not analyzed by default.
.TP
\fBDescription:\fR 
.PP
This option tells the static security analyzer to process include files and source files when issuing diagnostic messages. Normally, when static analysis diagnostics are enabled, only source files are analyzed. 
.NL
.PP
This option is ignored unless you enable static analysis diagnostics by specifying option [Q]diag\-enable setting sc[n] or setting sc\-mode.
.NL
.PP
This static analysis feature requires installation of another product. For more information, see Feature Requirements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-enable=sc\-single\-file (L*X only)
.RS
.TP
Tells static analysis to process each file individually. This is a deprecated option. There is no replacement option.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
If static analysis is
enabled, it analyzes the whole program.
.TP
\fBDescription:\fR 
.PP
This option tells static analysis to process each file individually.  Skipping the usual whole\-program analysis reduces memory requirements and analysis time on large programs but often finds fewer real errors. 
.NL
.PP
This option is ignored unless you enable static analysis diagnostics by specifying option [Q]diag\-enable setting sc[n] or setting sc\-mode.
.NL
.PP
This static analysis feature requires installation of another product. For more information, see Feature Requirements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-error\-limitn
.TP
.B
\-no\-diag\-error\-limit
.RS
.TP
Specifies the maximum number of errors allowed before compilation stops.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the maximum number of error\-level or fatal\-level compiler errors allowed.
.TP
\fBDefault:\fR 
.TP 18
30
.NL
A maximum of 30 error\-level and fatal\-level messages are allowed.
.TP
\fBDescription:\fR 
.PP
This option specifies the maximum number of errors allowed before compilation stops. It indicates the maximum number of error\-level or fatal\-level compiler errors allowed for a file specified on the command line. 
.NL
.PP
If you specify the negative form of the [Q]diag\-error\-limit option on the command line, there is no limit on the number of errors that are allowed.
.NL
.PP
If the maximum number of errors is reached, a warning message is issued and the next file (if any) on the command line is compiled.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-error\-limit and \-noerror\-limit
.NL
.RE
.TP
.B
\-diag\-file[=filename] (L*X only)
.RS
.TP
Causes the results of diagnostic analysis to be output to a file.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file for output.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Diagnostic messages are output to stderr.
.TP
\fBDescription:\fR 
.PP
This option causes the results of diagnostic analysis to be output to a file. The file is placed in the current working directory.
.NL
.PP
You can include a file extension in \fIfilename\fR. For example, if \fIfile.txt\fR is specified, the name of the output file is 
\fIfile.txt\fR. If you do not provide a file extension, the name of the file is \fIfilename.diag\fR. 
.NL
.PP
If \fIfilename\fR is not specified, the name of the file is \fIname\-of\-the\-first\-source\-file.diag\fR. This is also the name of the file if the name specified for file conflicts with a source file name provided in the command line.
.NL
.PP
.B NOTE:
If you specify the [Q]diag\-file option and you also specify the [Q]diag\-file\-append option, the last option specified on the command line takes precedence.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-file\-append[=filename] (L*X only)
.RS
.TP
Causes the results of diagnostic analysis to be appended to a file.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file to be appended to. It can include a path.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Diagnostic messages are output to stderr.
.TP
\fBDescription:\fR 
.PP
This option causes the results of diagnostic analysis to be appended to a file. If you do not specify a path, the driver will look for \fIfilename\fR in the current working directory. 
.NL
.PP
If \fIfilename\fR is not found, then a new file with that name is created in the current working directory. If the name specified for file conflicts with a source file name provided in the command line, the name of the file is \fIname\-of\-the\-first\-source\-file.diag\fR.
.NL
.PP
.B NOTE:
If you specify the [Q]diag\-file\-append option and you also specify the [Q]diag\-file option, the last option specified on the command line takes precedence.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-id\-numbers
.TP
.B
\-no\-diag\-id\-numbers
.RS
.TP
Determines whether the compiler displays diagnostic messages by using their ID number values.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-diag\-id\-numbers 
.NL
The compiler displays diagnostic messages by using their ID number values.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler displays diagnostic messages by using their ID number values. If you specify the negative form of the [Q]diag\-id\-numbers option, mnemonic names are output for driver diagnostics only.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-onceid[,id,...]
.RS
.TP
Tells the compiler to issue one or more diagnostic messages only once.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIid\fR
.NL
Is the ID number of the diagnostic message. If you specify more than one message number, they must be separated by commas. There can be no intervening white space between each \fIid\fR. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler issues certain diagnostic messages by default.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to issue one or more diagnostic messages only once.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-sc\-dir[=dir] (L*X only)
.RS
.TP
Specifies a directory for static analysis results. This is a deprecated option. There is no replacement option.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the name of the directory where the results should be placed.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
If static analysis is enabled, analysis results are placed in the current working directory. For more details, see below.
.TP
\fBDescription:\fR 
.PP
This option specifies a directory for static analysis results. 
.NL
.PP
If you do not specify \fIdir\fR, the results are placed in the current working directory.  Results are placed in a subdirectory with the name r\fInnn\fRsc, where \fInnn\fR is replaced by the next available sequence number (001, 002, etc.).
.NL
.PP
This option is ignored unless you enable static analysis diagnostics by specifying option [Q]diag\-enable setting sc[n] or setting sc\-mode.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-d\-lines
.TP
.B
\-nod\-lines
.RS
.TP
Compiles debug statements.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
nod\-lines
.NL
Debug lines are treated as comment lines.
.TP
\fBDescription:\fR 
.PP
This option compiles debug statements. It specifies that lines in fixed\-format files that contain a D in column 1 (debug statements) should be treated as source code.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-DD
.NL
.RE
.TP
.B
\-double\-size size
.RS
.TP
Specifies the default KIND for DOUBLE PRECISION and DOUBLE COMPLEX declarations, constants, functions, and intrinsics.
.NL
.TP
\fBArguments:\fR 
.TP 18
size
.NL
Specifies the default KIND for DOUBLE PRECISION and DOUBLE COMPLEX declarations, constants, functions, and intrinsics. Possible values are: 64 (KIND=8) or 128 (KIND=16).
.TP
\fBDefault:\fR 
.TP 18
64
.NL
DOUBLE PRECISION variables are defined as REAL*8 and DOUBLE COMPLEX variables are defined as COMPLEX*16.
.TP
\fBDescription:\fR 
.PP
This option defines the default KIND for DOUBLE PRECISION and DOUBLE COMPLEX declarations, constants, functions, and intrinsics.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
double\-size 64
.NL
Defines DOUBLE PRECISION declarations, constants, functions, and intrinsics as REAL(KIND=8) (REAL*8) and defines DOUBLE COMPLEX declarations, functions, and intrinsics as COMPLEX(KIND=8) (COMPLEX*16).
.NL
.TP 18
double\-size 128
.NL
Defines DOUBLE PRECISION declarations, constants, functions, and intrinsics as REAL(KIND=16) (REAL*16) and defines DOUBLE COMPLEX declarations, functions, and intrinsics as COMPLEX(KIND=16) (COMPLEX*32).
.NL
.PP
The real\-size option overrides the double\-size option; for example, on Linux* systems, "\-double\-size 64 \-real\-size 128" acts like
"\-double\-size 128 \-real\-size 128".
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dryrun
.RS
.TP
Specifies that driver tool commands should be shown but not executed.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No tool commands are shown, but they are executed.
.TP
\fBDescription:\fR 
.PP
This option specifies that driver tool commands should be shown but not executed. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dumpmachine
.RS
.TP
Displays the target machine and operating system configuration.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not display target machine or operating system information.
.TP
\fBDescription:\fR 
.PP
This option displays the target machine and operating system configuration. No compilation is performed.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dynamic\-linker file (L*X only)
.RS
.TP
Specifies a dynamic linker other than the default. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfile\fR
.NL
Is the name of the dynamic linker to be used.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The default dynamic linker is used.
.TP
\fBDescription:\fR 
.PP
This option lets you specify a dynamic linker other than the default.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dynamiclib (M*X only)
.RS
.TP
Invokes the libtool command to generate dynamic libraries.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler produces an executable.
.TP
\fBDescription:\fR 
.PP
This option invokes the libtool command to generate dynamic libraries. 
.NL
.PP
When passed this option, the compiler uses the libtool command to produce a dynamic library instead of an executable when linking. 
.NL
.PP
To build static libraries, you should specify option \-staticlib or libtool \-static <objects>.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dyncom "common1,common2,..."
.RS
.TP
Enables dynamic allocation of common blocks at run time.
.NL
.TP
\fBArguments:\fR 
.TP 18
common1,common2,...
.NL
Are the names of the common blocks to be dynamically allocated. The list of names must be within quotes.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Common blocks are not dynamically allocated at run time.
.TP
\fBDescription:\fR 
.PP
This option enables dynamic allocation of the specified common blocks at run time. For example, to enable dynamic allocation of common blocks a, b, and c at run time, use this syntax:
.NL
.PP
/Qdyncom "a,b,c"    ! on Windows systems
.PP
.PP
\-dyncom "a,b,c"     ! on Linux and OS X systems
.PP
.PP
The following are some limitations that you should be aware of when using this option:
.NL
.IP \(bu 2
An entity in a dynamic common cannot be initialized in a DATA statement.
.IP \(bu 2
Only named common blocks can be designated as dynamic COMMON.
.IP \(bu 2
An entity in a dynamic common block must not be used in an EQUIVALENCE expression with an entity in a static common block or a DATA\-initialized variable.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-E
.RS
.TP
Causes the preprocessor to send output to stdout.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Preprocessed source files are output to the compiler.
.TP
\fBDescription:\fR 
.PP
This option causes the preprocessor to send output to stdout. Compilation stops when the files have been preprocessed.
.NL
.PP
When you specify this option, the compiler\[aq]s preprocessor expands your source module and writes the result to stdout. The preprocessed source contains #line directives, which the compiler uses to determine the source file and line number.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-EP
.RS
.TP
Causes the preprocessor to send output to stdout, omitting #line directives.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Preprocessed source files are output to the compiler.
.TP
\fBDescription:\fR 
.PP
This option causes the preprocessor to send output to stdout, omitting #line directives. 
.NL
.PP
If you also specify option preprocess\-only, option P, or option F, the preprocessor will write the results (without #line directives) to a file instead of stdout.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-extend\-source [size]
.TP
.B
\-noextend\-source
.RS
.TP
Specifies the length of the statement field in a fixed\-form source file.
.NL
.TP
\fBArguments:\fR 
.TP 18
size
.NL
Is the length of the statement field in a fixed\-form source file. Possible values are: 72, 80, or 132.
.TP
\fBDefault:\fR 
.TP 18
72
.NL
If you do not specify this option or you specify noextend\-source, the statement field ends at column 72.
.TP 18
132
.NL
If you specify extend_source without \fIsize\fR, the statement field ends at column 132.\-
.TP
\fBDescription:\fR 
.PP
This option specifies the size (column number) of the statement field of a source line in a fixed\-form source file. This option is valid only for fixed\-form files; it is ignored for free\-form files.
.NL
.PP
When size is specified, it is the last column parsed as part of the statement field. Any columns after that are treated as comments.
.NL
.PP
If you do not specify \fIsize\fR, it is the same as specifying extend_source 132.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
extend\-source 72
.NL
Specifies that the statement field ends at column 72.
.NL
.TP 18
extend\-source 80
.NL
Specifies that the statement field ends at column 80.
.NL
.TP 18
extend\-source 132
.NL
Specifies that the statement field ends at column 132.
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
extend\-source 72 
.NL
Linux and OS X: \-72
.TP 18
extend\-source 80
.NL
Linux and OS X: \-80
.TP 18
extend\-source 132
.NL
Linux and OS X: \-132
.RE
.TP
.B
\-Fdir (M*X only)
.RS
.TP
Adds a framework directory to the head of an include file search path.
.NL
.TP
\fBArchitecture Restrictions:\fR  Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the name for the framework directory.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not add a framework directory to the head of an include file search path.
.TP
\fBDescription:\fR 
.PP
This option adds a framework directory to the head of an include file search path.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-f66
.RS
.TP
Tells the compiler to apply FORTRAN 66 semantics.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler applies Fortran 95 semantics.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to apply FORTRAN 66 semantics when interpreting language features. This causes the following to occur:
.NL
.IP \(bu 2
DO loops are always executed at least once
.IP \(bu 2
FORTRAN 66 EXTERNAL statement syntax and semantics are allowed
.IP \(bu 2
If the OPEN statement STATUS specifier is omitted, the default changes to STATUS=\[aq]NEW\[aq] instead of STATUS=\[aq]UNKNOWN\[aq]
.IP \(bu 2
If the OPEN statement BLANK specifier is omitted, the default changes to BLANK=\[aq]ZERO\[aq] instead of BLANK=\[aq]NULL\[aq]
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-f77rtl
.TP
.B
\-nof77rtl
.RS
.TP
Tells the compiler to use the run\-time behavior of FORTRAN 77.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
nof77rtl
.NL
The compiler uses the run\-time behavior of Intel(R) Fortran.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to use the run\-time behavior of FORTRAN 77.
.NL
.PP
Specifying this option controls the following run\-time behavior:
.NL
.IP \(bu 2
When the unit is not connected to a file, some INQUIRE specifiers will return different values:
.RS
.IP \(bu 2
NUMBER= returns 0
.IP \(bu 2
ACCESS= returns \[aq]UNKNOWN\[aq]
.IP \(bu 2
BLANK= returns \[aq]UNKNOWN\[aq]
.IP \(bu 2
FORM= returns \[aq]UNKNOWN\[aq]
.RE
.IP \(bu 2
PAD= defaults to \[aq]NO\[aq] for formatted input.
.IP \(bu 2
NAMELIST and list\-directed input of character strings must be delimited by apostrophes or quotes.
.IP \(bu 2
When processing NAMELIST input:
.RS
.IP \(bu 2
Column 1 of each record is skipped.
.IP \(bu 2
The \[aq]$\[aq] or \[aq]&\[aq] that appears prior to the group\-name must appear in column 2 of the input record.
.RE
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Fa[filename|dir]
.RS
.TP
Specifies that an assembly listing file should be generated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the assembly listing file.
.TP 18
\fIdir\fR
.NL
Is the directory where the file should be placed. It can include \fIfilename\fR.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No assembly listing file is produced.
.TP
\fBDescription:\fR 
.PP
This option specifies that an assembly listing file should be generated (optionally named \fIfilename\fR).
.NL
.PP
If \fIfilename\fR is not specified, the file name will be the name of the source file with an extension of .asm; the file is placed in the current directory.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-S
.NL
.PP
Windows: /S, /asmfile  (this is a deprecated option)
.NL
.RE
.TP
.B
\-falias
.TP
.B
\-fno\-alias
.RS
.TP
Determines whether aliasing should be assumed in the program.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-alias
.NL
No aliasing is assumed in the program.
.TP
\fBDescription:\fR 
.PP
This option determines whether aliasing should be assumed in the program.
.NL
.PP
If you want aliasing to be assumed in the program, specify \-falias. However, this may affect performance.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-falign\-functions[=n]
.TP
.B
\-fno\-align\-functions
.RS
.TP
Tells the compiler to align functions on an optimal byte boundary. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the byte boundary for function alignment. Possible values are 2 or 16.
.TP
\fBDefault:\fR 
.TP 18
\-fno\-align\-functions
.NL
The compiler aligns functions on 2\-byte boundaries. This is the same as specifying \-falign\-functions=2 (Linux* OS and OS X*).
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to align functions on an optimal byte boundary. If you do not specify \fIn\fR, the compiler aligns the start of functions on 16\-byte boundaries.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-falign\-stack=mode (L*X only)
.RS
.TP
Tells the compiler the stack alignment to use on entry to routines. 
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on IA\-32 architecture
.TP
\fBArguments:\fR 
.TP 18
\fImode\fR
.NL
Is the method to use for stack alignment.  Possible values are:
.RS
.TP 15
assume\-4\-byte
Tells the compiler to assume the stack is aligned on 4\-byte boundaries. The compiler can dynamically adjust the stack to 16\-byte alignment if needed. 
.TP 15
maintain\-16\-byte
Tells the compiler to not assume any specific stack alignment, but attempt to maintain alignment in case the stack is already aligned. The compiler can dynamically align the stack if needed. This setting is compatible with gcc. 
.TP 15
assume\-16\-byte
Tells the compiler to assume the stack is aligned on 16\-byte boundaries and to continue to maintain 16\-byte alignment. This setting is compatible with gcc. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-falign\-stack=assume\-16\-byte
.NL
The compiler assumes the stack is aligned on 16\-byte boundaries and continues to maintain 16\-byte alignment.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler the stack alignment to use on entry to routines.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fast
.RS
.TP
Maximizes speed across the entire program.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The optimizations that maximize speed are not enabled.
.TP
\fBDescription:\fR 
.PP
This option maximizes speed across the entire program.
.NL
.PP
It sets the following options:
.NL
.PP
On OS X* systems: \-ipo, \-mdynamic\-no\-pic, \-O3, \-no\-prec\-div, \-fp\-model fast=2, and \-xHost On Windows* systems: /O3, /Qipo, /Qprec\-div\-, /fp:fast=2, and /QxHost On Linux* systems: \-ipo, \-O3, \-no\-prec\-div, \-static, \-fp\-model fast=2, and \-xHost On Intel(R) 64 architecture\-based systems that target Intel(R) MIC Architecture: [Q]ipo, O3, \-no\-prec\-div (Linux* OS)  or /Qprec\-div\-
(Windows* OS), \-fp\-model fast=2 (Linux* OS) or /fp:fast=2 (Windows* OS) 
.NL
.PP
When option fast is specified, you can override the [Q]xHost option setting by specifying a different processor\-specific [Q]x option on the command line. However, the last option specified on the command line takes precedence.  
.NL
.PP
For example:
.NL
.IP \(bu 2
On Linux* OS,  if you specify option \-fast \-xSSE3, option \-xSSE3 takes effect. However, if you specify \-xSSE3 \-fast, option \-xHost takes effect.
.IP \(bu 2
On Windows* OS,  if you specify option /fast /QxSSE3, option/QxSSE3 takes effect. However, if you specify /QxSSE3 /fast, option /QxHost takes effect.
.PP
For implications on non\-Intel processors, refer to the [Q]xHost documentation.
.NL
.PP
.B NOTE:
Option fast sets some aggressive optimizations that may not be appropriate for all applications. The resulting executable may not run on processor types different from the one on which you compile. You should make sure that you understand the individual optimization options that are enabled by option fast.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fast\-transcendentals
.TP
.B
\-no\-fast\-transcendentals
.RS
.TP
Enables the compiler to replace calls to transcendental functions with faster but less precise implementations.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
depends on the setting of \-fp\-model (Linux* OS and OS X*)
.NL
If you do not specify option \-[no\-]fast\-transcendentals:
.RS
.IP \(bu 2
The default is ON if option \-fp\-model fast is specified or is in effect.
.IP \(bu 2
The default is OFF if a value\-safe setting is specified for \-fp\-model (such as "precise", "source", etc.).
.RE
.TP
\fBDescription:\fR 
.PP
This option enables the compiler to replace calls to transcendental functions with implementations that may be faster but less precise. 
.NL
.PP
It allows the compiler to perform certain optimizations on transcendental functions, such as replacing individual calls to sine in a loop with a single call to a less precise vectorized sine library routine. 
.NL
.PP
This option does not affect explicit Short Vector Math Library (SVML) intrinsics.  It only affects scalar calls to the standard math library routines.
.NL
.PP
You cannot use option –fast\-transcendentals with option –fp\-model strict. 
.NL
.PP
This option determines the setting for the
maximum allowable relative error for math library function results
(max\-error) if none of the following options are
specified:
.NL
.IP \(bu 2
\-fimf\-accuracy\-bits (Linux* OS and OS X*) or
/Qimf\-accuracy\-bits (Windows* OS)
.IP \(bu 2
\-fimf\-max\-error (Linux OS and OS X) or
/Qimf\-max\-error (Windows OS)
.IP \(bu 2
\-fimf\-precision (Linux OS and OS X) or
/Qimf\-precision (Windows OS)
.PP
This option enables extra optimization that only applies to Intel(R) processors.
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fasynchronous\-unwind\-tables
.TP
.B
\-fno\-asynchronous\-unwind\-tables
.RS
.TP
Determines whether unwind information is precise at an instruction boundary or at a call boundary. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
Intel(R) 64 architecture: \-fasynchronous\-unwind\-tables
.NL
The unwind table generated is precise at  an instruction boundary, enabling accurate unwinding at any instruction.
.TP 18
IA\-32 architecture: \-fno\-asynchronous\-unwind\-tables
.NL
The unwind table generated is precise at call boundaries only.
.TP
\fBDescription:\fR 
.PP
This option determines whether unwind information is precise at an instruction boundary or at a call boundary. The compiler generates an unwind table in DWARF2 or DWARF3 format, depending on which format is supported on your system.
.NL
.PP
If \-fno\-asynchronous\-unwind\-tables is specified, the unwind table is precise at call boundaries only. In this case, the compiler will avoid creating unwind tables for routines such as the following:
.NL
.IP \(bu 2
A C++ routine that does not declare objects with destructors and does not contain calls to routines that might throw an exception.
.IP \(bu 2
A C/C++ or Fortran routine compiled without \-fexceptions, and on Intel(R) 64 architecture, without \-traceback.
.IP \(bu 2
A C/C++ or Fortran routine compiled with \-fexceptions that does not contain calls to routines that might throw an exception.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fcode\-asm
.RS
.TP
Produces an assembly listing with machine code annotations.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No machine code annotations appear in the assembly listing file, if one is produced.
.TP
\fBDescription:\fR 
.PP
This option produces an assembly listing file with machine code annotations.
.NL
.PP
The assembly listing file shows the hex machine instructions at the beginning of each line of assembly code. The file cannot be assembled; the file name is the name of the source file with an extension of .cod.
.NL
.PP
To use this option, you must also specify option \-S, which causes an assembly listing to be generated.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-fcommon
.TP
.B
\-fno\-common
.RS
.TP
Determines whether the compiler treats common symbols as global definitions. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fcommon
.NL
The compiler does not treat common symbols as global definitions.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler treats common symbols as global definitions and to allocate memory for each symbol at compile time.
.NL
.PP
Option \-fno\-common tells the compiler to treat common symbols as global definitions. When using this option, you can only have a common variable declared in one module; otherwise, a link time error will occur for multiple defined symbols.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-feliminate\-unused\-debug\-types
.TP
.B
\-fno\-eliminate\-unused\-debug\-types
.RS
.TP
Controls the debug information emitted for types declared in a compilation unit.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-feliminate\-unused\-debug\-types 
.NL
The compiler emits debug information only for types that are actually used by a variable/parameter/etc..
.TP
\fBDescription:\fR 
.PP
This option controls the debug information emitted for types declared in a compilation unit.
.NL
.PP
If you specify \-fno\-eliminate\-unused\-debug\-types (Linux and OS X) or /Qeliminate\-unused\-debug\-types\-, it will cause the compiler to emit debug information for all types present in the sources. This option may cause a large increase in the size of the debug information.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fexceptions
.TP
.B
\-fno\-exceptions
.RS
.TP
Enables exception handling table generation. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-exceptions
.NL
Exception handling table generation is disabled.
.TP
\fBDescription:\fR 
.PP
This option enables C++ exception handling table generation, preventing Fortran routines in mixed\-language applications from interfering with exception handling between C++ routines. The \-fno\-exceptions option disables C++ exception handling table generation, resulting in smaller code. When this option is used, any use of C++ exception handling constructs (such as try blocks and throw statements) when a Fortran routine is in the call chain will produce an error. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ffat\-lto\-objects (L*X only)
.TP
.B
\-fno\-fat\-lto\-objects (L*X only)
.RS
.TP
Determines whether a fat link\-time optimization (LTO) object, containing both intermediate language and object code, is generated during an interprocedural optimization compilation (\-c –ipo).
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-ffat\-lto\-objects
.NL
When –c –ipo is specified, the compiler generates a fat link\-time optimization (LTO) object that has both a true object and a discardable intermediate language section.
.TP
\fBDescription:\fR 
.PP
This option determines whether a fat link time optimization (LTO) object, containing both intermediate language and object code, is generated during an interprocedural optimization compilation (\-c –ipo).
.NL
.PP
During an interprocedural optimization compilation (\-c –ipo), the following occurs:
.NL
.IP \(bu 2
If you specify \-ffat\-lto\-objects, the compiler generates a fat link\-time optimization (LTO) object that has both a true object and a discardable intermediate language section.  This enables both link\-time optimization (LTO) linking and normal linking.
.IP \(bu 2
If you specify \-fno\-fat\-lto\-objects, the compiler generates a fat link\-time optimization (LTO) object that only has a discardable intermediate language section; no true object is generated. This option may improve compilation time.
.PP
Note that these files will be inserted into archives in the form in which they were created.
.NL
.PP
This option is provided for compatibility with gcc. For more information about this option, see the gcc documentation.
.NL
.PP
.B NOTE:
Intel\[aq]s intermediate language representation is not compatible with gcc’s intermediate language representation.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ffnalias
.TP
.B
\-fno\-fnalias
.RS
.TP
Specifies that aliasing should be assumed within functions.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-ffnalias
.NL
Aliasing is assumed within functions.
.TP
\fBDescription:\fR 
.PP
This option specifies that aliasing should be assumed within functions.
.NL
.PP
The \-fno\-fnalias option specifies that aliasing should not be assumed within functions, but should be assumed across calls.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-fimf\-absolute\-error=value[:funclist]
.RS
.TP
Defines the maximum allowable absolute error for math library function results.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIvalue\fR
.NL
Is a positive, floating\-point number. Errors in math library function results may exceed the maximum relative error (max\-error) setting if the absolute\-error is less than or equal to \fIvalue\fR.
.IP
The format for the number is [digits] [.digits] [ { e | E
}[sign]digits]
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library functions to which the attribute should be applied. If you specify more than one function, they must be separated with commas.  Precision\-specific variants like sin and sinf are considered different functions, so you would need to use \-fimf\-absolute\-error=0.00001:sin,sinf (or /Qimf\-absolute\-error:0.00001:sin,sinf) to specify the maximum allowable absolute error for both the single\-precision and double\-precision sine functions. 
.IP
You also can specify the symbol /f to denote single\-precision divides, symbol / to denote double\-precision divides, symbol /l to denote extended\-precision divides, and symbol /q to denote quad\-precision divides. For example you can specify  \-fimf\-absolute\-error=0.00001:/ or /Qimf\-absolute\-error: 0.00001:/.
.TP
\fBDefault:\fR 
.TP 18
Zero ("0")
.NL
An absolute\-error setting of 0 means that the function is bound by the relative error setting. This is the default behavior.
.TP
\fBDescription:\fR 
.PP
This option defines the maximum allowable absolute error for math library function results.
.NL
.PP
This option can improve run\-time performance, but it may decrease the accuracy of results.
.NL
.PP
This option only affects functions that have
zero as a possible return value, such as log, sin, asin,
etc.
.NL
.PP
The relative error requirements for a
particular function are determined by options that set the maximum relative error (max\-error)
and precision. The return value from a function must have a
relative error less than the max\-error value, or an absolute error
less than the absolute\-error value.
.NL
.PP
If you need to define the accuracy for a math function of a certain
precision, specify the function name of the precision that you
need. For example, if you want double precision, you can specify
:sin; if you want single precision, you can specify :sinf, as
in \-fimf\-absolute\-error=0.00001:sin or
/Qimf\-absolute\-error:0.00001:sin, or \-fimf\-absolute\-error=0.00001:sqrtf or
/Qimf\-absolute\-error:0.00001:sqrtf.
.NL
.PP
If you do not specify any function names, then
the setting applies to all functions (and to all precisions).
However, as soon as you specify an individual function name, the
setting applies only to the function of corresponding
precision. So, for example, sinf applies only to the single\-precision sine
function, sin applies only to the
double\-precision sine
function, sinl applies only to the
extended\-precision sine
function, etc.
.NL
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML (Short Vector Math Library) are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fimf\-accuracy\-bits=bits[:funclist]
.RS
.TP
Defines the relative error for math library function results,  including division and square root.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIbits\fR
.NL
Is a positive, floating\-point number indicating the number of correct bits the compiler should use.
.IP
The format for the number is [digits] [.digits] [ { e | E }[sign]digits].
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library functions to which the attribute should be applied. If you specify more than one function, they must be separated with commas.  Precision\-specific variants like sin and sinf are considered different functions, so you would need to use \-fimf\-accuracy\-bits=23:sin,sinf (or /Qimf\-accuracy\-bits:23:sin,sinf) to specify the relative error for both the single\-precision and double\-precision sine functions. 
.IP
You also can specify the symbol /f to denote single\-precision divides, symbol / to denote double\-precision divides, symbol /l to denote extended\-precision divides, and symbol /q to denote quad\-precision divides. For example you can specify  \-fimf\-accuracy\-bits=10.0:/f or /Qimf\-accuracy\-bits:10.0:/f.
.TP
\fBDefault:\fR 
.TP 18
\-fimf\-precision=medium or /Qimf\-precision:medium
.NL
The compiler uses medium precision when calling math library functions. Note that other options can affect precision; see below for details.
.TP
\fBDescription:\fR 
.PP
This option defines the relative error, measured by the number of correct bits, for math library function results.
.NL
.PP
The following formula
is used to convert bits into ulps: ulps = 2p\-1\-bits, where
p is the number of the target format mantissa bits (24, 53, and 113
for single, double, and quad precision, respectively).
.NL
.PP
This option can affect run\-time performance and the accuracy of results.
.NL
.PP
If you need to define the accuracy for a math function of a certain precision, specify the function name of the precision that you need. For example, if you want double precision, you can specify :sin; if you want single precision, you can specify :sinf, as in the following: 
.NL
.IP \(bu 2
\-fimf\-accuracy\-bits=23:sinf,cosf,logf or /Qimf\-accuracy\-bits:23:sinf,cosf,logf
.IP \(bu 2
\-fimf\-accuracy\-bits=52:sqrt,/,trunc or /Qimf\-accuracy\-bits:52:sqrt,/,trunc
.IP \(bu 2
\-fimf\-accuracy\-bits=10:powf or /Qimf\-accuracy\-bits:10:powf
.PP
If you do not specify any function names, then the setting applies to all functions (and to all precisions). However, as soon as you specify an individual function name, the setting applies only to the function of corresponding precision. So, for example, sinf applies only to the single\-precision sine function, sin applies only to the double\-precision sine function, sinl applies only to the extended\-precision sine function, etc.  
.NL
.PP
There are three options you can use to express the maximum relative error.  They are as follows:
.NL
.IP \(bu 2
\-fimf\-precision (Linux* OS and OS X*) or /Qimf\-precision (Windows* OS)
.IP \(bu 2
\-fimf\-max\-error (Linux* OS and OS X*) or /Qimf\-max\-error (Windows* OS)
.IP \(bu 2
\-fimf\-accuracy\-bits (Linux OS and OS X*) or /Qimf\-accuracy\-bits (Windows OS)
.PP
If more than one of these options are specified, the default value for the maximum relative error is determined by the last one specified on the command line.
.NL
.PP
If none of the above options are specified, the default values for the maximum relative error are determined by the setting of the following options:
.NL
.IP \(bu 2
[Q]fast\-transcendentals
.IP \(bu 2
[Q]prec\-div
.IP \(bu 2
[Q]prec\-sqrt
.IP \(bu 2
\-fp\-model (Linux OS and OS X) or /fp (Windows OS)
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML (Short Vector Math Library) are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fimf\-arch\-consistency=value[:funclist]
.RS
.TP
Ensures that the math library functions produce consistent results across different microarchitectural implementations of the same architecture.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIvalue\fR
.NL
Is one of the logical values "true" or "false".
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library functions to which the attribute should be applied. If you specify more than one function, they must be separated with commas.  Precision\-specific variants like sin and sinf are considered different functions, so you would need to use \-fimf\-arch\-consistency=true:sin,sinf (or /Qimf\-arch\-consistency:true:sin,sinf) to specify consistent results for both the single\-precision and double\-precision sine functions. 
.IP
You also can specify the symbol /f to denote single\-precision divides, symbol / to denote double\-precision divides, symbol /l to denote extended\-precision divides, and symbol /q to denote quad\-precision divides. For example you can specify  \-fimf\-arch\-consistency=true:/ or /Qimf\-arch\-consistency:true:/.
.TP
\fBDefault:\fR 
.TP 18
false
.NL
Implementations of some math library functions may produce slightly different results on implementations of the same architecture.
.TP
\fBDescription:\fR 
.PP
This option ensures that the math library functions produce consistent results across different microarchitectural implementations of the same architecture (for example, across different microarchitectural implementations of IA\-32 architecture). Consistency is only guaranteed for a single binary. Consistency is not guaranteed across different architectures. For example, consistency is not guaranteed across IA\-32 architecture and Intel(R) 64 architecture.
.NL
.PP
If you need to define the accuracy for a math function of a certain precision, specify the function name of the precision that you need. For example, if you want double precision, you can specify :sin; if you want single precision, you can specify :sinf, as in \-fimf\-arch\-consistency=true:sin  or /Qimf\-arch\-consistency:true:sin, or \-fimf\-arch\-consistency=false:sqrtf or /Qimf\-arch\-consistency:false:sqrtf.
.NL
.PP
If you do not specify any function names, then the setting applies to all functions (and to all precisions). However, as soon as you specify an individual function name, the setting applies only to the function of corresponding precision. So, for example, sinf applies only to the single\-precision sine function, sin applies only to the double\-precision sine function, sinl applies only to the extended\-precision sine function, etc.  
.NL
.PP
The \-fimf\-arch\-consistency (Linux* OS and OS X*) and
/Qimf\-arch\-consistency (Windows* OS)
option may decrease run\-time performance, but the option will
provide bit\-wise consistent results on all Intel(R) processors and
compatible, non\-Intel processors,
regardless of micro\-architecture. This option may not provide bit\-wise
consistent results between different architectures, for example,
between IA\-32 and Intel(R) 64 architectures, or between Intel(R) 64 architecture and Intel(R) MIC Architecture.
.NL
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML (Short Vector Math Library) are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fimf\-domain\-exclusion=classlist[:funclist]
.RS
.TP
Indicates the input arguments domain on which math functions must provide correct results. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIclasslist\fR
.NL
Is one of the following: 
.RS
.IP \(bu 2
One or more of the following floating\-point value classes you can exclude from the function domain without affecting the correctness of your program. The supported class names are:
.RS
extremes
This class is for values which do not lie within the usual domain of arguments for a given function.
nans
This means "x=Nan".
infinities
This means "x=infinities".
denormals
This means "x=denormal".
zeros
This means "x=0".
.RE
Each \fIclasslist\fR element corresponds to a power of two. The exclusion attribute is the logical or of the associated powers of two (that is, a bitmask). 
The following shows the current mapping from \fIclasslist\fR mnemonics to numerical values:
.TP 18
extremes
.NL
1
.NL
.TP 18
nans
.NL
2
.NL
.TP 18
infinities
.NL
4
.NL
.TP 18
denormals
.NL
8
.NL
.TP 18
zeros
.NL
16
.NL
.TP 18
none
.NL
0
.NL
.TP 18
all
.NL
31
.NL
.TP 18
common
.NL
15
.NL
.TP 18
other combinations
.NL
bitwise OR of the used values
.NL
You must specify the integer value that corresponds to the class that you want to exclude. 
Note that on excluded values, unexpected results may occur.
.IP \(bu 2
One of the following short\-hand tokens:
.RS
none
This means that none of the supported classes are excluded from the domain. To indicate this token, specify 0, as in \-fimf\-domain\-exclusion=0 (or /Qimf\-domain\-exclusion:0).
all
This means that all of the supported classes are excluded from the domain. To indicate this token, specify 31, as in \-fimf\-domain\-exclusion=31 (or /Qimf\-domain\-exclusion:31).
common
This is the same as specifying extremes,nans,infinities,denormals. To indicate this token, specify 15 (1 + 2+ 4 + 8), as in \-fimf\-domain\-exclusion=15 (or /Qimf\-domain\-exclusion:15)
.RE
.RE
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library functions to which the attribute should be applied. If you specify more than one function, they must be separated with commas.  Precision\-specific variants like sin and sinf are considered different functions, so you would need to use \-fimf\-domain\-exclusion=4:sin,sinf (or /Qimf\-domain\-exclusion:4:sin,sinf) to specify infinities for both the single\-precision and double\-precision sine functions. 
.IP
You also can specify the symbol /f to denote single\-precision divides, symbol / to denote double\-precision divides, symbol /l to denote extended\-precision divides, and symbol /q to denote quad\-precision divides. For example, you can specify:
.IP
\-fimf\-domain\-exclusion=4 or /Qimf\-domain\-exclusion:4
.IP
\-fimf\-domain\-exclusion=5:/,powf or /Qimf\-domain\-exclusion:5:/,powf
.IP
\-fimf\-domain\-exclusion=23:log,logf,/,sin,cosf or /Qimf\-domain\-exclusion:23:log,logf,/,sin,cosf
.IP
If you don’t specify argument \fIfunclist\fR, the domain restrictions apply to all math library functions.
.TP
\fBDefault:\fR 
.TP 18
Zero ("0")
.NL
The compiler uses default heuristics when calling math library functions.
.TP
\fBDescription:\fR 
.PP
This option indicates the input arguments domain on which math functions must provide correct results. It specifies that your program will function correctly if the functions specified in \fIfunclist\fR do not produce standard conforming results on the number classes.
.NL
.PP
This option can affect run\-time performance and the accuracy of results.  As more classes are excluded, faster code sequences can be used.
.NL
.PP
If you need to define the accuracy for a math function of a certain precision, specify the function name of the precision that you need. For example, if you want double precision, you can specify :sin; if you want single precision, you can specify :sinf, as in \-fimf\-domain\-exclusion=denormals:sin  or /Qimf\-domain\-exclusion:denormals:sin, or \-fimf\-domain\-exclusion=extremes:sqrtf or /Qimf domain\-exclusion:extremes:sqrtf.
.NL
.PP
If you do not specify any function names, then the setting applies to all functions (and to all precisions). However, as soon as you specify an individual function name, the setting applies only to the function of corresponding precision. So, for example, sinf applies only to the single\-precision sine function, sin applies only to the double\-precision sine function, sinl applies only to the extended\-precision sine function, etc.  
.NL
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML (Short Vector Math Library) are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fimf\-max\-error=ulps[:funclist]
.RS
.TP
Defines the maximum allowable relative error for math library function results, including division and square root.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIulps\fR
.NL
Is a positive, floating\-point number indicating the maximum allowable relative error the compiler should use.  
.IP
The format for the number is [digits] [.digits] [ { e | E
}[sign]digits].
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library functions to which the attribute should be applied. If you specify more than one function, they must be separated with commas.  Precision\-specific variants like sin and sinf are considered different functions, so you would need to use \-fimf\-max\-error=4.0:sin,sinf (or /Qimf\-max\-error=4.0:sin,sinf) to specify the maximum allowable relative error for both the single\-precision and double\-precision sine functions. 
.IP
You also can specify the symbol /f to denote single\-precision divides, symbol / to denote double\-precision divides, symbol /l to denote extended\-precision divides, and symbol /q to denote quad\-precision divides. For example you can specify  \-fimf\-max\-error=4.0:/ or /Qimf\-max\-error:4.0:/.
.TP
\fBDefault:\fR 
.TP 18
\-fimf\-precision=medium or /Qimf\-precision:medium
.NL
The compiler uses medium precision when calling math library functions. Note that other options can affect precision; see below for details.
.TP
\fBDescription:\fR 
.PP
This option defines the maximum allowable relative error, measured in ulps, for math library function results. 
.NL
.PP
This option can affect run\-time performance and the accuracy of results.
.NL
.PP
If you need to define the accuracy for a math function of a certain precision, specify the function name of the precision that you need. For example, if you want double precision, you can specify :sin; if you want single precision, you can specify :sinf, as in \-fimf\-max\-error=4.0:sin  or /Qimf\-max\-error:4.0:sin, or \-fimf\-max\-error=4.0:sqrtf or /Qimf\-max\-error:4.0:sqrtf.
.NL
.PP
If you do not specify any function names, then the setting applies to all functions (and to all precisions). However, as soon as you specify an individual function name, the setting applies only to the function of corresponding precision. So, for example, sinf applies only to the single\-precision sine function, sin applies only to the double\-precision sine function, sinl applies only to the extended\-precision sine function, etc.  
.NL
.PP
There are three options you can use to express the maximum relative error.  They are as follows:
.NL
.IP \(bu 2
\-fimf\-precision (Linux* OS and OS X*) or /Qimf\-precision (Windows* OS)
.IP \(bu 2
\-fimf\-max\-error (Linux* OS and OS X*) or /Qimf\-max\-error (Windows* OS)
.IP \(bu 2
\-fimf\-accuracy\-bits (Linux OS and OS X*) or /Qimf\-accuracy\-bits (Windows OS)
.PP
If more than one of these options are specified, the default value for the maximum relative error is determined by the last one specified on the command line.
.NL
.PP
If none of the above options are specified, the default values for the maximum relative error are determined by the setting of the following options:
.NL
.IP \(bu 2
[Q]fast\-transcendentals
.IP \(bu 2
[Q]prec\-div
.IP \(bu 2
[Q]prec\-sqrt
.IP \(bu 2
\-fp\-model (Linux OS and OS X) or /fp (Windows OS)
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML (Short Vector Math Library) are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fimf\-precision[=value[:funclist]]
.RS
.TP
Lets you specify a level of accuracy (precision) that the compiler should use when determining which math library functions to use.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIvalue\fR
.NL
Is one of the following values denoting the desired accuracy: 
.RS
.TP 15
high
This is equivalent to max\-error = 0.6.
.TP 15
medium
This is equivalent to max\-error = 4; this is the default setting if the option is specified and \fIvalue\fR is omitted.
.TP 15
low
This is equivalent to accuracy\-bits = 11 for single\-precision functions; accuracy\-bits = 26 for double\-precision functions.
.RE
.IP
In the above explanations, max\-error
means option  \-fimf\-max\-error (Linux* OS and OS X*) or
/Qimf\-max\-error (Windows* OS);  accuracy\-bits means option \-fimf\-accuracy\-bits (Linux* OS and OS X*) or /Qimf\-accuracy\-bits (Windows* OS).
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library functions to which the attribute should be applied. If you specify more than one function, they must be separated with commas.  Precision\-specific variants like sin and sinf are considered different functions, so you would need to use \-fimf\-precision=high:sin,sinf (or /Qimf\-precision:high:sin,sinf) to specify high precision for both the single\-precision and double\-precision sine functions. 
.IP
You also can specify the symbol /f to denote single\-precision divides, symbol / to denote double\-precision divides, symbol /l to denote extended\-precision divides, and symbol /q to denote quad\-precision divides. For example you can specify \-fimf\-precision=low:/ or /Qimf\-precision:low:/ and \-fimf\-precision=low:/f or /Qimf\-precision:low:/f.
.TP
\fBDefault:\fR 
.TP 18
medium
.NL
The compiler uses medium precision when calling math library functions. Note that other options can affect precision; see below for details.
.TP
\fBDescription:\fR 
.PP
This option lets you specify a level of accuracy (precision) that the compiler should use when determining which math library functions to use. 
.NL
.PP
This option can be used to improve run\-time performance if reduced accuracy is sufficient for the application, or it can be used to increase the accuracy of math library functions selected by the compiler.
.NL
.PP
In general, using a lower precision can improve run\-time performance and using a higher precision may reduce run\-time performance.
.NL
.PP
If you need to define the accuracy for a math function of a certain precision, specify the function name of the precision that you need.  For example, if you want double precision, you can specify :sin; if you want single precision, you can specify :sinf, as  in \-fimf\-precision=low:sin  or /Qimf\-precision:low:sin, or \-fimf\-precision=high:sqrtf or /Qimf\-precision:high:sqrtf.
.NL
.PP
If you do not specify any function names, then the setting applies to all functions (and to all precisions). However, as soon as you specify an individual function name, the setting applies only to the function of corresponding precision. So, for example, sinf applies only to the single\-precision sine function, sin applies only to the double\-precision sine function, sinl applies only to the extended\-precision sine function, etc. 
.NL
.PP
There are three options you can use to express the maximum relative error.  They are as follows:
.NL
.IP \(bu 2
\-fimf\-precision (Linux* OS and OS X*) or /Qimf\-precision (Windows* OS)
.IP \(bu 2
\-fimf\-max\-error (Linux* OS and OS X*) or /Qimf\-max\-error (Windows* OS)
.IP \(bu 2
\-fimf\-accuracy\-bits (Linux OS and OS X*) or /Qimf\-accuracy\-bits (Windows OS)
.PP
If more than one of these options are specified, the default value for the maximum relative error is determined by the last one specified on the command line.
.NL
.PP
If none of the above options are specified, the default values for the maximum relative error are determined by the setting of the following options:
.NL
.IP \(bu 2
[Q]fast\-transcendentals
.IP \(bu 2
[Q]prec\-div
.IP \(bu 2
[Q]prec\-sqrt
.IP \(bu 2
\-fp\-model (Linux OS and OS X) or /fp (Windows OS)
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML (Short Vector Math Library) are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-finline
.TP
.B
\-fno\-inline
.RS
.TP
Tells the compiler to inline functions declared with !DIR$ ATTRIBUTES FORCEINLINE.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-inline
.NL
The compiler does not inline functions declared with !DIR$ ATTRIBUTES FORCEINLINE.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to inline functions declared with !DIR$ ATTRIBUTES FORCEINLINE.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-inline\-level
.NL
.RE
.TP
.B
\-finline\-functions
.TP
.B
\-fno\-inline\-functions
.RS
.TP
Enables function inlining for single file compilation.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-finline\-functions
.NL
Interprocedural optimizations occur. However, if you specify \-O0, the default is OFF.
.TP
\fBDescription:\fR 
.PP
This option enables function inlining for single file compilation. 
.NL
.PP
It enables the compiler to perform inline function expansion for calls to functions defined within the current source file.
.NL
.PP
The compiler applies a heuristic to perform the function expansion. To specify the size of the function to be expanded, use the \-finline\-limit option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-inline\-level=2
.NL
.RE
.TP
.B
\-finline\-limit=n
.RS
.TP
Lets you specify the maximum size of a function to be inlined.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Must be an integer greater than or equal to zero. It is the maximum number of lines the function can have to be considered for inlining.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses default heuristics when inlining functions.
.TP
\fBDescription:\fR 
.PP
This option lets you specify the maximum size of a function to be inlined. The compiler inlines smaller functions, but this option lets you inline large functions. For example, to indicate a large function, you could specify 100 or 1000 for \fIn\fR.
.NL
.PP
Note that parts of functions cannot be inlined, only whole functions.
.NL
.PP
This option is a modification of the \-finline\-functions option, whose behavior occurs by default.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-finstrument\-functions
.TP
.B
\-fno\-instrument\-functions
.RS
.TP
Determines whether routine entry and exit points are instrumented.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-instrument\-functions 
.NL
Routine entry and exit points are not instrumented.
.TP
\fBDescription:\fR 
.PP
This option determines whether routine entry and exit points are instrumented. It may increase execution time.
.NL
.PP
The following profiling functions are called with the address of the current routine and the address of where the routine was called (its "call site"):
.NL
.IP \(bu 2
This function is called upon routine entry:
.RS
.IP \(bu 2
.IP
void __cyg_profile_func_enter (void *this_fn,
.IP
void *call_site);
.RE
.IP \(bu 2
This function is called upon routine exit:
.RS
.IP \(bu 2
.IP
void __cyg_profile_func_exit (void *this_fn,
.IP
void *call_site);
.RE
.PP
These functions can be used to gather more information, such as profiling information or timing information. Note that it is the user\[aq]s responsibility to provide these profiling functions.
.NL
.PP
If you specify \-finstrument\-functions (Linux* OS and OS X*) or /Qinstrument\-functions (Windows* OS), routine inlining is disabled. If you specify \-fno\-instrument\-functions or /Qinstrument\-functions\-, inlining is not disabled.
.NL
.PP
This option is provided for compatibility with gcc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fixed
.TP
.B
\-nofixed
.RS
.TP
Specifies source files are in fixed format.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The source file format is determined from the file extension.
.TP
\fBDescription:\fR 
.PP
This option specifies source files are in fixed format. If this option is not specified, format is determined as follows:
.NL
.IP \(bu 2
Files with an extension of .f90, .F90, or .i90 are free\-format source files.
.IP \(bu 2
Files with an extension of .f, .for, .FOR, .ftn, .FTN, .fpp, .FPP, or .i are fixed\-format files.
.PP
Note that on Linux* and OS X* systems, file names and file extensions are case sensitive.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-FI
.NL
.RE
.TP
.B
\-fkeep\-static\-consts
.TP
.B
\-fno\-keep\-static\-consts
.RS
.TP
Tells the compiler to preserve allocation of variables that are not referenced in the source.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-keep\-static\-consts
.NL
If a variable is never referenced in a routine, the variable is discarded unless optimizations are disabled by option \-O0 (Linux* OS and OS X*).
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to preserve allocation of variables that are not referenced in the source.
.NL
.PP
The negated form can be useful when optimizations are enabled to reduce the memory usage of static data.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fltconsistency
.TP
.B
\-nofltconsistency
.RS
.TP
Enables improved floating\-point consistency.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
nofltconsistency
.NL
Improved floating\-point consistency is not enabled. This setting provides better accuracy and run\-time performance at the expense of less consistent floating\-point results.
.TP
\fBDescription:\fR 
.PP
This option enables improved floating\-point consistency and may slightly reduce execution speed. It limits floating\-point optimizations and maintains declared precision. It also disables inlining of math library functions.
.NL
.PP
Floating\-point operations are not reordered and the result of each floating\-point operation is stored in the target variable rather than being kept in the floating\-point processor for use in a subsequent calculation.
.NL
.PP
For example, the compiler can change floating\-point division computations into multiplication by the reciprocal of the denominator. This change can alter the results of floating\-point division computations slightly.
.NL
.PP
Floating\-point intermediate results are kept in full 80 bits internal precision. Additionally, all spills/reloads of the X87 floating point registers are done using the internal formats; this prevents accidental loss of precision due to spill/reload behavior over which you have no control.
.NL
.PP
Specifying this option has the following effects on program compilation:
.NL
.IP \(bu 2
Floating\-point user variables are not assigned to registers.
.IP \(bu 2
Floating\-point arithmetic comparisons conform to IEEE 754.
.IP \(bu 2
The exact operations specified in the code are performed. For example, division is never changed to multiplication by the reciprocal.
.IP \(bu 2
The compiler performs floating\-point operations in the order specified without reassociation.
.IP \(bu 2
The compiler does not perform constant folding on floating\-point values. Constant folding also eliminates any multiplication by 1, division by 1, and addition or subtraction of 0. For example, code that adds 0.0 to a number is executed exactly as written. Compile\-time floating\-point arithmetic is not performed to ensure that floating\-point exceptions are also maintained.
.IP \(bu 2
Whenever an expression is spilled, it is spilled as 80 bits (extended precision), not 64 bits (DOUBLE PRECISION). When assignments to type REAL and DOUBLE PRECISION are made, the precision is rounded from 80 bits down to 32 bits (REAL) or 64 bits (DOUBLE PRECISION). When you do not specify /fltconsistency, the extra bits of precision are not always rounded away before the variable is reused.
.IP \(bu 2
Even if vectorization is enabled by the [Q]x option, the compiler does not vectorize reduction loops (loops computing the dot product) and loops with mixed precision types. Similarly, the compiler does not enable certain loop transformations. For example, the compiler does not transform reduction loops to perform partial summation or loop interchange.
.PP
This option causes performance degradation relative to using default floating\-point optimization flags.
.NL
.PP
On Windows systems, an alternative is to use the /Qprec option, which should provide better than default floating\-point precision while still delivering good floating\-point performance.
.NL
.PP
The recommended method to control the semantics of floating\-point calculations is to use option \-fp\-model (Linux* OS and OS X*) or /fp (Windows* OS).
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
fltconsistency
.NL
Linux and OS X: \-mieee\-fp
.TP 18
nofltconsistency
.NL
Linux and OS X: \-mno\-ieee\-fp
.RE
.TP
.B
\-fma
.TP
.B
\-no\-fma
.RS
.TP
Determines whether the compiler generates fused multiply\-add (FMA) instructions if such instructions exist on the target processor. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fma 
.NL
If the instructions exist on the target processor, the compiler generates fused multiply\-add (FMA) instructions.
.IP
However, if you specify 
\-fp\-model strict (Linux* OS and OS X*), but do not explicitly specify \-fma, the default is \-no\-fma.  
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler
generates fused multiply\-add (FMA) instructions if such instructions exist on the target processor. When the [Q]fma option
is specified, the compiler may generate FMA
instructions for combining multiply and add operations. When the negative form of the 
[Q]fma option is specified, the
compiler must generate separate multiply and add
instructions with intermediate rounding.
.NL
.PP
This option has no effect unless setting CORE\-AVX2 or higher is specified for option [Q]x,  \-march (Linux OS and OS X), or /arch (Windows OS).
.NL
.RE
.TP
.B
\-fmath\-errno
.TP
.B
\-fno\-math\-errno
.RS
.TP
Tells the compiler that errno can be reliably tested after calls to standard math library functions.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-math\-errno
.NL
The compiler assumes that the program does not test errno after calls to standard math library functions.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to assume that the program tests errno after calls to math library functions. This restricts optimization because it causes the compiler to treat most math functions as having side effects.
.NL
.PP
Option \-fno\-math\-errno tells the compiler to assume that the program does not test errno after calls to math library functions. This frequently allows the compiler to generate faster code. Floating\-point code that relies on IEEE exceptions instead of errno to detect errors can safely use this option to improve performance.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fmerge\-constants (L*X only)
.TP
.B
\-fno\-merge\-constants (L*X only)
.RS
.TP
Determines whether the compiler and linker attempt to merge identical constants (string constants and floating\-point constants) across compilation units.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fmerge\-constants
.NL
The compiler and linker attempt to merge identical constants across compilation units if the compiler and linker supports it.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler and linker
attempt to merge identical constants (string constants and
floating\-point constants) across compilation units.
.NL
.PP
If you do not want the compiler and linker to
attempt to merge identical constants across compilation units.
specify \-fno\-merge\-constants.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fmerge\-debug\-strings (L*X only)
.TP
.B
\-fno\-merge\-debug\-strings (L*X only)
.RS
.TP
Causes the compiler to pool strings used in debugging information.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fmerge\-debug\-strings
.NL
The compiler will pool strings used in debugging information.
.TP
\fBDescription:\fR 
.PP
This option causes the compiler to pool strings
used in debugging information. The linker will automatically retain
this pooling.
.NL
.PP
This option can reduce the size of debug
information, but it may produce slightly slower compile and link
times.
.NL
.PP
This option is only turned on by default if you
are using gcc 4.3 or later, where this setting is also the default,
since the generated debug tables require binutils version 2.17 or
later to work reliably.
.NL
.PP
If you do not want the compiler to pool strings
used in debugging information, specify option
\-fno\-merge\-debug\-strings.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fminshared
.RS
.TP
Specifies that a compilation unit is a component of a main program and should not be linked as part of a shareable object.
.NL
.TP
\fBArchitecture Restrictions:\fR  Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Source files are compiled together to form a single object file.
.TP
\fBDescription:\fR 
.PP
This option specifies that a compilation unit is a component of a main program and should not be linked as part of a shareable object.
.NL
.PP
This option allows the compiler to optimize references to defined symbols without special visibility settings. To ensure that external and common symbol references are optimized, you need to specify visibility hidden or protected by using the \-fvisibility, \-fvisibility\-hidden, or \-fvisibility\-protected option.
.NL
.PP
Also, the compiler does not need to generate position\-independent code for the main program. It can use absolute addressing, which may reduce the size of the global offset table (GOT) and may reduce memory traffic.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fmpc\-privatize (L*X only)
.TP
.B
\-fno\-mpc\-privatize (L*X only)
.RS
.TP
Enables or disables privatization of all static data for the MultiProcessor Computing environment (MPC) unified parallel runtime.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-mpc\-privatize
.NL
The privatization of all static data for the MPC unified parallel runtime is disabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables privatization of all static data for the MultiProcessor Computing environment (MPC) unified parallel runtime. 
.NL
.PP
Option  \-fmpc\-privatize  causes calls to extended thread\-local\-storage (TLS) resolution, run\-time routines that are not supported on standard Linux* OS distributions. 
.NL
.PP
This option requires installation of another product. For more information, see Feature Requirements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fomit\-frame\-pointer
.TP
.B
\-fno\-omit\-frame\-pointer
.RS
.TP
Determines whether EBP is used as a general\-purpose register in optimizations.
.NL
.TP
\fBArchitecture Restrictions:\fR Option /Oy[\-] is only available on IA\-32 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fomit\-frame\-pointer 
.NL
EBP is used as a general\-purpose register in optimizations. However, on Linux* and OS X* systems, the default is \-fno\-omit\-frame\-pointer if option \-O0 or \-g is specified. 
.TP
\fBDescription:\fR 
.PP
These options determine whether EBP is used as a general\-purpose register in optimizations. Options \-fomit\-frame\-pointer and /Oy allow this use. Options \-fno\-omit\-frame\-pointer and /Oy\- disallow it.
.NL
.PP
Some debuggers expect EBP to be used as a stack frame pointer, and cannot produce a stack backtrace unless this is so. The \-fno\-omit\-frame\-pointer and /Oy\- options direct the compiler to generate code that maintains and uses EBP as a stack frame pointer for all functions so that a debugger can still produce a stack backtrace without doing the following:
.NL
.IP \(bu 2
For \-fno\-omit\-frame\-pointer: turning off optimizations with \-O0
.IP \(bu 2
For /Oy\-: turning off /O1, /O2, or /O3 optimizations
.PP
The \-fno\-omit\-frame\-pointer option is set when you specify option \-O0 or the \-g option. The \-fomit\-frame\-pointer option is set when you specify option \-O1, \-O2, or \-O3.
.NL
.PP
The /Oy option is set when you specify the /O1, /O2, or /O3 option. Option /Oy\- is set when you specify the /Od option.
.NL
.PP
Using the \-fno\-omit\-frame\-pointer or /Oy\- option reduces the number of available general\-purpose registers by 1, and can result in slightly less efficient code.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-fp (this is a deprecated option)
.NL
.RE
.TP
.B
\-foptimize\-sibling\-calls
.TP
.B
\-fno\-optimize\-sibling\-calls
.RS
.TP
Determines whether the compiler optimizes tail recursive calls.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-foptimize\-sibling\-calls
.NL
The compiler optimizes tail recursive calls.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler
optimizes tail recursive calls. It enables conversion of tail recursion into
loops.
.NL
.PP
If you do not want to optimize tail recursive
calls, specify \-fno\-optimize\-sibling\-calls.
.NL
.PP
Tail recursion is a special form of recursion
that doesn\[aq]t use stack space. In tail recursion, a recursive call
is converted to a GOTO statement that returns to the beginning of
the function. In this case, the return value of the recursive call
is only used to be returned. It is not used in another expression.
The recursive function is converted into a loop, which prevents
modification of the stack space used.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fp\-model keyword
.RS
.TP
Controls the semantics of floating\-point calculations.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies the semantics to be used. Possible values are:
.RS
.TP 15
precise
Disables optimizations that are not  value\-safe on floating\-point data and rounds intermediate results to source\-defined precision.
.TP 15
fast[=1|2]
Enables more aggressive optimizations on floating\-point data.
.TP 15
strict
Enables precise and except, disables contractions, and 
enables the property that allows modification of the floating\-point environment.
.TP 15
source
Rounds intermediate results to source\-defined precision.
.TP 15
[no\-]except (Linux* OS and OS X*) or except[\-] (Windows* OS)
Determines whether strict floating\-point exception semantics are honored.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-fp\-model fast=1 
.NL
The compiler uses more aggressive optimizations on floating\-point calculations.
.TP
\fBDescription:\fR 
.PP
This option controls the semantics of floating\-point calculations.
.NL
.PP
The \fIkeywords\fR can be considered in groups:
.NL
.IP \(bu 2
Group A: precise, fast, strict
.IP \(bu 2
Group B: source
.IP \(bu 2
Group C: except (or the negative form) 
.PP
You can use more than one \fIkeyword\fR. However, the following rules apply:
.NL
.IP \(bu 2
You cannot specify fast and except together in the same compilation. You can specify any other combination of group A, group B, and group C. Since fast is the default, you must not specify except without a group A or group B \fIkeyword\fR.
.IP \(bu 2
You should specify only one \fIkeyword\fR from group A and only one \fIkeyword\fR from  group B. If you try to specify more than one \fIkeyword\fR from either group A or group B, the last (rightmost) one takes effect.
.IP \(bu 2
If you specify except more than once, the last (rightmost) one takes effect.
.PP
The floating\-point (FP) environment is a collection of registers that control the behavior of FP machine instructions and indicate the current FP status. The floating\-point environment may include rounding\-mode controls, exception masks, flush\-to\-zero controls, exception status flags, and other floating\-point related features.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
\-fp\-model precise or /fp:precise
.NL
Tells the compiler to strictly adhere to value\-safe optimizations when implementing floating\-point calculations. It disables optimizations that can change the result of floating\-point calculations. 
.TP 18
These semantics ensure the reproducibility of floating\-point computations for serial code, including code vectorized or auto\-parallelized by the compiler, but they may slow performance. They do not ensure value safety or run\-to\-run reproducibility of other parallel code.  
Run\-to\-run reproducibility for floating\-point reductions in OpenMP* code may be obtained for a fixed number of threads through the KMP_DETERMINISTIC_REDUCTION environment variable. 
For more information about this environment variable, see 
\fISupported Environment Variables\fR.
.TP 18
The compiler assumes the default floating\-point environment; you are not allowed to modify it.
.TP 18
Note that option fp\-model precise is converted to fp\-model source and option fp:precise is converted to fp:source.
.TP 18
IA\-32 architecture: Windows: Double; Linux: Extended; OS X: Extended
.TP 18
Intel(R) 64 architecture: All operating systems: Source
.TP 18
Floating\-point exception semantics are disabled by default. To enable these semantics, you must also specify \-fp\-model except or /fp:except.
.TP 18
Note that option fp\-model precise enables option assume protect\-parens, which tells the optimizer to honor parentheses in REAL and COMPLEX expression evaluations by not reassociating operations.
.NL
.TP 18
\-fp\-model fast[=1|2] or /fp:fast[=1|2]
.NL
Tells the compiler to use more aggressive optimizations when implementing floating\-point calculations. These optimizations increase speed,  but may affect the accuracy or reproducibility of floating\-point computations.
.TP 18
Specifying fast is the same as specifying fast=1. fast=2 may produce faster and less accurate results.
.TP 18
Floating\-point exception semantics are disabled by default and they cannot be enabled because you cannot specify fast and except together in the same compilation. To enable exception semantics, you must explicitly specify another keyword (see other keyword descriptions for details).
.NL
.TP 18
\-fp\-model strict or /fp:strict
.NL
Tells the compiler to strictly adhere to value\-safe optimizations when implementing floating\-point calculations and enables floating\-point exception semantics. This is the strictest floating\-point model.
.TP 18
The compiler does not assume the default floating\-point environment; you are allowed to modify it.
.TP 18
Floating\-point exception semantics can be disabled by explicitly specifying \-fp\-model no\-except or /fp:except\-.
.NL
.TP 18
\-fp\-model source or /fp:source
.NL
This option causes intermediate results to be rounded to the precision defined in the source code. It also implies keyword precise unless it is overridden by a keyword from Group A.
.TP 18
long double: 64\-bit precision; 80\-bit data type; 15\-bit exponent
.TP 18
double: 53\-bit precision; 64\-bit data type; 11\-bit exponent; on Windows systems using IA\-32 architecture, the exponent may be 15\-bit if an x87 register is used to hold the value.
.TP 18
float: 24\-bit precision; 32\-bit data type; 8\-bit exponent
.TP 18
The compiler assumes the default floating\-point environment; you are not allowed to modify it.
.TP 18
Note that option fp\-model source enables option assume protect\-parens, which tells the optimizer to honor parentheses in REAL and COMPLEX expression evaluations by not reassociating operations.
.NL
.TP 18
\-fp\-model except or /fp:except
.NL
Tells the compiler to follow strict floating\-point exception semantics.
.NL
.PP
The \-fp\-model and /fp  options determine the setting for the
maximum allowable relative error for math library function results
(max\-error) if none of the following options are
specified:
.NL
.IP \(bu 2
\-fimf\-accuracy\-bits (Linux* OS and OS X*) or
/Qimf\-accuracy\-bits (Windows* OS)
.IP \(bu 2
\-fimf\-max\-error (Linux OS and OS X) or
/Qimf\-max\-error (Windows OS)
.IP \(bu 2
\-fimf\-precision (Linux OS and OS X) or
/Qimf\-precision (Windows OS)
.IP \(bu 2
[Q]fast\-transcendentals
.PP
Option \-fp\-model fast (and /fp:fast) sets option \-fimf\-precision=medium (/Qimf\-precision:medium) and option \-fp\-model precise (and /fp:precise) implies \-fimf\-precision=high (and /Qimf\-precision:high). Option \-fp\-model fast=2 (and /fp:fast2) sets option \-fimf\-precision=medium (and /Qimf\-precision:medium) and option \-fimf\-domain\-exclusion=15 (and /Qimf\-domain\-exclusion=15).
.NL
.PP
.B NOTE:
This option cannot be used to change the default (source) precision for the calculation of intermediate results.
.PP
.B NOTE:
On Windows and Linux operating systems on IA\-32 architecture,  the compiler, by default, implements floating\-point (FP) arithmetic using SSE2 and SSE instructions. This can cause differences in floating\-point results when compared to previous x87 implementations.
.PP
.B NOTE:
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fp\-port
.TP
.B
\-no\-fp\-port
.RS
.TP
Rounds floating\-point results after floating\-point operations. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-fp\-port 
.NL
The default rounding behavior depends on the compiler\[aq]s code generation decisions and the precision parameters of the operating system.
.TP
\fBDescription:\fR 
.PP
This option rounds floating\-point results after
floating\-point operations.
.NL
.PP
This option is designed to be used with the
\-mia32 (Linux* OS and OS X*) or /arch:IA32 (Windows* OS ) option on
a 32\-bit compiler. Under those conditions, the compiler implements
floating\-point calculations using the x87 instruction set, which
uses an internal precision that may be higher than the precision
specified in the program.
.NL
.PP
By default, the compiler may keep results of
floating\-point operations in this higher internal precision.
Rounding to program precision occurs at unspecified points. This
provides better performance, but the floating\-point results are
less deterministic. The [Q]fp\-port option rounds floating\-point
results to user\-specified precision at assignments and type
conversions. This has some impact on speed.
.NL
.PP
When compiling for newer architectures, the
compiler implements floating\-point calculations with different
instructions, such as Intel(R) SSE and SSE2. These Intel(R) Streaming
SIMD Extensions round directly to single precision or double
precision at every instruction. In these cases, option [Q]fp\-port
has no effect.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fp\-speculation=mode
.RS
.TP
Tells the compiler the mode in which to speculate on floating\-point operations.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fImode\fR
.NL
Is the mode for floating\-point operations. Possible values are:
.RS
.TP 15
fast
Tells the compiler to speculate on floating\-point operations.
.TP 15
safe
Tells the compiler to disable speculation if there is a possibility that the speculation may cause a floating\-point exception.
.TP 15
strict
Tells the compiler to disable speculation on floating\-point operations.
.TP 15
off
This is the same as specifying strict.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-fp\-speculation=fast 
.NL
The compiler speculates on floating\-point operations. This is also the behavior when optimizations are enabled. However, if you specify no optimizations (\-O0 on Linux* OS), the default is \-fp\-speculation=safe (Linux* OS).
.TP
\fBDescription:\fR 
.PP
This option tells the compiler the mode in which to speculate on floating\-point operations.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fp\-stack\-check
.RS
.TP
Tells the compiler to generate extra code after every function call to ensure that the floating\-point stack is in the expected state.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
There is no checking to ensure that the floating\-point (FP) stack is in the expected state.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate extra code after every function call to ensure that the floating\-point (FP) stack is in the expected state.
.NL
.PP
By default, there is no checking. So when the FP stack overflows, a NaN value is put into FP calculations and the program\[aq]s results differ. Unfortunately, the overflow point can be far away from the point of the actual bug. This option places code that causes an access violation exception immediately after an incorrect call occurs, thus making it easier to locate these issues. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fpconstant
.TP
.B
\-nofpconstant
.RS
.TP
Tells the compiler that single\-precision constants assigned to double\-precision variables should be evaluated in double precision.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
nofpconstant
.NL
Single\-precision constants assigned to double\-precision variables are evaluated in single precision according to Fortran 2003 Standard rules.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler that single\-precision constants assigned to double\-precision variables should be evaluated in double precision.
.NL
.PP
This is extended precision. It does not comply with the Fortran 2003
standard, which requires that single\-precision constants assigned to double\-precision variables be evaluated in single precision.
.NL
.PP
It allows compatibility with FORTRAN 77, where such extended precision was allowed. If this option is not used, certain programs originally created for FORTRAN 77 compilers may show different floating\-point results because they rely on the extended precision for single\-precision constants assigned to double\-precision variables.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fpen
.RS
.TP
Allows some control over floating\-point exception handling for the main program at run\-time.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
n
.NL
Specifies the floating\-point exception handling level. Possible values are:
.RS
.TP 15
0
Floating\-point invalid, divide\-by\-zero, and overflow exceptions are enabled. If any such exceptions occur, execution is aborted.  This option causes denormalized floating\-point results to be set to zero. Underflow results will also be set to zero, unless you override this by explicitly specifying option \-no\-ftz or \-fp\-model precise (Linux* OS and OS X*) or option /Qftz\- or /fp:precise (Windows* OS).
.IP
Underflow results from SSE instructions, as well as x87 instructions, will be set to zero. By contrast, option [Q]ftz only sets SSE underflow results to zero.
.IP
To get more detailed location information about where the error occurred, use option traceback.
.TP 15
1
All floating\-point exceptions are disabled. 
.IP
Underflow results from SSE instructions, as well as x87 instructions, will be set to zero.
.TP 15
3
All floating\-point exceptions are disabled. Floating\-point underflow is gradual, unless you explicitly specify a compiler option that enables flush\-to\-zero, such as [Q]ftz, O3, or O2. This setting provides full IEEE support.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-fpe3
.NL
All floating\-point exceptions are disabled. Floating\-point underflow is gradual, unless you explicitly specify a compiler option that enables flush\-to\-zero.
.TP
\fBDescription:\fR 
.PP
This option allows some control over floating\-point exception handling for the main program at run\-time. This includes whether exceptional floating\-point values are allowed and how precisely run\-time exceptions are reported.
.NL
.PP
The fpe option affects how the following conditions are handled:
.NL
.IP \(bu 2
When floating\-point calculations result in a divide by zero, overflow, or invalid operation.
.IP \(bu 2
When floating\-point calculations result in an underflow.
.IP \(bu 2
When a denormalized number or other exceptional number (positive infinity, negative infinity, or a NaN) is present in an arithmetic expression.
.PP
When enabled exceptions occur, execution is aborted and the cause of the abort reported to the user. If compiler option traceback is specified at compile time, detailed information about the location of the abort is also reported.
.NL
.PP
This option does not enable underflow exceptions, input denormal exceptions, or inexact exceptions.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fpe\-all=n
.RS
.TP
Allows some control over floating\-point exception handling for each routine in a program at run\-time.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
n
.NL
Specifies the floating\-point exception handling level. Possible values are:
.RS
.TP 15
0
Floating\-point invalid, divide\-by\-zero, and overflow exceptions are enabled. If any such exceptions occur, execution is aborted. This option sets the [Q]ftz option; therefore underflow results will be set to zero unless you explicitly specify \-no\-ftz (Linux OS and OS X) or /Qftz\- (Windows OS).
.IP
To get more detailed location information about where the error occurred, use option traceback.
.TP 15
1
All floating\-point exceptions are disabled. 
.IP
Underflow results from SSE instructions, as well as x87 instructions, will be set to zero.
.TP 15
3
All floating\-point exceptions are disabled. Floating\-point underflow is gradual, unless you explicitly specify a compiler option that enables flush\-to\-zero, such as [Q]ftz, O3, or O2. This setting provides full IEEE support.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-fpe\-all=3  or the setting of fpe that the main program was compiled with
.NL
All floating\-point exceptions are disabled. Floating\-point underflow is gradual, unless you explicitly specify a compiler option that enables flush\-to\-zero.
.TP
\fBDescription:\fR 
.PP
This option allows some control over floating\-point exception handling for each routine in a program at run\-time. This includes whether exceptional floating\-point values are allowed and how precisely run\-time exceptions are reported.
.NL
.PP
The fpe\-all option affects how the following conditions are handled:
.NL
.IP \(bu 2
When floating\-point calculations result in a divide by zero, overflow, or invalid operation.
.IP \(bu 2
When floating\-point calculations result in an underflow.
.IP \(bu 2
When a denormalized number or other exceptional number (positive infinity, negative infinity, or a NaN) is present in an arithmetic expression.
.PP
The current settings of the floating\-point exception and status flags are saved on each routine entry and restored on each routine exit. This may incur some performance overhead.
.NL
.PP
When option fpe\-all is applied to a main program, it has the same effect as when option fpe is applied to the main program.
.NL
.PP
When enabled exceptions occur, execution is aborted and the cause of the abort reported to the user. If compiler option traceback is specified at compile time, detailed information about the location of the abort is also reported.
.NL
.PP
This option does not enable underflow exceptions, input denormal exceptions, or inexact exceptions.
.NL
.PP
Option fpe\-all sets option assume ieee_fpe_flags.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fpic
.TP
.B
\-fno\-pic
.RS
.TP
Determines whether the compiler generates position\-independent code.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-pic
.NL
The compiler does not generate position\-independent code.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler generates position\-independent code.
.NL
.PP
Option \-fpic specifies full symbol preemption. Global symbol definitions as well as global symbol references get default (that is, preemptable) visibility unless explicitly specified otherwise.
.NL
.PP
Option \-fpic must be used when building shared objects.
.NL
.PP
This option can also be specified as \-fPIC.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fpie (L*X only)
.RS
.TP
Tells the compiler to generate position\-independent code. The generated code can only be linked into executables. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate position\-independent code for an executable\-only object.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate position\-independent code. It is similar to \-fpic, but code generated by \-fpie can only be linked into an executable. 
.NL
.PP
Because the object is linked into an executable, this option causes better optimization of some symbol references.
.NL
.PP
To ensure that run\-time libraries are set up properly for the executable, you should also specify option \-pie to the compiler driver on the link command line. 
.NL
.PP
Option \-fpie can also be specified as \-fPIE.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fpp
.TP
.B
\-nofpp
.RS
.TP
Runs the Fortran preprocessor on source files before compilation.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfpp_option\fR
.NL
Is a Fortran preprocessor (fpp) option; it must start with a slash (/) and appear in quotes. This argument is only allowed on Windows* systems.
.TP
\fBDefault:\fR 
.TP 18
nofpp
.NL
The Fortran preprocessor is not run on files before compilation.
.TP
\fBDescription:\fR 
.PP
This option runs the Fortran preprocessor on source files before they are compiled.
.NL
.PP
If you want to pass fpp options to the Fortran preprocessor, you can use any of the following methods:
.NL
.IP \(bu 2
Use option Qoption,fpp,"option". This is the recommended method.
.IP \(bu 2
On Windows* OS, use this option (fpp) and include the argument \fIfpp_option\fR (for example, fpp:"/macro=no").
.IP \(bu 2
On Linux* OS and OS X*, use option \-Wp,fpp_option (for example, \-Wp,\-macro=no).
.PP
To see a list of all available fpp options, specify one of the following on the command line:
.NL
.PP
fpp \-help     ! Linux and OS X systems
.PP
.PP
fpp /help     ! Windows systems
.PP
.PP
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-cpp (this is a deprecated option)
.NL
.RE
.TP
.B
\-fpscomp [keyword[, keyword...]]
.TP
.B
\-nofpscomp
.RS
.TP
Controls whether certain aspects of the run\-time system and semantic language features within the compiler are compatible with Intel(R) Fortran or Microsoft* Fortran PowerStation.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the compatibility that the compiler should follow. Possible values are:
.RS
.TP 15
none
Specifies that no options should be used for compatibility.
.TP 15
[no]filesfromcmd
Determines what compatibility is used when the OPEN statement FILE= specifier is blank.
.TP 15
[no]general
Determines what compatibility is used when semantics differences exist between Fortran PowerStation and Intel(R) Fortran.
.TP 15
[no]ioformat
Determines what compatibility is used for list\-directed formatted and unformatted I/O.
.TP 15
[no]libs
Determines whether the portability library is passed to the linker.
.TP 15
[no]ldio_spacing
Determines whether a blank is inserted at run\-time after a numeric value before a character value.
.TP 15
[no]logicals
Determines what compatibility is used for representation of LOGICAL values.
.TP 15
all
Specifies that all options should be used for compatibility.
.RE
.TP
\fBDefault:\fR 
.TP 18
fpscomp libs
.NL
The portability library is passed to the linker.
.TP
\fBDescription:\fR 
.PP
This option controls whether certain aspects of the run\-time system and semantic language features within the compiler are compatible with Intel Fortran or Microsoft* Fortran PowerStation.
.NL
.PP
If you experience problems when porting applications from Fortran PowerStation, specify fpscomp (or fpscomp all). When porting applications from Intel Fortran, use fpscomp none or fpscomp libs (the default).
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
fpscomp none
.NL
Specifies that no options should be used for compatibility with Fortran PowerStation. This is the same as specifying nofpscomp. Option fpscomp none enables full Intel(R) Fortran compatibility. If you omit fpscomp, the default is fpscomp libs. You cannot use the fpscomp and vms options in the same command.
.NL
.TP 18
fpscomp filesfromcmd
.NL
Specifies Fortran PowerStation behavior when the OPEN statement FILE= specifier is blank (FILE=\[aq] \[aq]). It causes the following actions to be taken at run time:
.RS
.IP \(bu 2
The program reads a file name from the list of arguments (if any) in the command line that invoked the program. If any of the command\-line arguments contain a null string (\[aq]\[aq]), the program asks the user for the corresponding file name. Each additional OPEN statement with a blank FILE= specifier reads the next command\-line argument.
.IP \(bu 2
If there are more nameless OPEN statements than command\-line arguments, the program prompts for additional file names.
.IP \(bu 2
In a QuickWin application, a "File Select" dialog box appears to request file names.
.RE
.TP 18
To prevent the run\-time system from using the file name specified on the command line when the OPEN statement FILE specifier is omitted, specify fpscomp nofilesfromcmd. This allows the application of Intel Fortran defaults, such as the FORTn environment variable and the FORT. \fIn\fR file name (where \fIn\fR is the unit number).
.TP 18
The fpscomp filesfromcmd option affects the following Fortran features:
.RS
.IP \(bu 2
The OPEN statement FILE specifier
For example, assume a program OPENTEST contains the following statements:
OPEN(UNIT = 2, FILE = \[aq] \[aq])
OPEN(UNIT = 3, FILE = \[aq] \[aq])
OPEN(UNIT = 4, FILE = \[aq] \[aq])
The following command line assigns the file TEST.DAT to unit 2, prompts the user for a file name to associate with unit 3, then prompts again for a file name to associate with unit 4:
opentest test.dat \[aq]\[aq] \[aq]\[aq]
.IP \(bu 2
Implicit file open statements such as the WRITE, READ, and ENDFILE statements Unopened files referred to in READ or WRITE statements are opened implicitly as if there had been an OPEN statement with a name specified as all blanks. The name is read from the command line.
.RE
.NL
.TP 18
fpscomp general
.NL
Specifies that Fortran PowerStation semantics should be used when a difference exists between Intel Fortran and Fortran PowerStation. The fpscomp general option affects the following Fortran features:
.IP \(bu 2
The BACKSPACE statement:
.RS
.IP \(bu 2
It allows files opened with ACCESS=\[aq]APPEND\[aq] to be used with the BACKSPACE statement.
.IP \(bu 2
It allows files opened with ACCESS=\[aq]DIRECT\[aq] to be used with the BACKSPACE statement.
.RE
Note: Allowing files that are not opened with sequential access (such as ACCESS=\[aq]DIRECT\[aq]) to be used with the BACKSPACE statement violates the Fortran 95 standard and may be removed in the future.
.IP \(bu 2
The READ statement:
.RS
.IP \(bu 2
It causes a READ from a formatted file opened for direct access to read records that have the same record type format as Fortran PowerStation. This consists of accounting for the trailing Carriage Return/Line Feed pair (<CR><LF>) that is part of the record. It allows sequential reads from a formatted file opened for direct access.
Note: Allowing files that are not opened with sequential access (such as ACCESS=\[aq]DIRECT\[aq]) to be used with the sequential READ statement violates the Fortran 95 standard and may be removed in the future.
.IP \(bu 2
It allows the last record in a file opened with FORM=\[aq]FORMATTED\[aq] and a record type of STREAM_LF or STREAM_CR that does not end with a proper record terminator (<line feed> or <carriage return>) to be read without producing an error.
.IP \(bu 2
It allows sequential reads from an unformatted file opened for direct access.
.IP \(bu 2
Note: Allowing files that are not opened with sequential access (such as ACCESS=\[aq]DIRECT\[aq]) to be read with the sequential READ statement violates the Fortran 95 standard and may be removed in the future.
.RE
.IP \(bu 2
The INQUIRE statement:
.RS
.IP \(bu 2
The CARRIAGECONTROL specifier returns the value "UNDEFINED" instead of "UNKNOWN" when the carriage control is not known.
.IP \(bu 2
The NAME specifier returns the file name "UNKNOWN" instead of filling the file name with spaces when the file name is not known.
.IP \(bu 2
The SEQUENTIAL specifier returns the value "YES" instead of "NO" for a direct access formatted file.
.IP \(bu 2
The UNFORMATTED specifier returns the value "NO" instead of "UNKNOWN" when it is not known whether unformatted I/O can be performed to the file.
Note: Returning the value "NO" instead of "UNKNOWN" for this specifier violates the Fortran 95 standard and may be removed in the future.
.RE
.IP \(bu 2
The OPEN statement:
.RS
.IP \(bu 2
If a file is opened with an unspecified STATUS keyword value, and is not named (no FILE specifier), the file is opened as a scratch file.
For example:
OPEN (UNIT = 4)
.IP \(bu 2
In contrast, when fpscomp nogeneral is in effect with an unspecified STATUS value with no FILE specifier, the FORT\fIn\fR environment variable and the FORT.n file name are used (where \fIn\fR is the unit number).
.IP \(bu 2
If the STATUS value was not specified and if the name of the file is "USER", the file is marked for deletion when it is closed.
.IP \(bu 2
It allows a file to be opened with the APPEND and READONLY characteristics.
.IP \(bu 2
If the default for the CARRIAGECONTROL specifier is assumed, it gives "LIST" carriage control to direct access formatted files instead of "NONE".
.IP \(bu 2
If the default for the CARRIAGECONTROL specifier is assumed and the device type is a terminal file, the file is given the default carriage control value of "FORTRAN" instead of "LIST".
.IP \(bu 2
It gives an opened file the additional default of write sharing.
.IP \(bu 2
It 
gives the file a default block size of 1024 instead of 8192.
.IP \(bu 2
If the default for the MODE and ACTION specifier is assumed and there was an error opening the file, try opening the file as read only, then write only.
.IP \(bu 2
If a file that is being re\-opened has a different file type than the current existing file, an error is returned.
.IP \(bu 2
It gives direct access formatted files the same record type as Fortran PowerStation. This means accounting for the trailing Carriage Return/Line Feed pair (<CR><LF>) that is part of the record.
.RE
.IP \(bu 2
The STOP statement: It writes the Fortran PowerStation output string and/or returns the same exit condition values.
.IP \(bu 2
The WRITE statement:
.RS
.IP \(bu 2
Writing to formatted direct files
When writing to a formatted file opened for direct access, records are written in the same record type format as Fortran PowerStation. This consists of adding the trailing Carriage Return/Line Feed pair <CR><LF>) that is part of the record.
It ignores the CARRIAGECONTROL specifier setting when writing to a formatted direct access file.
.IP \(bu 2
Interpreting Fortran carriage control characters
When interpreting Fortran carriage control characters during formatted I/O, carriage control sequences are written that are the same as Fortran PowerStation. This is true for the "Space, 0, 1 and + " characters.
.IP \(bu 2
Performing non\-advancing I/O to the terminal
When performing non\-advancing I/O to the terminal, output is written in the same format as Fortran PowerStation.
.IP \(bu 2
Interpreting the backslash (\) and dollar ($) edit descriptors
When interpreting backslash and dollar edit descriptors during formatted I/O, sequences are written the same as Fortran PowerStation.
.IP \(bu 2
Performing sequential writes
It allows sequential writes from an unformatted file opened for direct access.
Note: Allowing files that are not opened with sequential access (such as ACCESS=\[aq]DIRECT\[aq]) to be read with the sequential WRITE statement violates the Fortran 95 standard and may be removed in the future.
.RE
.TP 18
Specifying fpscomp general sets fpscomp ldio_spacing.
.NL
.TP 18
fpscomp ioformat
.NL
Specifies that Fortran PowerStation semantic conventions and record formats should be used for list\-directed formatted and unformatted I/O. The fpscomp ioformat option affects the following Fortran features:
.IP \(bu 2
The WRITE statement:
.RS
.IP \(bu 2
For formatted list\-directed WRITE statements, formatted internal list\-directed WRITE statements, and formatted namelist WRITE statements, the output line, field width values, and the list\-directed data type semantics are determined according to the following sample for real constants (N below):
For 1 <= N < 10**7, use F15.6 for single precision or F24.15 for double.
For N < 1 or N >= 10**7, use E15.6E2 for single precision or E24.15E3 for double.
See the Fortran PowerStation documentation for more detailed information about the other data types affected.
.IP \(bu 2
For unformatted WRITE statements, the unformatted file semantics are dictated according to the Fortran PowerStation documentation; these semantics are different from the Intel Fortran file format. See the Fortran PowerStation documentation for more detailed information.
The following table summarizes the default output formats for list\-directed output with the intrinsic data types:
.RE
.IP \(bu 2
The READ statement:
.RS
.IP \(bu 2
For formatted list\-directed READ statements, formatted internal list\-directed READ statements, and formatted namelist READ statements, the field width values and the list\-directed semantics are dictated according to the following sample for real constants (N below):
For 1 <= N < 10**7, use F15.6 for single precision or F24.15 for double.
For N < 1 or N >= 10**7, use E15.6E2 for single precision or E24.15E3 for double.
See the Fortran PowerStation documentation for more detailed information about the other data types affected.
.IP \(bu 2
For unformatted READ statements, the unformatted file semantics are dictated according to the Fortran PowerStation documentation; these semantics are different from the Intel Fortran file format. See the Fortran PowerStation documentation for more detailed information.
.RE
.NL
.TP 18
fpscomp nolibs
.NL
Prevents the portability library from being passed to the linker.
.NL
.TP 18
fpscomp ldio_spacing
.NL
Specifies that at run time a blank should not be inserted after a numeric value before a character value (undelimited character string). This representation is used by Intel Fortran releases before Version 8.0 
and by Fortran PowerStation. If you specify fpscomp general, it sets fpscomp ldio_spacing.
.NL
.TP 18
fpscomp logicals
.NL
Specifies that integers with a non\-zero value are treated as true, integers with a zero value are treated as false. The literal constant .TRUE. has an integer value of 1, and the literal constant .FALSE. has an integer value of 0. This representation is used by Intel Fortran releases before Version 8.0 and by Fortran PowerStation. 
.TP 18
The default is fpscomp nologicals, which specifies that odd integer values (low bit one) are treated as true and even integer values (low bit zero) are treated as false. 
.TP 18
The literal constant .TRUE. has an integer value of \-1, and the literal constant .FALSE. has an integer value of 0. This representation is used by Compaq* Visual Fortran. The internal representation of LOGICAL values is not specified by the Fortran standard. Programs which use integer values in LOGICAL contexts, or which pass LOGICAL values to procedures written in other languages, are non\-portable and may not execute correctly. Intel recommends that you avoid coding practices that depend on the internal representation of LOGICAL values. 
.TP 18
The fpscomp logical option affects the results of all logical expressions and affects the return value for the following Fortran features:
.IP \(bu 2
The INQUIRE statement specifiers OPENED, IOFOCUS, EXISTS, and NAMED
.IP \(bu 2
The EOF intrinsic function
.IP \(bu 2
The BTEST intrinsic function
.IP \(bu 2
The lexical intrinsic functions LLT, LLE, LGT, and LGE
.NL
.TP 18
fpscomp all
.NL
Specifies that all options should be used for compatibility with Fortran PowerStation. This is the same as specifying fpscomp with no keyword. Option fpscomp all enables full compatibility with Fortran PowerStation.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-free 
.TP
.B
\-nofree
.RS
.TP
Specifies source files are in free format.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The source file format is determined from the file extension.
.TP
\fBDescription:\fR 
.PP
This option specifies source files are in free format. If this option is not specified, format is determined as follows:
.NL
.IP \(bu 2
Files with an extension of .f90, .F90, or .i90 are free\-format source files.
.IP \(bu 2
Files with an extension of .f, .for, .FOR, .ftn, or .i are fixed\-format files.
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-FR
.NL
.RE
.TP
.B
\-fsource\-asm
.RS
.TP
Produces an assembly listing with source code annotations.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No source code annotations appear in the assembly listing file, if one is produced.
.TP
\fBDescription:\fR 
.PP
This option produces an assembly listing file with source code annotations. The assembly listing file shows the source code as interspersed comments.
.NL
.PP
To use this option, you must also specify option \-S, which causes an assembly listing to be generated.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-fstack\-protector\-all
.TP
.B
\-fno\-stack\-protector\-all
.RS
.TP
Enables or disables stack overflow security checks including functions.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-stack\-protector\-all
.NL
Stack overflow security checks, including functions, are disabled.
.TP
\fBDescription:\fR 
.PP
Enables or disables stack overflow security checks including functions.  These checks are enabled when you specify \-fstack\-protector\-all.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ftrapuv
.RS
.TP
Initializes stack local variables to an unusual value to aid error detection.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not initialize local variables.
.TP
\fBDescription:\fR 
.PP
This option initializes stack local variables to an unusual value to aid error detection. Normally, these local variables should be initialized in the application.  It also unmasks the floating\-point invalid exception.
.NL
.PP
The option sets any uninitialized local variables that are allocated on the stack to a value that is typically interpreted as a very large integer or an invalid address. References to these variables are then likely to cause run\-time errors that can help you detect coding errors.
.NL
.PP
This option sets option \-g (Linux* OS and OS X*) and /Zi or /Z7 (Windows* OS), which  changes
the default optimization level from O2 to \-O0 (Linux OS and OS X)
or /Od (Windows OS). You can override this effect by explicitly
specifying an O option setting.
.NL
.PP
This option sets option [Q]init snan.
.NL
.PP
If option O2 and option \-ftrapuv (Linux OS and OS X) or /Qtrapuv (Windows OS) are used together, you should specify
option \-fp\-speculation safe (Linux OS and OS X) or
/Qfp\-speculation:safe (Windows OS) to prevent exceptions resulting
from speculated floating\-point operations from being
trapped.
.NL
.PP
For more details on using options \-ftrapuv and /Qtrapuv
with compiler option O, see the article in Intel(R) Developer Zone
titled Don\[aq]t optimize when using \-ftrapuv for uninitialized
variable detection.
.NL
.PP
Another way to detect uninitialized local scalar variables is by specifying keyword uninit for option check.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ftz
.TP
.B
\-no\-ftz
.RS
.TP
Flushes denormal results to zero.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-ftz
.NL
Denormal results are flushed to zero.
.IP
Every optimization option O level, except O0, sets [Q]ftz.
.IP
Value 0 for the [Q]fpe option sets [Q]ftz.
.TP
\fBDescription:\fR 
.PP
This option flushes denormal results to zero when the application is in the gradual underflow mode. It may improve performance if the denormal values are not critical to your application\[aq]s behavior.
.NL
.PP
The [Q]ftz option has no effect during compile\-time optimization.
.NL
.PP
The [Q]ftz option sets or resets the FTZ and the DAZ hardware flags. If FTZ is ON, denormal results from floating\-point calculations will be set to the value zero. If FTZ is OFF, denormal results remain as is. If DAZ is ON, denormal values used as input to floating\-point instructions will be treated as zero. If DAZ is OFF, denormal instruction inputs remain as is.  Systems using Intel(R) 64 architecture have both FTZ and DAZ. FTZ and DAZ are not supported on all IA\-32 architectures. 
.NL
.PP
When the [Q]ftz option is used in combination with an SSE\-enabling option on systems using IA\-32 architecture (for example, the [Q]xSSE2 option), the compiler will insert code in the main routine to set FTZ and DAZ. When [Q]ftz is used without such an option, the compiler will insert code to conditionally set FTZ/DAZ based on a run\-time processor check.  The negative form of  option [Q]ftz will prevent the compiler from inserting any code that might set FTZ or DAZ. 
.NL
.PP
Option [Q]ftz only has an effect when the main program is being compiled. It sets the FTZ/DAZ mode for the process. The initial thread and any threads subsequently created by that process will operate in FTZ/DAZ mode.
.NL
.PP
If this option produces undesirable results of the numerical behavior of your program, you can turn the FTZ/DAZ mode off by using \-no\-ftz or /Qftz\- in the command line while still benefiting from the O3 optimizations.
.NL
.PP
.B NOTE:
Option [Q]ftz is a performance option. Setting this option does not guarantee that all denormals in a program are flushed to zero. The option only causes denormals generated at run time to be flushed to zero.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fverbose\-asm
.TP
.B
\-fno\-verbose\-asm
.RS
.TP
Produces an assembly listing with compiler comments, including options and version information.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-verbose\-asm
.NL
No source code annotations appear in the assembly listing file, if one is produced.
.TP
\fBDescription:\fR 
.PP
This option produces an assembly listing file with compiler comments, including options and version information.
.NL
.PP
To use this option, you must also specify \-S, which sets \-fverbose\-asm.
.NL
.PP
If you do not want this default when you specify \-S, specify \-fno\-verbose\-asm.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fvisibility=keyword
.TP
.B
\-fvisibility\-keyword=filename
.RS
.TP
Specifies the default visibility for global symbols or the visibility for symbols in a file. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies the visibility setting. Possible values are:
.RS
.TP 15
default
Sets visibility to default.
.TP 15
extern
Sets visibility to extern.
.TP 15
hidden
Sets visibility to hidden.
.TP 15
internal
Sets visibility to internal.
.TP 15
protected
Sets visibility to protected. This value is not available on OS X* systems.
.RE
.TP 18
\fIfilename\fR
.NL
Is the pathname of a file containing the list of symbols whose visibility you want to set. The symbols must be separated by whitespace (spaces, tabs, or newlines).
.TP
\fBDefault:\fR 
.TP 18
\-fvisibility=default
.NL
The compiler sets visibility of symbols to default.
.TP
\fBDescription:\fR 
.PP
This option specifies the default visibility for global symbols (syntax \-fvisibility=\fIkeyword\fR) or the visibility for symbols in a file (syntax \-fvisibility\-\fIkeyword=filename\fR). 
.NL
.PP
Visibility specified by \-fvisibility\-\fIkeyword=filename\fR overrides visibility specified by \-fvisibility=\fIkeyword\fR for symbols specified in a file.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
\-fvisibility=default \-fvisibility\-default\fI=filename\fR
.NL
Sets visibility of symbols to default. This means other components can reference the symbol, and the symbol definition can be overridden (preempted) by a definition of the same name in another component.
.NL
.TP 18
\-fvisibility=extern \-fvisibility\-extern\fI=filename\fR
.NL
Sets visibility of symbols to extern. This means the symbol is treated as though it is defined in another component. It also means that the symbol can be overridden by a definition of the same name in another component.
.NL
.TP 18
\-fvisibility=hidden \-fvisibility\-hidden\fI=filename\fR
.NL
Sets visibility of symbols to hidden. This means that other components cannot directly reference the symbol. However, its address may be passed to other components indirectly.
.NL
.TP 18
\-fvisibility=internal \-fvisibility\-internal\fI=filename\fR
.NL
Sets visibility of symbols to internal.  This means that the symbol cannot be referenced outside its defining component, either directly or indirectly. The affected functions can never be called from another module, including through function pointers.
.NL
.TP 18
\-fvisibility=protected \-fvisibility\-protected\fI=filename\fR
.NL
Sets visibility of symbols to protected. This means other
components can reference the symbol, but it cannot be overridden by
a definition of the same name in another component.
This value is not available on OS X* systems.
.NL
.PP
If an \-fvisibility option is specified more than once on the command line, the last specification takes precedence over any others.
.NL
.PP
If a symbol appears in more than one visibility \fIfilename\fR, the setting with the least visibility takes precedence.
.NL
.PP
The following shows the precedence of the visibility settings (from greatest to least visibility):
.NL
.IP \(bu 2
extern
.IP \(bu 2
default
.IP \(bu 2
protected
.IP \(bu 2
hidden
.IP \(bu 2
internal
.PP
Note that extern visibility only applies to functions. If a variable symbol is specified as extern, it is assumed to be default.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fzero\-initialized\-in\-bss
.TP
.B
\-fno\-zero\-initialized\-in\-bss
.RS
.TP
Determines whether the compiler places in the DATA section any variables explicitly initialized with zeros.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-zero\-initialized\-in\-bss 
.NL
Variables explicitly initialized with zeros are placed in the BSS section. This can save space in the resulting code.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler
places in the DATA section any variables explicitly initialized
with zeros.
.NL
.PP
If option \-fno\-zero\-initialized\-in\-bss (Linux* OS and OS X*) or /Qzero\-initialized\-in\-bss\- (Windows* OS) is specified, the
compiler places in the DATA section any variables that are
initialized to zero.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-g
.RS
.TP
Tells the compiler to generate full debugging information in the object file or a project database (PDB) file. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No debugging information is produced in the object file or in a PDB file.
.TP
\fBDescription:\fR 
.PP
Options \-g (Linux* OS and OS X*)
and /Z7 (Windows* OS) tell the compiler to generate symbolic debugging information in the object file, which increases the size of the object file. The /Zi option (Windows OS) tells the compiler to generate symbolic debugging information in a PDB file. 
.NL
.PP
Two PDB files are created, one by the compiler, and one by the linker:
.NL
.IP \(bu 2
vc\fIx\fR0.pdb, where \fIx\fR represents the version of Visual C++, for example vc100.pdb. 
This file stores all debugging information for the individual OBJ files and resides in the same directory as the project makefile. If you want to change this name, use option /Fd.
.IP \(bu 2
\fIexecutablename\fR.pdb   
This file stores all debug information for the .exe file and resides in the debug subdirectory.
.PP
Each time it creates a .obj file, the compiler merges debug information into vc\fIx\fR0.pdb. 
.NL
.PP
The linker creates \fIexecutablename\fR.pdb, which contains debug information for the project\[aq]s .exe file. The \fIexecutablename\fR.pdb file contains full debug information, including function prototypes, not just the type information found in vc\fIx\fR0.pdb. Both PDB files allow incremental updates. The linker also embeds the path to the .pdb file in the .exe or .dll file that it creates.
.NL
.PP
The compiler does not support the generation of debugging information in assemblable files. If you specify these options, the resulting object file will contain debugging information, but the assemblable file will not.
.NL
.PP
These options turn off O2 and make O0 (Linux OS and OS X) or Od (Windows OS) the default unless O2 (or higher) is explicitly specified in the same command line.
.NL
.PP
On Linux* OS and OS X*, specifying the \-g or \-O0 option sets the \-fno\-omit\-frame\-pointer option. On Linux* OS, the \-debug inline\-debug\-info option will be enabled by default if you compile with optimizations (option \-O2 or higher) and debugging is enabled (option \-g).
.NL
.PP
.B NOTE:
When option \-g is specified, debugging information is generated in the DWARF Version 3 format. Older versions of some analysis tools may require applications to be built with the \-gdwarf\-2 option to ensure 
correct operation.
.TP
\fBAlternate Options:\fR 
.TP 18
/Zi
.NL
Linux and OS X: None
.RE
.TP
.B
\-gcc\-name=name (L*X only)
.RS
.TP
Specifies the name of the gcc compiler that should be used to set up the environment for C compilations.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIname\fR
.NL
Is the name of the gcc compiler to use.  It can include the path where the gcc compiler is located.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses the PATH setting to find the gcc compiler and resolve environment settings.
.TP
\fBDescription:\fR 
.PP
This option specifies the name of the gcc compiler that should be used to set up the environment for C compilations.  If you do not specify a path, the compiler will search the PATH settings for the compiler name you provide.
.NL
.PP
This option is helpful when you are referencing a non\-standard gcc installation.
.NL
.PP
The C++ equivalent to option \-gcc\-name is \-gxx\-name.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-gdwarf\-n
.RS
.TP
Lets you specify a DWARF Version format when generating debug information.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a value denoting the DWARF Version format to use. Possible values are:
.RS
.TP 15
2
Generates debug information using the DWARF Version 2 format.
.TP 15
3
Generates debug information using the DWARF Version 3 format.
.TP 15
4
Generates debug information using the DWARF Version 4 format. This setting is only available on Linux* OS.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No debug information is generated. However, if compiler option \-g is specified, debugging information is generated in the DWARF Version 3 format.
.TP
\fBDescription:\fR 
.PP
This option lets you specify a DWARF Version format when generating debug information. 
.NL
.PP
Note that older versions of some analysis tools may require applications to be built with the \-gdwarf\-2 option to ensure correct operation.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-gen\-dep[=filename]
.TP
.B
\-no\-gen\-dep
.RS
.TP
Tells the compiler to generate build dependencies for the current compilation.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file for output. It can include a path.
.IP
If you specify \fIfilename\fR, it is similar
to specifying option [Q]MF\fIfilename\fR.
If you do not specify \fIfilename\fR, it is
similar to specifying option [Q]MD or [Q]MMD.
.TP
\fBDefault:\fR 
.TP 18
\-no\-gen\-dep or /gen\-dep\-
.NL
The compiler does not generate build dependencies for the compilation.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate build dependencies for the current compilation. The build dependencies include a list of all files included with INCLUDE statements or .mod files accessed with USE statements.
.NL
.PP
If you do not specify \fIfilename\fR, the dependencies are written to stdout.
.NL
.PP
You can use option gen\-depformat to specify the form of the output for the build dependencies generated. 
.NL
.PP
If you specify option gen\-dep and you do not specify option gen\-depformat, the output format is in a form acceptable to the make utility.
.NL
.PP
Note that if option fpp is used to process #include files, those files will also appear in the list of build dependencies.
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
gen\-dep with a \fIfilename\fR
.NL
Linux and OS X: \-MF
.TP 18
gen\-dep with no \fIfilename\fR
.NL
Linux and OS X: \-MD or \-MMD
.RE
.TP
.B
\-gen\-depformat=form
.RS
.TP
Specifies the form for the output generated when option gen\-dep is specified.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIform\fR
.NL
Is the output form for the list of build dependencies. Possible values are make or nmake.
.TP
\fBDefault:\fR 
.TP 18
make
.NL
The output form for the list of build dependencies is in a form acceptable to the make utility.
.TP
\fBDescription:\fR 
.PP
This option specifies the form for the output
generated when option gen\-dep is specified.
.NL
.PP
If you specify option gen\-depformat and do not
specify option gen\-dep, the option is ignored.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-gen\-interfaces [[no]source]
.TP
.B
\-nogen\-interfaces
.RS
.TP
Tells the compiler to generate an interface block for each routine in a source file.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
nogen\-interfaces
.NL
The compiler does not generate interface blocks for routines in a source file.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate an interface block for each routine (that is, for each SUBROUTINE and FUNCTION statement) defined in the source file. The compiler generates two files for each routine, a .mod file and a .f90 file, and places them in the current directory or in the directory specified by the include (\-I) or \-module option. The .f90 file is the text of the interface block; the .mod file is the interface block compiled into binary form.
.NL
.PP
If source is specified, the compiler creates the \fIprocedure\-name\fR__GENmod.f90 as well as the \fIprocedure\-name\fR__GENmod.mod files. If nosource is specified, the compiler creates the \fIprocedure\-name\fR__GENmod.mod but not the \fIprocedure\-name\fR__GENmod.f90 files. If neither is specified, it is the same as specifying setting source for the gen\-interfaces option.
.NL
.PP
On Windows* OS, for a Debug configuration in a Visual Studio project, the default is /warn:interfaces.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-global\-hoist
.TP
.B
\-no\-global\-hoist
.RS
.TP
Enables certain optimizations that can move memory loads to a point earlier in the program execution than where they appear in the source.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-global\-hoist 
.NL
Certain optimizations are enabled that can move memory loads.
.TP
\fBDescription:\fR 
.PP
This option enables certain optimizations that can move memory loads to a point earlier in the program execution than where they appear in the source. In most cases, these optimizations are safe and can improve performance. 
.NL
.PP
The negative form of the option is useful for some applications, such as those that use shared or dynamically mapped memory, which can fail if a load is moved too early in the execution stream (for example, before the memory is mapped).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-grecord\-gcc\-switches (L*X only)
.RS
.TP
Causes the command line options that were used to invoke the compiler to be appended to the DW_AT_producer attribute in DWARF debugging information.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The command line options that were used to
invoke the compiler are not appended to the DW_AT_producer
attribute in DWARF debugging information.
.TP
\fBDescription:\fR 
.PP
This option causes the command line options
that were used to invoke the compiler to be appended to the DW_AT_producer attribute in DWARF
debugging information.
.NL
.PP
The options
are concatenated with whitespace separating them from each other and
from the compiler version.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide[=n]
.RS
.TP
Lets you set a level of guidance for auto\-vectorization, auto parallelism, and data transformation.  
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an optional value specifying the level of guidance to be provided.
.IP
The values available are 1 through 4. Value 1 indicates a standard level of guidance. Value 4
indicates the most advanced level of guidance. If \fIn\fR is omitted, the default is 4.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
You do not receive guidance about how to improve optimizations for parallelism, vectorization, and data transformation.
.TP
\fBDescription:\fR 
.PP
This option lets you set a level of guidance (advice) for auto\-vectorization, auto parallelism, and data transformation. It causes the compiler to generate messages suggesting ways to improve these optimizations. 
.NL
.PP
When this option is specified, the compiler does not produce any objects or executables. 
.NL
.PP
You must also specify the [Q]parallel option to receive auto parallelism guidance.
.NL
.PP
You can set levels of guidance for the individual guide optimizations by specifying one of the following options:
.NL
.TP 18
data transformation
.NL
[Q]guide\-data\-trans
.TP 18
auto parallelism
.NL
[Q]guide\-par
.TP 18
auto\-vectorization
.NL
[Q]guide\-vec
.PP
If you specify the [Q]guide option and also specify one of the options setting a level of guidance for an individual guide optimization, the value set for the individual guide optimization will override the setting specified in [Q]guide.
.NL
.PP
If you do not specify [Q]guide, but specify one of the options setting a level of guidance for an individual guide optimization, option [Q]guide
is enabled with the greatest value passed among any of the three individual guide optimizations specified.
.NL
.PP
In debug mode, this option has no effect unless option O2 (or higher) is explicitly specified in the same command line.
.NL
.PP
.B NOTE:
The compiler speculatively performs optimizations as part of guide
analysis. As a result, when you use guided auto\-parallelism options with
the [Q]vec\-report or [Q]par\-report options, the compiler generates "LOOP WAS VECTORIZED" or
similar messages as if the compilation was performed with the
recommended changes. 
.PP
You should use extra caution when interpreting output from 
the [Q]vec\-report or [Q]par\-report options when the compilation is performed
with the [Q]guide option.
.PP
.B NOTE:
You can specify [Q]diag\-disable to prevent the compiler from issuing one or more diagnostic messages.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-data\-trans[=n]
.RS
.TP
Lets you set a level of guidance for data transformation.  
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an optional value specifying the level of guidance to be provided.
.IP
The values available are 1 through 4. Value 1 indicates a standard level of guidance. Value 4 indicates the most advanced level of guidance. If \fIn\fR is omitted, the default is 4.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
You do not receive guidance about how to improve optimizations for data transformation.
.TP
\fBDescription:\fR 
.PP
This option lets you set a level of guidance for data transformation. It causes the compiler to generate messages suggesting ways to improve that optimization.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-file[=filename]
.RS
.TP
Causes the results of guided auto parallelism to be output to a file.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file for output. It can include a path.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Messages that are generated by guided auto parallelism are
output to stderr.
.TP
\fBDescription:\fR 
.PP
This option causes the results of guided
auto parallelism to be output to a file.
.NL
.PP
This option is ignored unless you also specify
one or more of the following options: 
.NL
.IP \(bu 2
[Q]guide
.IP \(bu 2
[Q]guide\-vec
.IP \(bu 2
[Q]guide\-data\-trans
.IP \(bu 2
[Q]guide\-par
.PP
If you do not specify a path, the file is
placed in the current working directory.
.NL
.PP
If there is already a file named \fIfilename\fR, it
will be overwritten.
.NL
.PP
You can include a file extension in \fIfilename\fR.
For example, if \fIfile.txt\fR is specified, the name of the output file
is \fIfile.txt\fR. If you do not provide a file extension, the name of
the file is \fIfilename.guide\fR.
.NL
.PP
If you do not specify \fIfilename\fR, the name of the
file is \fIname\-of\-the\-first\-source\-file.guide\fR. This is also the name
of the file if the name specified for \fIfilename\fR conflicts with a
source file name provided in the command line.
.NL
.PP
.B NOTE:
If you specify the [Q]guide\-file option and you also specify option [Q]guide\-file\-append, the last option specified on the command line takes precedence.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-file\-append[=filename]
.RS
.TP
Causes the results of guided auto parallelism to be appended to a file.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file to be appended to. It can include a path.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Messages that are generated by guided auto parallelism are
output to stderr.
.TP
\fBDescription:\fR 
.PP
This option causes the results of guided auto parallelism to be appended to a file.
.NL
.PP
This option is ignored unless you also specify
one or more of the following options: 
.NL
.IP \(bu 2
[Q]guide
.IP \(bu 2
[Q]guide\-vec
.IP \(bu 2
[Q]guide\-data\-trans
.IP \(bu 2
[Q]guide\-par
.PP
If you do not specify a path, the compiler
looks for \fIfilename\fR in the current working directory.
.NL
.PP
If \fIfilename\fR is not found, then a new file with
that name is created in the current working directory.
.NL
.PP
If you do not specify a file extension, the
name of the file is \fIfilename.guide\fR.
.NL
.PP
If the name specified for \fIfilename\fR conflicts
with a source file name provided in the command line, the name of
the file is \fIname\-of\-the\-first\-source\-file.guide\fR.
.NL
.PP
.B NOTE:
If you specify the [Q]guide\-file\-append
option
and you also specify option  [Q]guide\-file, the last option specified on the command line takes precedence.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
guide\-opts=string
.RS
.TP
Tells the compiler to analyze certain code and generate recommendations that may improve optimizations.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIstring\fR
.NL
Is the text denoting the code to analyze. The string must appear
within quotes. It can take one or more of the following forms:
\fIfilename\fR\fIfilename\fR, \fIroutine\fR\fIfilename\fR, \fIrange\fR [, \fIrange\fR]...
\fIfilename\fR, \fIroutine\fR, \fIrange\fR
[, \fIrange\fR]...
.IP
If you specify more than one of the above forms in a string, a semicolon must appear between each form. If you specify more than one \fIrange\fR
in a string, a comma must appear between each \fIrange\fR. Optional blanks can follow each parameter in the forms above and they can also follow each form in a string.
.RS
.TP 15
\fIfilename\fR
Specifies the name of a file to be analyzed. It
can include a path.
.IP
If you do not specify a path, the compiler
looks for filename in the current working directory.
.TP 15
\fIroutine\fR
Specifies the name of a routine to be analyzed.
You can include an identifying argument. 
.IP
The name, including any argument, must be enclosed in single quotes.
.IP
The compiler tries to uniquely identify the routine that corresponds to the specified routine name. It may select multiple routines to analyze, especially if the following is true:
.RS
.IP \(bu 2
More than one routine has the specified routine name, so the routine cannot be uniquely identified.
.IP \(bu 2
No argument
information has been specified to narrow the number of routines selected as matches.
.RE
.TP 15
\fIrange\fR
Specifies a range of line numbers to analyze in
the file or routine specified. The \fIrange\fR must be specified in
integers in the form:
.IP
\fIfirst_line_number\-last_line_number\fR
.IP
The hyphen between the line numbers is
required.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
You do not receive guidance on how to improve optimizations.
However, if you specify the [Q]guide option, the compiler
analyzes and generates recommendations for all the code in an
application
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to analyze
certain code and generate recommendations that may
improve optimizations.
.NL
.PP
This option is ignored unless you also specify
one or more of the following options: 
.NL
.IP \(bu 2
[Q]guide
.IP \(bu 2
[Q]guide\-vec
.IP \(bu 2
[Q]guide\-data\-trans
.IP \(bu 2
[Q]guide\-par
.PP
When the [Q]guide\-opt option is
specified, a message is output that
includes which parts of the input files are being analyzed. If a routine is selected to be analyzed, the
complete routine name will appear in the generated
message.
.NL
.PP
When inlining is involved, you should specify
callee line numbers. Generated messages also use callee line
numbers.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-par[=n]
.RS
.TP
Lets you set a level of guidance for auto parallelism.  
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an optional value specifying the level of guidance to be provided.
.IP
The values available are 1 through 4. Value 1 indicates a standard level of guidance. Value 4 indicates the most advanced level of guidance. If \fIn\fR is omitted, the default is 4.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
You do not receive guidance about how to improve optimizations for parallelism.
.TP
\fBDescription:\fR 
.PP
This option lets you set a level of guidance
for auto parallelism. It causes the compiler to generate
messages suggesting ways to improve that optimization.
.NL
.PP
You must also specify the [Q]parallel option to receive auto parallelism
guidance.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-profile=filename|dir [, [filename|dir]...]
.RS
.TP
Specifies a loop profiler data file (or a set of files) when used with option \-guide or /Qguide.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is an .xml file created from a loop profiler run.
.TP 18
\fIdir\fR
.NL
Is a directory that contains one or more .xml files from a loop profiler run.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
When the [Q]guide option is specified, the guide region is the whole file or the region specified by option [Q]guide\-opts.
.TP
\fBDescription:\fR 
.PP
This option specifies a loop profiler data file
(or a set of files) when used with the [Q]guide option.
.NL
.PP
This option has no effect unless the [Q]guide option has been specified. Option [Q]guide\-profile
helps you take advantage of the [Q]guide option to more efficiently optimize
your applications for
auto parallelism and/or vectorization.
.NL
.PP
The loop profile data file can be collected by
using one of the following options:
.NL
.IP \(bu 2
[Q]profile\-loops
.IP \(bu 2
[Q]profile\-functions
.PP
When the data is from [Q]profile\-loops, the setting of the guide regions will be based
upon the hottest loops.
.NL
.PP
When the data is from [Q]profile\-functions, the guide region will be the entire function
containing the hottest functions.
.NL
.PP
If you specify options [Q]guide\-opts and
[Q]guide\-profile, the compiler issues an error
message.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-vec[=n]
.RS
.TP
Lets you set a level of guidance for auto\-vectorization.  
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an optional value specifying the level of guidance to be provided.
.IP
The values available are 1 through 4. Value 1 indicates a standard level of guidance. Value 4 indicates the most advanced level of guidance. If \fIn\fR is omitted, the default is 4.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
You do not receive guidance about how to improve optimizations for vectorization.
.TP
\fBDescription:\fR 
.PP
This option lets you set a level of guidance
for auto\-vectorization. It causes the compiler to generate
messages suggesting ways to improve that optimization.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-gxx\-name=name (L*X only)
.RS
.TP
Specifies the name of the g++ compiler that should be used to set up the environment for C++ compilations.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIname\fR
.NL
Is the name of the g++ compiler to use.  It can include the path where the g++ compiler is located.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses the PATH setting to find the g++ compiler and resolve environment settings.
.TP
\fBDescription:\fR 
.PP
This option specifies the name of the g++ compiler that should be used to set up the environment for C++ compilations.  If you do not specify a path, the compiler will search the PATH settings for the compiler name you provide.
.NL
.PP
The C equivalent to option \-gxx\-name is \-gcc\-name.
.NL
.PP
.B NOTE:
When compiling a C++ file with icc, g++ is used to get the environment.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-heap\-arrays [size]
.TP
.B
\-no\-heap\-arrays
.RS
.TP
Puts automatic arrays and arrays created for temporary computations on the heap instead of the stack.
.NL
.TP
\fBArguments:\fR 
.TP 18
size
.NL
Is an integer value representing the size of the arrays in kilobytes. Arrays smaller than \fIsize\fR are put on the stack.
.TP
\fBDefault:\fR 
.TP 18
\-no\-heap\-arrays
.NL
The compiler puts automatic arrays and temporary arrays in the stack storage area.
.TP
\fBDescription:\fR 
.PP
This option puts automatic arrays and arrays created for temporary computations on the heap instead of the stack.
.NL
.PP
When this option is specified, automatic (temporary) arrays that have a compile\-time size greater than the value specified for \fIsize\fR are put on the heap, rather than on the stack. If the compiler cannot determine the size at compile time, it always puts the automatic array on the heap.
.NL
.PP
If \fIsize\fR is specified, the value is only
used when the total size of the temporary array or automatic array
can be determined at compile time, using compile\-time constants.
Any arrays known at compile\-time to be larger than \fIsize\fR are
allocated on the heap instead of the stack. For example, if 10 is
specified for \fIsize\fR:
.NL
.IP \(bu 2
All automatic and temporary arrays equal to or larger than 10 KB are put on the heap.
.IP \(bu 2
All automatic and temporary arrays smaller than 10 KB are put on the stack.
.PP
If \fIsize\fR is omitted, and the size of the temporary array or automatic array cannot be determined at compile time, it is assumed that the total size is greater than \fIsize\fR and the array is allocated on the heap.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-help[category]
.RS
.TP
Displays all available compiler options or a category of compiler options.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIcategory\fR
.NL
Is a category or class of options to display. Possible values are:
.RS
.TP 15
advanced
Displays advanced optimization options that allow fine tuning of compilation or allow control over advanced features of the compiler.
.TP 15
codegen
Displays Code Generation options.
.TP 15
compatibility
Displays options affecting language compatibility.
.TP 15
component
Displays options for component control.
.TP 15
data
Displays options related to interpretation of data in programs or the storage of data.
.TP 15
deprecated
Displays options that have been deprecated.
.TP 15
diagnostics
Displays options that affect diagnostic messages displayed by the compiler.
.TP 15
float
Displays options that affect floating\-point operations.
.TP 15
help
Displays all the available help categories.
.TP 15
inline
Displays options that affect inlining.
.TP 15
ipo
Displays Interprocedural Optimization (IPO) options
.TP 15
language
Displays options affecting the behavior of the compiler language features.
.TP 15
link
Displays linking or linker options.
.TP 15
misc
Displays miscellaneous options that do not fit within other categories.
.TP 15
openmp
Displays OpenMP and parallel processing options.
.TP 15
opt
Displays options that help you optimize code.
.TP 15
output
Displays options that provide control over compiler output.
.TP 15
pgo
Displays Profile Guided Optimization (PGO) options.
.TP 15
preproc
Displays options that affect preprocessing operations.
.TP 15
reports
Displays options for optimization reports.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No list is displayed unless this compiler option is specified.
.TP
\fBDescription:\fR 
.PP
This option displays all available compiler options or a category of compiler options. If category is not specified, all available compiler options are displayed. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-Idir
.RS
.TP
Specifies an additional directory for the include path.
.NL
.TP
\fBArguments:\fR 
.TP 18
dir
.NL
Is the directory to add to the include path.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The default include path is used.
.TP
\fBDescription:\fR 
.PP
This option specifies an additional directory for the include path, which is searched for module files referenced in USE statements and include files referenced in INCLUDE statements. To specify multiple directories on the command line, repeat the option for each directory you want to add.
.NL
.PP
For all USE statements and for those INCLUDE statements whose file name does not begin with a device or directory name, the directories are searched in this order:
.NL
.IP 1) 4n 
.IP
The directory containing the first source file.
.IP
Note that if assume nosource_include is specified, this directory will not be searched.
.IP 2) 4n 
.IP
The current working directory where the compilation is taking place (if different from the above directory).
.IP 3) 4n 
.IP
Any directory or directories specified using the I option. If multiple directories are specified, they are searched in the order specified on the command line, from left to right.
.IP 4) 4n 
.IP
On Linux* and OS X* systems, any directories indicated using environment variable CPATH. On Windows* systems, any directories indicated using environment variable INCLUDE.
.PP
This option affects fpp preprocessor behavior and the USE statement.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-idirafterdir
.RS
.TP
Adds a directory to the second include file search path.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the name of the directory to add.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Include file search paths include certain default directories.
.TP
\fBDescription:\fR 
.PP
This option adds a directory to the second include file search path (after \-I).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.RS
.TP
Tells the compiler to link to the IMSL* Fortran Numerical Library*(IMSL* library).
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not link to the IMSL* library.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to link to the IMSL* Fortran Numerical Library* (IMSL* library). This option is applicable for users of editions of the Intel(R) Fortran Compiler product that include the IMSL* libraries.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-init=keyword
.RS
.TP
Lets you initialize a class of saved variables to zero or to signaling NaN.
.NL
.TP
\fBArchitecture Restrictions:\fR [Q]init keyword snan: Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies a class of saved variables. Possible values are:
.RS
.TP 15
[no]arrays
Determines whether the compiler initializes variables that are saved arrays or saved scalars. Specifying arrays initializes saved arrays. You must also specify either [Q]init snan or [Q]init zero to initialize saved arrays.
.TP 15
[no]snan
Determines whether the compiler initializes to signaling NaN all saved variables of intrinsic type REAL or COMPLEX that are not already initialized. 
.TP 15
[no]zero
Determines whether the compiler initializes to zero all saved variables of intrinsic type INTEGER, REAL, COMPLEX, or LOGICAL that are not already initialized.  Option /Qinit:[no]zero replaces option /Qzero[\-] (Windows*) , and option \-init=[no]zero replaces option \-[no]zero (Linux* and OS X*).
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No initializations are performed by default if you do not specify any of these
options.
.TP
\fBDescription:\fR 
.PP
This option lets you initialize a class of saved variables to zero or to signaling NaN. 
.NL
.PP
If you only specify option \-init=zero or \-init=snan (Linux* OS and OS X*) or /Qinit:zero or /Qinit:snan (Windows* OS), it affects only saved scalar variables. To apply the initialization to saved arrays as well, you must also specify option \-init=arrays (Linux* OS and OS X*) or Qinit:arrays (Windows* OS).
.NL
.PP
On Intel(R) 64 architecture targeting Intel(R) MIC Architecture, you cannot specify [Q]init [no]snan. Trapping signaling snan is not available on Intel(R) MIC Architecture.
.NL
.PP
If you specify [Q]init snan, the floating\-point exception handling flags will be set to trap signaling NaN and halt so that when such a value is trapped at run\-time, the Fortran library can catch the usage, display an error message about a possible uninitialized variable, display a traceback, and stop execution. You can use the debugger to determine where in your code this uninitialized variable is being referenced when execution stops. 
.NL
.PP
The following are general restrictions for this option:
.NL
.IP \(bu 2
[Q]init snan only affects certain variables of REAL or COMPLEX type that are SAVEd.
.IP \(bu 2
You cannot initialize variables in equivalence groups to signaling NaN values;  they can only be initialized to zero.
.PP
If you specify [Q]init snan or [Q]init zero, the following restrictions apply:
.NL
.IP \(bu 2
Derived types and arrays of derived types will not be initialized.
.IP \(bu 2
Allocatable variables will not be initialized.
.IP \(bu 2
Automatic variables will not be initialized.
.IP \(bu 2
Adjustable arrays will not be initialized.
.PP
If you specify both [Q]init snan and [Q]init zero, then certain saved variables of REAL and COMPLEX type are initialized to signaling NaN and certain saved variables of INTEGER and LOGICAL type are initialized to zero. 
.NL
.PP
Setting the option [Q]init snan implicitly sets the option fpe 0. A compile time warning will occur if you specify both option fpe 3 and option [Q]init snan on the command line.  In this case, fpe 3 is ignored.
.NL
.PP
Use option [Q]save on the command line to ensure all variables are specifically marked as SAVE.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-factor=n
.TP
.B
\-no\-inline\-factor
.RS
.TP
Specifies the percentage multiplier that should be applied to all inlining options that define upper limits.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer specifying the percentage value. The default value is 100 (a factor of 1).
.TP
\fBDefault:\fR 
.TP 18
\-inline\-factor=100 
.NL
The compiler uses a percentage multiplier of 100.
.TP
\fBDescription:\fR 
.PP
This option specifies the percentage multiplier that should be applied to all inlining options that define upper limits:
.NL
.IP \(bu 2
[Q]inline\-max\-size
.IP \(bu 2
[Q]inline\-max\-total\-size
.IP \(bu 2
[Q]inline\-max\-per\-routine
.IP \(bu 2
[Q]inline\-max\-per\-compile
.PP
The  [Q]inline\-factor option takes the default value for each of the above options and multiplies it by \fIn\fR divided by 100. For example, if 200 is specified, all inlining options that define upper limits are multiplied by a factor of 2. This option is useful if you do not want to individually increase each option limit.
.NL
.PP
If you specify \-no\-inline\-factor (Linux* OS and OS X*) or /Qinline\-factor\- (Windows* OS), the following occurs:
.NL
.IP \(bu 2
Every function is considered to be a small or medium function; there are no large functions.
.IP \(bu 2
There is no limit to the size a routine may grow when inline expansion is performed.
.IP \(bu 2
There is no limit to the number of times some routine may be inlined into a particular routine.
.IP \(bu 2
There is no limit to the number of times inlining can be applied to a compilation unit.
.PP
To see compiler values for important inlining limits, specify the \-qopt\-report (Linux* OS and OS X*) or  /Qopt\-report (Windows) option.
.NL
.PP
.B CAUTION:
When you use this option to increase default limits, the compiler may do so much additional inlining that it runs out of memory and terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-forceinline
.RS
.TP
Instructs the compiler to force inlining of functions suggested for inlining whenever the compiler is capable doing so.
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses default heuristics for inline routine expansion.
.TP
\fBDescription:\fR 
.PP
This option instructs the compiler to force inlining of functions suggested for inlining whenever the compiler is capable doing so. 
.NL
.PP
Without this option, the compiler treats functions declared with an INLINE attribute as merely being recommended for inlining. When this option is used, it is as if they were declared with the directive !DIR$ ATTRIBUTES FORCEINLINE.
.NL
.PP
To see compiler values for important inlining limits, specify the \-qopt\-report (Linux* OS and OS X*) or  /Qopt\-report (Windows) option.
.NL
.PP
.B CAUTION:
When you use this option to change the meaning of inline to "forceinline", the compiler may do so much additional inlining that it runs out of memory and terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-level=n
.RS
.TP
Specifies the level of inline function expansion.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the inline function expansion level. Possible values are 0, 1, and 2.
.TP
\fBDefault:\fR 
.TP 18
\-inline\-level=2
.NL
This is the default if option O2 is specified or is in effect by default. On Windows* systems, this is also the default if option O3 is specified.
.TP 18
\-inline\-level=0
.NL
This is the default if option \-O0 (Linux* OS and OS X*) is specified.
.TP
\fBDescription:\fR 
.PP
This option specifies the level of inline function expansion. Inlining procedures can greatly improve the run\-time performance of certain programs.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
\-inline\-level=0 or /Ob0
.NL
Disables inlining of user\-defined functions. Note that statement functions are always inlined.
.NL
.TP 18
\-inline\-level=1  or /Ob1
.NL
Enables inlining when an inline keyword or an inline directive is specified.
.NL
.TP 18
\-inline\-level=2  or /Ob2
.NL
Enables inlining of any function at the compiler\[aq]s discretion.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-max\-per\-compile=n
.TP
.B
\-no\-inline\-max\-per\-compile
.RS
.TP
Specifies the maximum number of times inlining may be applied to an entire compilation unit.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer that specifies the number of times inlining may be applied.
.TP
\fBDefault:\fR 
.TP 18
\-no\-inline\-max\-per\-compile 
.NL
The compiler uses default heuristics for inline routine expansion.
.TP
\fBDescription:\fR 
.PP
This option the maximum number of times inlining may be applied to an entire compilation unit. It limits the number of times that inlining can be applied.
.NL
.PP
For compilations using Interprocedural Optimizations (IPO), the entire compilation is a compilation unit. For other compilations, a compilation unit is a file.
.NL
.PP
If you specify \-no\-inline\-max\-per\-compile (Linux* OS and OS X*) or /Qinline\-max\-per\-compile\- (Windows* OS), there is no limit to the number of times inlining may be applied to a compilation unit.
.NL
.PP
To see compiler values for important inlining limits, specify the \-qopt\-report (Linux* OS and OS X*) or  /Qopt\-report (Windows) option.
.NL
.PP
.B CAUTION:
When you use this option to increase the default limit, the compiler may do so much additional inlining that it runs out of memory and terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-max\-per\-routine=n
.TP
.B
\-no\-inline\-max\-per\-routine
.RS
.TP
Specifies the maximum number of times the inliner may inline into a particular routine.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer that specifies the maximum number of times the inliner may inline into a particular routine.
.TP
\fBDefault:\fR 
.TP 18
\-no\-inline\-max\-per\-routine 
.NL
The compiler uses default heuristics for inline routine expansion.
.TP
\fBDescription:\fR 
.PP
This option specifies the maximum number of times the inliner may inline into a particular routine. It limits the number of times that inlining can be applied to any routine.
.NL
.PP
If you specify \-no\-inline\-max\-per\-routine (Linux* OS and OS X*) or /Qinline\-max\-per\-routine\- (Windows* OS), there is no limit to the number of times some routine may be inlined into a particular routine.
.NL
.PP
To see compiler values for important inlining limits, specify the \-qopt\-report (Linux* OS and OS X*) or  /Qopt\-report (Windows) option.
.NL
.PP
.B CAUTION:
When you use this option to increase the default limit, the compiler may do so much additional inlining that it runs out of memory and terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-max\-size=n
.TP
.B
\-no\-inline\-max\-size
.RS
.TP
Specifies the lower limit for the size of what the inliner considers to be a large routine.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer that specifies the minimum size of what the inliner considers to be a large routine.
.TP
\fBDefault:\fR 
.TP 18
\-inline\-max\-size 
.NL
The compiler sets the maximum size (\fIn\fR) dynamically, based on the platform.
.TP
\fBDescription:\fR 
.PP
This option specifies the lower limit for the size of what the inliner considers to be a large routine (a function or subroutine). The inliner classifies routines as small, medium, or large. This option specifies the boundary between what the inliner considers to be medium and large\-size routines.
.NL
.PP
The inliner prefers to inline small routines. It has a preference against inlining large routines. So, any large routine is highly unlikely to be inlined.
.NL
.PP
If you specify \-no\-inline\-max\-size (Linux* OS and OS X*) or /Qinline\-max\-size\- (Windows* OS), there are no large routines. Every routine is either a small or medium routine.
.NL
.PP
To see compiler values for important inlining limits, specify the \-qopt\-report (Linux* OS and OS X*) or  /Qopt\-report (Windows) option.
.NL
.PP
.B CAUTION:
When you use this option to increase the default limit, the compiler may do so much additional inlining that it runs out of memory and terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-max\-total\-size=n
.TP
.B
\-no\-inline\-max\-total\-size
.RS
.TP
Specifies how much larger a routine can normally grow when inline expansion is performed.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer that specifies the permitted increase in the routine\[aq]s size when inline expansion is performed.
.TP
\fBDefault:\fR 
.TP 18
\-no\-inline\-max\-total\-size 
.NL
The compiler uses default heuristics for inline routine expansion.
.TP
\fBDescription:\fR 
.PP
This option specifies how much larger a routine can normally grow when inline expansion is performed. It limits the potential size of the routine. For example, if 2000 is specified for \fIn\fR, the size of any routine will normally not increase by more than 2000.
.NL
.PP
If you specify \-no\-inline\-max\-total\-size (Linux* OS and OS X*) or /Qinline\-max\-total\-size\- (Windows* OS), there is no limit to the size a routine may grow when inline expansion is performed.
.NL
.PP
To see compiler values for important inlining limits, specify the \-qopt\-report (Linux* OS and OS X*) or  /Qopt\-report (Windows) option.
.NL
.PP
.B CAUTION:
When you use this option to increase the default limit, the compiler may do so much additional inlining that it runs out of memory and terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-min\-size=n
.TP
.B
\-no\-inline\-min\-size
.RS
.TP
Specifies the upper limit for the size of what the inliner considers to be a small routine.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer that specifies the maximum size of what the inliner considers to be a small routine.
.TP
\fBDefault:\fR 
.TP 18
\-no\-inline\-min\-size 
.NL
The compiler uses default heuristics for inline routine expansion.
.TP
\fBDescription:\fR 
.PP
This option specifies the upper limit for the size of what the inliner considers to be a small routine (a function or subroutine). The inliner classifies routines as small, medium, or large. This option specifies the boundary between what the inliner considers to be small and medium\-size routines.
.NL
.PP
The inliner has a preference to inline small routines. So, when a routine is smaller than or equal to the specified size, it is very likely to be inlined.
.NL
.PP
If you specify \-no\-inline\-min\-size (Linux* OS and OS X*) or /Qinline\-min\-size\- (Windows* OS), there is no limit to the size of small routines. Every routine is a small routine; there are no medium or large routines.
.NL
.PP
To see compiler values for important inlining limits, specify the \-qopt\-report (Linux* OS and OS X*) or  /Qopt\-report (Windows) option.
.NL
.PP
.B CAUTION:
When you use this option to increase the default limit, the compiler may do so much additional inlining that it runs out of memory and terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-intconstant
.TP
.B
\-nointconstant
.RS
.TP
Tells the compiler to use FORTRAN 77 semantics to determine the kind parameter for integer constants.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
nointconstant
.NL
The compiler uses the Fortran 2003 default INTEGER type.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to use FORTRAN 77 semantics to determine the kind parameter for integer constants.
.NL
.PP
With FORTRAN 77 semantics, the kind is determined by the value of the constant. All constants are kept internally by the compiler in the highest precision possible. For example, if you specify option intconstant, the compiler stores an integer constant of 14 internally as INTEGER(KIND=8) and converts the constant upon reference to the corresponding proper size. Fortran 2003 specifies that integer constants with no explicit KIND are kept internally in the default INTEGER kind (KIND=4 by default).
.NL
.PP
Note that the internal precision for floating\-point constants is controlled by option \fIfpconstant\fR.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-integer\-size size
.RS
.TP
Specifies the default KIND for integer and logical variables.
.NL
.TP
\fBArguments:\fR 
.TP 18
size
.NL
Is the size for integer and logical variables. Possible values are: 16, 32, or 64.
.TP
\fBDefault:\fR 
.TP 18
integer\-size 32
.NL
Integer and logical variables are 4 bytes long (INTEGER(KIND=4) and LOGICAL(KIND=4)).
.TP
\fBDescription:\fR 
.PP
This option specifies the default size (in bits) for integer and logical variables.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
integer\-size 16
.NL
Makes default integer and logical declarations, constants,
functions, and intrinsics 2 bytes long. INTEGER and LOGICAL declarations are treated as (KIND=2). Integer and logical constants of unspecified KIND are evaluated in INTEGER (KIND=2) and LOGICAL(KIND=2)respectively.
.NL
.TP 18
integer\-size 32
.NL
Makes default integer and logical declarations, constants,
functions, and intrinsics 4 bytes long. INTEGER and LOGICAL declarations are treated as (KIND=4). Integer and logical constants of unspecified KIND are evaluated in INTEGER (KIND=4) and LOGICAL(KIND=4)respectively.
.NL
.TP 18
integer\-size 64
.NL
Makes default integer and logical declarations, constants,
functions, and intrinsics 8 bytes long. INTEGER and LOGICAL declarations are treated as (KIND=8). Integer and logical constants of unspecified KIND are evaluated in INTEGER (KIND=8) and LOGICAL(KIND=8)respectively.
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
integer\-size 16
.NL
Linux and OS X: \-i2
.TP 18
integer\-size 32
.NL
Linux and OS X: \-i4
.TP 18
integer\-size 64
.NL
Linux and OS X: \-i8
.RE
.TP
.B
\-ip
.TP
.B
\-no\-ip
.RS
.TP
Determines whether additional interprocedural optimizations for single\-file compilation are enabled.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Some limited interprocedural optimizations occur, including inline function expansion for calls to functions defined within the current source file. These optimizations are a subset of full intra\-file interprocedural optimizations. Note that this setting is not the same as \-no\-ip (Linux* OS and OS X*).
.TP
\fBDescription:\fR 
.PP
This option determines whether additional interprocedural optimizations for single\-file compilation are enabled. 
.NL
.PP
The [Q]ip option enables additional interprocedural optimizations for single\-file compilation. 
.NL
.PP
Options \-no\-ip (Linux OS and OS X) and /Qip\- (Windows OS) may not disable inlining. To ensure that inlining of user\-defined functions is disabled, specify \-inline\-level=0or \-fno\-inline (Linux OS and OS X), or specify /Ob0 (Windows OS). 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ip\-no\-inlining
.RS
.TP
Disables full and partial inlining enabled by interprocedural optimization options.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Inlining enabled by interprocedural optimization options is performed.
.TP
\fBDescription:\fR 
.PP
This option disables full and partial inlining enabled by the following interprocedural optimization options:
.NL
.IP \(bu 2
On Linux* and OS X* systems: \-ip or \-ipo
.IP \(bu 2
On Windows* systems: /Qip, /Qipo, or /Ob2
.PP
It has no effect on other interprocedural optimizations.
.NL
.PP
On Windows systems, this option also has no effect on user\-directed inlining specified by option /Ob1.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ip\-no\-pinlining
.RS
.TP
Disables partial inlining enabled by interprocedural optimization options.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Inlining enabled by interprocedural optimization options is performed.
.TP
\fBDescription:\fR 
.PP
This option disables partial inlining enabled by the following interprocedural optimization options:
.NL
.IP \(bu 2
On Linux* and OS X* systems: \-ip or \-ipo
.IP \(bu 2
On Windows* systems: /Qip or /Qipo
.PP
It has no effect on other interprocedural optimizations.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ipo[n]
.TP
.B
\-no\-ipo
.RS
.TP
Enables interprocedural optimization between files.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an optional integer that specifies the number of object files the compiler should create. The integer must be greater than or equal to 0.
.TP
\fBDefault:\fR 
.TP 18
\-no\-ipo or /Qipo\-
.NL
Multifile interprocedural optimization is not enabled.
.TP
\fBDescription:\fR 
.PP
This option enables interprocedural optimization between files. This is also called multifile interprocedural optimization (multifile IPO) or Whole Program Optimization (WPO).
.NL
.PP
When you specify this option, the compiler performs inline function expansion for calls to functions defined in separate files.
.NL
.PP
You cannot specify the names for the files that are created.
.NL
.PP
If \fIn\fR is 0, the compiler decides whether to create one or more object files based on an estimate of the size of the application. It generates one object file for small applications, and two or more object files for large applications.
.NL
.PP
If \fIn\fR is greater than 0, the compiler generates \fIn\fR object files, unless \fIn\fR exceeds the number of source files (\fIm\fR), in which case the compiler generates only \fIm\fR object files.
.NL
.PP
If you do not specify \fIn\fR, the default is 0.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ipo\-c
.RS
.TP
Tells the compiler to optimize across multiple files and generate a single object file.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate a multifile object file.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to optimize across multiple files and generate a single object file (named ipo_out.o
on Linux* and OS X* systems; ipo_out.obj
on Windows* systems).
.NL
.PP
It performs the same optimizations as the [Q]ipo option, but compilation stops before the final link stage, leaving an optimized object file that can be used in further link steps.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ipo\-jobsn
.RS
.TP
Specifies the number of commands (jobs) to be executed simultaneously during the link phase of Interprocedural Optimization (IPO).
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the number of commands (jobs) to run simultaneously. The number must be greater than or equal to 1.
.TP
\fBDefault:\fR 
.TP 18
\-ipo\-jobs1 
.NL
One command (job) is executed in an interprocedural optimization parallel build.
.TP
\fBDescription:\fR 
.PP
This option specifies the number of commands (jobs) to be executed simultaneously during the link phase of Interprocedural Optimization (IPO). It should only be used if the link\-time compilation is generating more than one object. In this case, each object is generated by a separate compilation, which can be done in parallel.
.NL
.PP
This option can be affected by the following compiler options:
.NL
.IP \(bu 2
[Q]ipo when applications are large enough that the compiler decides to generate multiple object files.
.IP \(bu 2
[Q]ipo\fIn\fR when \fIn\fR is greater than 1.
.IP \(bu 2
[Q]ipo\-separate
.PP
.B CAUTION:
Be careful when using this option. On a multi\-processor system with lots of memory, it can speed application build time. However, if \fIn\fR is greater than the number of processors, or if there is not enough memory to avoid thrashing, this option can increase application build time.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ipo\-S
.RS
.TP
Tells the compiler to optimize across multiple files and generate a single assembly file.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate a multifile assembly file.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to optimize across multiple files and generate a single assembly file (named ipo_out.s on Linux* and OS X* systems; ipo_out.asm
on Windows* systems). 
.NL
.PP
It performs the same optimizations as the [Q]ipo option, but compilation stops before the final link stage, leaving an optimized assembly file that can be used in further link steps.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ipo\-separate (L*X only)
.RS
.TP
Tells the compiler to generate one object file for every source file.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler decides whether to create one or more object files.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate one object file for every source file. It overrides any [Q]ipo option  specification.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-isystemdir
.RS
.TP
Specifies a directory to add to the start of the system include path.
.NL
.TP
\fBArchitecture Restrictions:\fR  Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the directory to add to the system include path.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The default system include path is used.
.TP
\fBDescription:\fR 
.PP
This option specifies a directory to add to the system include path. The compiler searches the specified directory for include files after it searches all directories specified by the \-I compiler option but before it searches the standard system directories. 
.NL
.PP
On Linux* systems, this option is provided for compatibility with gcc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-lstring
.RS
.TP
Tells the linker to search for a specified library when linking.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIstring\fR
.NL
Specifies the library (lib\fIstring\fR) that the linker should search.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The linker searches for standard libraries in standard directories.
.TP
\fBDescription:\fR 
.PP
This option tells the linker to search for a specified library when linking.
.NL
.PP
When resolving references, the linker normally searches for libraries in several standard directories, in directories specified by the L option, then in the library specified by the l option.
.NL
.PP
The linker searches and processes libraries and object files in the order they are specified. So, you should specify this option following the last object file it applies to.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Ldir
.RS
.TP
Tells the linker to search for libraries in a specified directory before searching the standard directories.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the name of the directory to search for libraries.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The linker searches the standard directories for libraries.
.TP
\fBDescription:\fR 
.PP
This option tells the linker to search for libraries in a specified directory before searching for them in the standard directories.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-list[=filename]
.TP
.B
\-no\-list
.RS
.TP
Tells the compiler to create a listing of the source file.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file for output. It can include a path.
.TP
\fBDefault:\fR 
.TP 18
\-no\-list or /list\-
.NL
No listing is created for the source file.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to create a
listing of the source file.  The listing contains the following:
.NL
.IP \(bu 2
The contents of files included with INCLUDE statements
.IP \(bu 2
A symbol list with a line
number cross\-reference for each routine
.IP \(bu 2
A list of compiler
options used for the current compilation
.PP
The contents of the listing can be controlled
by specifying option show.
.NL
.PP
The line length of the listing can be specified
by using option list\-line\-len.
.NL
.PP
The page length of the listing can be specified
by using option list\-page\-len.
.NL
.PP
If you do not specify \fIfilename\fR, the output is
written to a file in the same directory as the source. The file name is the name of the source
file with an extension of .lst.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-list\-line\-len=n
.RS
.TP
Specifies the line length for the listing generated when option list is specified.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer indicating the number of columns to show in
the listing.
.TP
\fBDefault:\fR 
.TP 18
80
.NL
When a listing is generated, the default line length is 80 columns.
.TP
\fBDescription:\fR 
.PP
This option specifies the line length for the
listing generated when option list is specified.
.NL
.PP
If you specify option list\-line\-len and do not
specify option list, the option is ignored.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-list\-page\-len=n
.RS
.TP
Specifies the page length for the listing generated when option list is specified.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer indicating the number of lines on a page to show in
the listing.
.TP
\fBDefault:\fR 
.TP 18
60
.NL
When a listing is generated, the default page length is 60 lines.
.TP
\fBDescription:\fR 
.PP
This option specifies the page length for the
listing generated when option list is specified.
.NL
.PP
If you specify option list\-page\-len and do not
specify option list, the option is ignored.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-logo
.TP
.B
\-nologo
.RS
.TP
Displays the compiler version information.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
Linux* OS and OS X*: nologo
.NL
The compiler version information is not displayed.
.TP
\fBDescription:\fR 
.PP
This option displays the startup banner, which contains the following compiler information:
.NL
.IP \(bu 2
The name of the compiler and its applicable architecture
.IP \(bu 2
The major and minor version of the compiler, the update number, and the package number(for example, Version 11.1.0.047)
.IP \(bu 2
The specific build and build date (for example, Build <builddate>)
.IP \(bu 2
The copyright date of the software
.PP
This option can be placed anywhere on the command line.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-V
.NL
.RE
.TP
.B
\-mcode
.RS
.TP
Tells the compiler which features it may target, including which instruction sets it may generate.
.NL
.TP
\fBArchitecture Restrictions:\fR  Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIcode\fR
.NL
Indicates to the compiler a feature set that it may target, including which instruction sets it may generate. Many of the following descriptions refer to
Intel(R) Streaming SIMD Extensions (Intel(R) SSE) and Supplemental
Streaming SIMD Extensions (SSSE). Possible values are:
.RS
.TP 15
avx
May generate Intel(R) Advanced Vector Extensions (Intel(R) AVX), SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions. 
.TP 15
sse4.2
May generate Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions.
.TP 15
sse4.1
May generate Intel(R) SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions.
.TP 15
ssse3
May generate SSSE3 instructions and Intel(R) SSE3, SSE2, and SSE instructions.
.TP 15
sse3
May generate Intel(R) SSE3, SSE2, and SSE instructions.
.TP 15
sse2
May generate Intel(R) SSE2 and SSE instructions.  This value is only available on Linux systems.
.TP 15
sse
This option has been deprecated; it is now the same as specifying ia32.
.TP 15
ia32
Generates x86/x87 generic code that is compatible with IA\-32 architecture. Disables any default extended instruction settings, and any previously set extended instruction settings.  It also disables all feature\-specific optimizations and instructions. This value is only available on Linux* systems using IA\-32 architecture.
.RE
.TP
\fBDefault:\fR 
.TP 18
Linux* systems: \-msse2 OS X* systems using IA\-32 architecture: \-msse3 OS X* systems using Intel(R) 64 architecture: \-mssse3
.NL
For more information on the default values, see Arguments above.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler which features it may target, including which instruction sets it may generate. 
.NL
.PP
Code generated with these options should execute on any compatible, non\-Intel processor with support for the corresponding instruction set.
.NL
.PP
Options \-x and \-m are mutually exclusive. If both are specified, the compiler uses the last one specified and generates a warning.
.NL
.PP
Linux* systems:  For compatibility with gcc, the compiler allows the following options but they have no effect. You will get a warning error, but the instructions associated with the name will not be generated. You should use the suggested replacement options.
.NL
.TP 18
gcc Compatibility Option (Linux* OS)
.NL
Suggested Replacement Option
.NL
.TP 18
\-mfma
.NL
\-march=core\-avx2
.NL
.TP 18
\-mbmi, \-mavx2, \-mlzcnt
.NL
\-march=core\-avx2
.NL
.TP 18
\-mmovbe
.NL
\-march=atom \-minstruction=movbe
.NL
.TP 18
\-mcrc32, \-maes, \-mpclmul, \-mpopcnt
.NL
\-march=corei7
.NL
.TP 18
\-mvzeroupper
.NL
\-march=corei7\-avx
.NL
.TP 18
\-mfsgsbase, \-mrdrnd, \-mf16c
.NL
\-march=core\-avx\-i
.NL
.PP
Many of the above gcc options are not available on Intel(R) MIC Architecture.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-m32
.TP
.B
\-m64
.RS
.TP
Tells the compiler to generate code for a specific architecture.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler\[aq]s behavior depends on the host system.
.TP
\fBDescription:\fR 
.PP
These options tell the compiler to generate code for a specific architecture.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
\-m32
.NL
Tells the compiler to generate code for IA\-32 architecture.
.NL
.TP 18
\-m64
.NL
Tells the compiler to generate code for Intel(R) 64 architecture.
.NL
.PP
The \-m32 and \-m64 options are the same as OS X* options \-arch i386 and \-arch x86_64, respectively.  These options are not related to the Intel(R) Fortran  Compiler option arch.
.NL
.PP
On Linux* systems,  these options are provided for compatibility with gcc. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-map\-opts (L*X only)
.RS
.TP
Maps one or more compiler options to their equivalent on a different operating system.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No platform mappings are performed.
.TP
\fBDescription:\fR 
.PP
This option maps one or more compiler options to their equivalent on a different operating system. The result is output to stdout. 
.NL
.PP
On Windows systems, the options you provide are presumed to be Windows options, so the options that are output to stdout will be Linux equivalents.
.NL
.PP
On Linux systems, the options you provide are presumed to be Linux options, so the options that are output to stdout will be Windows equivalents.
.NL
.PP
The tool can be invoked from the compiler command line or it can be used directly. 
.NL
.PP
No compilation is performed when the option mapping tool is used.
.NL
.PP
This option is useful if you have both compilers and want to convert scripts or makefiles.
.NL
.PP
.B NOTE:
Compiler options are mapped to their equivalent on the architecture you are using. For example, if you are using a processor with IA\-32 architecture, you will only see equivalent options that are available on processors with IA\-32 architecture.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-march=processor
.RS
.TP
Tells the compiler to generate code for processors that support certain features. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIprocessor\fR
.NL
Indicates to the compiler the code it may generate. Possible values are:
.RS
.TP 15
generic
Generates code for the compiler\[aq]s default behavior.
.TP 15
core\-avx2
Generates code for processors that support Intel(R) Advanced Vector Extensions 2 (Intel(R) AVX2), Intel(R) AVX, SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions.
.TP 15
core\-avx\-i
Generates code for processors that support the RDRND instruction, Intel(R) Advanced Vector Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions.
.TP 15
corei7\-avx
Generates code for processors that support Intel(R) Advanced Vector Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions.
.TP 15
corei7
Generates code for processors that support Intel(R) SSE4 Efficient Accelerated String and Text Processing instructions. May also generate code for Intel(R) SSE4 Vectorizing Compiler and Media Accelerator, Intel(R) SSE3, SSE2, SSE, and SSSE3 instructions.
.TP 15
atom
Generates code for processors that support MOVBE instructions, depending on the setting of option \-minstruction (Linux* OS and OS X*) or /Qinstruction (Windows* OS). May also generate code for SSSE3 instructions and  Intel(R) SSE3, SSE2, and SSE instructions.
.TP 15
core2
Generates code for the Intel(R) Core(TM) 2 processor family.
.TP 15
pentium\-mmx
Generates for Intel(R) Pentium(R) with MMX technology.
.TP 15
pentiumpro
Generates for Intel(R) Pentium(R) Pro, Intel Pentium II, and Intel Pentium III processors.
.TP 15
pentium4m
Generates for Intel(R) Pentium(R) 4 processors with MMX technology.
.TP 15
pentium\-m pentium4 pentium3 pentium
Generates code for Intel(R) Pentium(R) processors. Value pentium3 is only available on Linux* OS.
.RE
.TP
\fBDefault:\fR 
.TP 18
pentium4
.NL
If no architecture option is specified, value pentium4 is used by the compiler to generate code.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate code for processors that support certain features.
.NL
.PP
If you specify both the \-ax and \-march options, the compiler will not generate Intel\-specific instructions.
.NL
.PP
Specifying \-march=pentium4 sets \-mtune=pentium4.
.NL
.PP
For compatibility, a number of historical \fIprocessor\fR values are also supported, but the generated code will not differ from the default.
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
\-march=pentium3
.NL
Linux: \-xSSE
.IP
OS X: None
.TP 18
\-march=pentium4 \-march=pentium\-m
.NL
Linux: \-xSSE2
.IP
OS X: None
.TP 18
\-march=core2
.NL
Linux: \-xSSSE3
.IP
OS X: None
.RE
.TP
.B
\-mcmodel=mem_model (L*X only)
.RS
.TP
Tells the compiler to use a specific memory model to generate code and store data.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fImem_model\fR
.NL
Is the memory model to use. Possible values are:
.RS
.TP 15
small
Tells the compiler to restrict code and data to the first 2GB of address space. All accesses of code and data can be done with Instruction Pointer (IP)\-relative addressing.
.TP 15
medium
Tells the compiler to restrict code to the first 2GB; it places no memory restriction on data. Accesses of code can be done with IP\-relative addressing, but accesses of data must be done with absolute addressing.
.TP 15
large
Places no memory restriction on code or data. All accesses of code and data must be done with absolute addressing.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-mcmodel=small
.NL
On systems using Intel(R) 64 architecture, the compiler restricts code and data to the first 2GB of address space. Instruction Pointer (IP)\-relative addressing can be used to access code and data.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to use a specific memory model to generate code and store data. It can affect code size and performance. If your program has COMMON blocks and local data with a total size smaller than 2GB, \-mcmodel=small is sufficient. COMMONs larger than 2GB require\-mcmodel=medium or \-mcmodel=large. 
Allocation of memory larger than 2GB can be done with any setting of \-mcmodel.
.NL
.PP
IP\-relative addressing requires only 32 bits, whereas absolute addressing requires 64\-bits. IP\-relative addressing is somewhat faster. So, the small memory model has the least impact on performance.
.NL
.PP
.B NOTE:
When you specify option \-mcmodel=medium or \-mcmodel=large, it sets option \-shared\-intel. This ensures that the correct dynamic versions of the Intel run\-time libraries are used.
.PP
If you specify option \-static\-intel while \-mcmodel=medium or \-mcmodel=large is set, an error will be displayed.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mdynamic\-no\-pic (M*X only)
.RS
.TP
Generates code that is not position\-independent but has position\-independent external references. 
.NL
.TP
\fBArchitecture Restrictions:\fR  Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
All references are generated as position independent.
.TP
\fBDescription:\fR 
.PP
This option generates code that is not position\-independent but has position\-independent external references.
.NL
.PP
The generated code is suitable for building executables, but it is not suitable for building shared libraries.
.NL
.PP
This option may reduce code size and produce more efficient code. It overrides the \-fpic compiler option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-minstruction=[no]movbe
.RS
.TP
Determines whether MOVBE instructions are generated for certain Intel processors.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
–minstruction=nomovbe 
.NL
The compiler does not generate MOVBE instructions for Intel(R) Atom(TM) processors.
.TP
\fBDescription:\fR 
.PP
This option determines whether MOVBE instructions are generated for Intel(R) Atom(TM)  processors. To use this option, you must also specify 
[Q]xATOM_SSSE3  or [Q]xATOM_SSE4.2.
.NL
.PP
If \-minstruction=movbe or /Qinstruction:movbe is specified, 
the following occurs:
.NL
.IP \(bu 2
MOVBE instructions are generated that are specific to the Intel(R) Atom(TM) processor.
.IP \(bu 2
Generated executables can only be run on Intel(R) Atom(TM) processors or processors that support Supplemental Streaming SIMD Extensions 3 (Intel(R) SSSE3) 
or Intel(R) Streaming SIMD Extensions 4.2 (Intel(R) SSE4.2) and MOVBE.
.PP
If \-minstruction=nomovbe or 
/Qinstruction:nomovbe is specified, the following occurs:
.NL
.IP \(bu 2
The compiler optimizes code for the Intel(R) Atom(TM) processor, but it does not generate MOVBE instructions.
.IP \(bu 2
Generated executables can be run on non\-Intel(R) Atom(TM) processors that support Intel(R)
SSE3 or Intel(R)
SSE4.2.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mkl[=lib]
.RS
.TP
Tells the compiler to link to certain libraries in the Intel(R) Math Kernel Library (Intel(R) MKL).
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIlib\fR
.NL
Indicates which Intel(R) MKL library files should be linked. Possible values are:
.RS
.TP 15
parallel
Tells the compiler to link using the threaded libraries in the Intel(R) MKL. This is the default if the option is specified with no \fIlib\fR.
.TP 15
sequential
Tells the compiler to link using the sequential libraries in the Intel(R) MKL.
.TP 15
cluster
Tells the compiler to link using the cluster\-specific libraries and the sequential libraries in the  Intel(R) MKL. Cluster\-specific libraries are not available for OS X*.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not link to the Intel(R) MKL.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to link to certain libraries in the Intel(R) Math Kernel Library (Intel(R) MKL).
.NL
.PP
.B NOTE:
On Windows* OS, this option adds directives to the compiled code, which the linker then reads without further input from the driver. On Linux* OS and OS X, the driver must add the library names explicitly to the link command.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mmic
(L*X only)
.RS
.TP
Builds an application that runs natively on Intel(R) MIC Architecture. This option only applies to Intel(R) MIC Architecture.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler builds a heterogeneous application. You must specify this option to build an application that runs natively on Intel(R) MIC Architecture.
.TP
\fBDescription:\fR 
.PP
This option enables the cross compiler to build	an application that runs natively on Intel(R) MIC Architecture. It is only available on the command line.
.NL
.PP
When you use this option, the compiler defines the macro __MIC__.
.NL
.PP
.B NOTE:
When you specify Windows* option /Qmic, you must specify any other options on the command line in the Linux* form. This is because all other options are passed directly to the native Intel(R) MIC Architecture compiler, which is a Windows*\-hosted Linux* compiler.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-module path
.RS
.TP
Specifies the directory where module files should be placed when created and where they should be searched for.
.NL
.TP
\fBArguments:\fR 
.TP 18
path
.NL
Is the directory for module files.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler places module files in the current directory.
.TP
\fBDescription:\fR 
.PP
This option specifies the directory (path) where module (.mod) files should be placed when created and where they should be searched for (USE statement).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mp1
.RS
.TP
Improves floating\-point precision and consistency.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler provides good accuracy and run\-time performance at the expense of less consistent floating\-point results.
.TP
\fBDescription:\fR 
.PP
This option improves floating\-point consistency. It ensures the out\-of\-range check of operands of transcendental functions and improves the accuracy of floating\-point compares.
.NL
.PP
This option prevents the compiler from performing optimizations that change NaN comparison semantics and causes all values to be truncated to declared precision before they are used in comparisons. It also causes the compiler to use library routines that give better precision results compared to the X87 transcendental instructions.
.NL
.PP
This option disables fewer optimizations and has less impact on performance than option fltconsistency.
.NL
.PP
This option disables fewer optimizations and has less impact on performance than option fltconsistency,\-fp\-model precise (Linux* OS and OS X*), or option /fp:precise (Windows* OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mtune=processor
.RS
.TP
Performs optimizations for specific processors.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIprocessor\fR
.NL
Is the processor for which the compiler should perform optimizations.    Possible values are: 
.RS
.TP 15
generic
Optimizes code for the compiler\[aq]s default behavior.
.TP 15
core\-avx2
Optimizes code for processors that support Intel(R) Advanced Vector Extensions 2 (Intel(R) AVX2), Intel(R) AVX, SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions.
.TP 15
core\-avx\-i
Optimizes code for processors that support the RDRND instruction, Intel(R) Advanced Vector Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions.
.TP 15
corei7\-avx
Optimizes code for processors that support Intel(R) Advanced Vector Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions.
.TP 15
corei7
Optimizes code for processors that support Intel(R) SSE4 Efficient Accelerated String and Text Processing instructions. May also generate code for Intel(R) SSE4 Vectorizing Compiler and Media Accelerator, Intel(R) SSE3, SSE2, SSE, and SSSE3 instructions.
.TP 15
atom
Optimizes code for processors that support MOVBE instructions, depending on the setting of option \-minstruction (Linux* OS and OS X*) or /Qinstruction (Windows* OS). May also generate code for SSSE3 instructions and  Intel(R) SSE3, SSE2, and SSE instructions.
.TP 15
core2
Optimizes for the Intel(R) Core(TM) 2 processor family, including support for MMX(TM), Intel(R) SSE, SSE2, SSE3 and SSSE3 instruction sets.
.TP 15
pentium\-mmx
Optimizes for Intel(R) Pentium(R) with MMX technology.
.TP 15
pentiumpro
Optimizes for Intel(R) Pentium(R) Pro, Intel Pentium II, and Intel Pentium III processors.
.TP 15
pentium4m
Optimizes for Intel(R) Pentium(R) 4 processors with MMX technology.
.TP 15
pentium\-m pentium4 pentium3 pentium
Optimizes code for Intel(R) Pentium(R) processors. Value pentium3 is only available on Linux* OS.
.RE
.TP
\fBDefault:\fR 
.TP 18
generic
.NL
Code is generated for the compiler\[aq]s default behavior.
.TP
\fBDescription:\fR 
.PP
This option performs optimizations for specific processors.
.NL
.PP
The resulting executable is backwards compatible and generated code is optimized for specific processors. For example, code generated with \-mtune=pentium4 will run correctly on Core2 processors, but it might not run as fast as if it had been generated using \-mtune=core2.
.NL
.PP
The following table shows on which architecture you can use each value.
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
\-mtune
.NL
Linux: \-mcpu (this is a deprecated option)
.IP
OS X: None
.RE
.TP
.B
\-multiple\-processes[=n]
.RS
.TP
Creates multiple processes that can be used to compile large numbers of source files at the same time. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the maximum number of processes that the compiler should create. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
A single process is used to compile source files.  
.TP
\fBDescription:\fR 
.PP
This option creates multiple processes that can be used to compile large numbers of source files at the same time. It can improve performance by reducing the time it takes to compile source files on the command line.
.NL
.PP
This option causes the compiler to create one or more copies of itself, each in a separate process. These copies simultaneously compile the source files.
.NL
.PP
If \fIn\fR is not specified for this option, the default value is as follows:
.NL
.IP \(bu 2
On Windows* OS, the value is based on the setting of the NUMBER_OF_PROCESSORS environment variable. 
.IP \(bu 2
On Linux* OS and OS X*, the value is 2. 
.PP
This option applies to compilations, but not to linking or link\-time code generation.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-names keyword
.RS
.TP
Specifies how source code identifiers and external names are interpreted.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies how to interpret the identifiers and external names in source code. Possible values are:
.RS
.TP 15
lowercase
Causes the compiler to ignore case differences in identifiers and to convert external names to lowercase.
.TP 15
uppercase
Causes the compiler to ignore case differences in identifiers and to convert external names to uppercase.
.TP 15
as_is
Causes the compiler to distinguish case differences in identifiers and to preserve the case of external names.
.RE
.TP
\fBDefault:\fR 
.TP 18
lowercase
.NL
This is the default on Linux* and OS X* systems. The compiler ignores case differences in identifiers and converts external names to lowercase.
.TP 18
uppercase
.NL
This is the default on Windows* systems. The compiler ignores case differences in identifiers and converts external names to uppercase.
.TP
\fBDescription:\fR 
.PP
This option specifies how source code identifiers and external names are interpreted. It can be useful in mixed\-language programming.
.NL
.PP
This naming convention applies whether names are being defined or referenced.
.NL
.PP
You can use the ALIAS directive to specify an alternate external name to be used when referring to external subprograms.
.NL
.PP
.B CAUTION:
On Windows systems, if you specify option /iface:cref, it overrides the default for external names and causes them to be lowercase. It is as if you specified "!dir$ attributes c, reference" for the external name.
.PP
If you specify option /iface:cref and want external names to be uppercase, you must explicitly specify option /names:uppercase.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-no\-bss\-init
.RS
.TP
Tells the compiler to place in the DATA section any uninitialized variables and explicitly zero\-initialized variables.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Uninitialized variables and explicitly zero\-initialized variables are placed in the BSS section.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to place in the DATA section any uninitialized variables and explicitly zero\-initialized variables.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-nodefaultlibs
.RS
.TP
Prevents the compiler from using standard libraries when linking.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The standard libraries are linked.
.TP
\fBDescription:\fR 
.PP
This option prevents the compiler from using standard libraries when linking.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-nofor\-main
.RS
.TP
Specifies that the main program is not written in Fortran.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler assumes the main program is written in Fortran.
.TP
\fBDescription:\fR 
.PP
This option specifies that the main program is not written in Fortran. It is a link\-time option that prevents the compiler from linking for_main.o into applications. 
.NL
.PP
For example, if the main program is written in C and calls a Fortran subprogram, specify \-nofor\-main when compiling the program with the ifort command.
.NL
.PP
If you omit this option, the main program must be a Fortran program.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-nolib\-inline
.RS
.TP
Disables inline expansion of standard library or intrinsic functions.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler inlines many standard library and intrinsic functions.
.TP
\fBDescription:\fR 
.PP
This option disables inline expansion of standard library or intrinsic functions. It prevents the unexpected results that can arise from inline expansion of these functions.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-nostartfiles
.RS
.TP
Prevents the compiler from using standard startup files when linking.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses standard startup files when linking.
.TP
\fBDescription:\fR 
.PP
This option prevents the compiler from using standard startup files when linking.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-nostdlib
.RS
.TP
Prevents the compiler from using standard libraries and startup files when linking.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses standard startup files and standard libraries when linking.
.TP
\fBDescription:\fR 
.PP
This option prevents the compiler from using standard libraries and startup files when linking. 
.NL
.PP
This option is not related to option \-stdlib.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-o filename
.RS
.TP
Specifies the name for an output file.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name for the output file. The space before \fIfilename\fR is optional.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses the default file name for an output file.
.TP
\fBDescription:\fR 
.PP
This option specifies the name for an output file as follows:
.NL
.IP \(bu 2
If \-c is specified, it specifies the name of the generated object file.
.IP \(bu 2
If \-S is specified, it specifies the name of the generated assembly listing file.
.IP \(bu 2
If \-preprocess\-only or \-P is specified, it specifies the name of the generated preprocessor file.
.PP
Otherwise, it specifies the name of the executable file.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.PP
Windows: /exe
.NL
.RE
.TP
.B
\-O[n]
.RS
.TP
Specifies the code optimization for applications.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the optimization level. Possible values are 1, 2, or 3. On Linux* and OS X* systems, you can also specify 0.
.TP
\fBDefault:\fR 
.TP 18
O2
.NL
Optimizes for code speed. This default may change depending on which other compiler options are specified. For details, see below.
.TP
\fBDescription:\fR 
.PP
This option specifies the code optimization for applications.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
O (Linux* OS and OS X*)
.NL
This is the same as specifying O2.
.NL
.TP 18
O0 (Linux OS and OS X)
.NL
Disables all optimizations. 
.TP 18
This option may set other options. This is determined by the compiler, depending on which operating system and architecture you are using. The options that are set may change from release to release.
.TP 18
This option causes certain warn options to be ignored. This is the default if you specify option \-debug (with no keyword).
.NL
.TP 18
O1
.NL
Enables optimizations for speed and disables some optimizations that increase code size and affect speed. To limit code size, this option:
.RS
.IP \(bu 2
Enables global optimization; this includes data\-flow analysis, code motion, strength reduction and test replacement, split\-lifetime analysis, and instruction scheduling.
.RE
.TP 18
This option may set other options. This is determined by the compiler, depending on which operating system and architecture you are using. The options that are set may change from release to release.
.TP 18
The O1 option may improve performance for applications with very large code size, many branches, and execution time not dominated by code within loops.
.NL
.TP 18
O2
.NL
Enables optimizations for speed. This is the generally recommended optimization level.  Vectorization is enabled at O2 and higher levels.
.TP 18
On systems using IA\-32 architecture: Some basic loop optimizations such as Distribution, Predicate Opt, Interchange, multi\-versioning, and scalar replacements are performed.
.TP 18
This option also enables:
.RS
.IP \(bu 2
Inlining of intrinsics
.IP \(bu 2
Intra\-file interprocedural optimization, which includes:
.RS
.IP \(bu 2
inlining
.IP \(bu 2
constant propagation
.IP \(bu 2
forward substitution
.IP \(bu 2
routine attribute propagation
.IP \(bu 2
variable address\-taken analysis
.IP \(bu 2
dead static function elimination
.IP \(bu 2
removal of unreferenced variables
.RE
.IP \(bu 2
The following capabilities for performance gain:
.RS
.IP \(bu 2
constant propagation
.IP \(bu 2
copy propagation
.IP \(bu 2
dead\-code elimination
.IP \(bu 2
global register allocation
.IP \(bu 2
global instruction scheduling and control speculation
.IP \(bu 2
loop unrolling
.IP \(bu 2
optimized code selection
.IP \(bu 2
partial redundancy elimination
.IP \(bu 2
strength reduction/induction variable simplification
.IP \(bu 2
variable renaming
.IP \(bu 2
exception handling optimizations
.IP \(bu 2
tail recursions
.IP \(bu 2
peephole optimizations
.IP \(bu 2
structure assignment lowering and optimizations
.IP \(bu 2
dead store elimination
.RE
.RE
.TP 18
This option may set other options,  especially options that optimize for code speed. This is determined by the compiler, depending on which operating system and architecture you are using. The options that are set may change from release to release.
.TP 18
On Windows* systems, this option is the same as the Ox option.
.TP 18
On Linux* and OS X* systems, if \-g is specified, O2 is turned off and O0 is the default unless O2 (or O1 
or O3) is explicitly specified in the command line together with \-g.
.TP 18
On Linux systems, the \-debug inline\-debug\-info option will be enabled by default if you compile with optimizations (option \-O2 or higher) and debugging is enabled (option \-g).
.TP 18
Many routines in the shared libraries are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.NL
.TP 18
O3
.NL
Performs O2 optimizations and enables more aggressive loop transformations such as Fusion, Block\-Unroll\-and\-Jam, and collapsing IF statements.
.TP 18
This option may set other options. This is determined by the compiler, depending on which operating system and architecture you are using. The options that are set may change from release to release.
.TP 18
When O3 is used with options \-ax or \-x (Linux OS) or with options /Qax or /Qx (Windows OS), the compiler performs more aggressive data dependency analysis than for O2, which may result in longer compilation times.
.TP 18
The O3 optimizations may not cause higher performance unless loop and memory access transformations take place. The optimizations may slow down code in some cases compared to O2 optimizations.
.TP 18
The O3 option is recommended for applications that have loops that heavily use floating\-point calculations and process large data sets. 
.TP 18
Many routines in the shared libraries are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.NL
.PP
The last O option specified on the command line takes precedence over any others.
.NL
.RE
.TP
.B
\-Ofast
.RS
.TP
Sets certain aggressive options to improve the speed of your application.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The aggressive optimizations that improve speed are not enabled.
.TP
\fBDescription:\fR 
.PP
This option improves the speed  of your
application.
.NL
.PP
It sets compiler options \-O3, \-no\-prec\-div, and \-fp\-model fast=2. 
.NL
.PP
On Linux* systems, this option is
provided for compatibility with gcc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Os
.RS
.TP
Enables optimizations that do not increase code size and produces smaller code size than O2. 
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Optimizations are made for code speed. However, if O1 is specified, Os is the default.
.TP
\fBDescription:\fR 
.PP
This option enables optimizations that do not increase code size and produces smaller code size than O2. It disables some optimizations that increase code size for a small speed benefit.
.NL
.PP
This option tells the compiler to favor transformations that reduce code size over transformations that produce maximum performance.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-p
.RS
.TP
Compiles and links for function profiling with gprof(1).
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Files are compiled and linked without profiling.
.TP
\fBDescription:\fR 
.PP
This option compiles and links for function profiling with gprof(1).
.NL
.PP
When you specify this option, inlining is disabled. However, you can override this by specifying directive FORCEINLINE, or a compiler option such as [Q]inline\-forceinline.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-pg,\-qp (this is a deprecated option)
.NL
.RE
.TP
.B
\-pad
.TP
.B
\-nopad
.RS
.TP
Enables the changing of the variable and array memory layout.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-nopad
.NL
Variable and array memory layout is performed by default methods.
.TP
\fBDescription:\fR 
.PP
This option enables the changing of the variable and array memory layout.
.NL
.PP
This option is effectively not different from the align option when applied to structures and derived types. However, the scope of pad is greater because it applies also to common blocks, derived types, sequence types, and structures.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-pad\-source
.TP
.B
\-nopad\-source
.RS
.TP
Specifies padding for fixed\-form source records.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-nopad\-source
.NL
Fixed\-form source records are not padded.
.TP
\fBDescription:\fR 
.PP
This option specifies padding for fixed\-form source records. It tells the compiler that fixed\-form source lines shorter than the statement field width are to be padded with spaces to the end of the statement field. This affects the interpretation of character and Hollerith literals that are continued across source records.
.NL
.PP
The default value setting causes a warning message to be displayed if a character or Hollerith literal that ends before the statement field ends is continued onto the next source record. To suppress this warning message, specify  setting nousage for option warn.
.NL
.PP
Specifying [Q]pad\-source can prevent warning messages associated with  setting usage for option warn. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-parallel
.RS
.TP
Tells the auto\-parallelizer to generate multithreaded code for loops that can be safely executed in parallel.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Multithreaded code is not generated for loops that can be safely executed in parallel.
.TP
\fBDescription:\fR 
.PP
This option tells the auto\-parallelizer to generate multithreaded code for loops that can be safely executed in parallel. 
.NL
.PP
To use this option, you must also specify option O2 or O3.
.NL
.PP
This option sets option \-qopt\-matmul on Linux* OS, and 
option /Qopt\-matmul on Windows* OS, if option O3 is also
specified.
.NL
.PP
.B NOTE:
On OS X* systems, when you enable automatic parallelization, you must also set the DYLD_LIBRARY_PATH environment variable within Xcode* or an error will be displayed.
.PP
.B NOTE:
Using this option enables parallelization for both Intel(R) microprocessors and non\-Intel microprocessors.  The resulting executable may get additional performance gain on Intel microprocessors than on non\-Intel
microprocessors. The parallelization can also be affected by certain options, such as /arch or /Qx (Windows OS) or \-m or \-x (Linux OS and OS X).
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-parallel\-source\-info[=n]
.TP
.B
\-no\-parallel\-source\-info
.RS
.TP
Enables or disables source location emission when OpenMP* or auto\-parallelism code is generated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the level of source location emission. Possible values are:
.RS
.TP 15
0
Disables the emission of source location information when OpenMP* code or auto\-parallelism code is generated. This is the same as specifying \-no\-parallel\-source\-info (Linux* OS and OS X*) or /Qparallel\-source\-info\- (Windows* OS).
.TP 15
1
Tells the compiler to emit routine name and line information. This is the same as specifying [Q]parallel\-source\-info  with no \fIn\fR.
.TP 15
2
Tells the compiler to emit path, file, routine name, and line information.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-parallel\-source\-info=1 
.NL
When OpenMP* code or auto\-parallelism code is generated, the routine name and line information is emitted.
.TP
\fBDescription:\fR 
.PP
This option enables or disables source location emission when OpenMP code or auto\-parallelism code is generated.  It also lets you set the level of emission.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-par\-affinity=[modifier,...]type[,permute][,offset] (L*X only)
.RS
.TP
Specifies thread affinity.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fImodifier\fR
.NL
Is one of the following values:
granularity={fine|thread|core}, [no]respect, [no]verbose, [no]warnings, proclist=proc_list.
The default is granularity=core, respect, and noverbose. 
.TP 18
\fItype\fR
.NL
Indicates the thread affinity. This argument is required and must be one of the following values: 
compact, disabled, explicit, none, scatter, logical, physical.  The default is none.
Values logical and physical are deprecated. Use compact and scatter, respectively, with no \fIpermute\fR value.
.TP 18
\fIpermute\fR
.NL
Is a positive integer. You cannot use this argument with \fItype\fR setting explicit, none, or disabled. The default is 0.
.TP 18
\fIoffset\fR
.NL
Is a positive integer. You cannot use this argument with \fItype\fR setting explicit, none, or disabled. The default is 0.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The thread affinity is determined by the run\-time environment.
.TP
\fBDescription:\fR 
.PP
This option specifies thread affinity, which binds threads to physical processing units. It has the same effect as environment variable KMP_AFFINITY.
.NL
.PP
This option overrides the environment variable when both are specified. 
.NL
.PP
This option only has an effect if the following is true:
.NL
.IP \(bu 2
Linux* OS: You have specified option \-parallel or \-qopenmp (or both).
Windows* OS: You have specified option /Qparallel or /Qopenmp (or
both).
.IP \(bu 2
You are compiling the main program.
.PP
.B NOTE:
This option may behave differently on Intel(R) microprocessors than on non\-Intel microprocessors.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-par\-num\-threads=n
.RS
.TP
Specifies the number of threads to use in a parallel region.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the number of threads to use. It must be a positive integer.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The number of threads to use is determined by the run\-time environment.
.TP
\fBDescription:\fR 
.PP
This option specifies the number of threads to
use in a parallel region. It has the same effect as environment
variable OMP_NUM_THREADS.
.NL
.PP
This option overrides the environment variable
when both are specified.
.NL
.PP
This option only has an effect if the following
is true:
.NL
.IP \(bu 2
Linux* OS and OS X*: You have specified option \-parallel or \-qopenmp (or both).
Windows* OS: You have specified option /Qparallel or /Qopenmp (or
both).
.IP \(bu 2
You are compiling the
main program.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-par\-report[=n]
.RS
.TP
Controls the diagnostic information reported by the auto\-parallelizer. This is a deprecated option. The replacement options for this kind of report are \-qopt\-report \-qopt\-report\-phase=par (Linux* OS and OS X*) or /Qopt\-report /Qopt\-report\-phase:par (Windows* OS).
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a value denoting which diagnostic messages to report. Possible values are:
.RS
.TP 15
0
Tells the auto\-parallelizer to report no diagnostic information.
.TP 15
1
Tells the auto\-parallelizer to report diagnostic messages for loops successfully auto\-parallelized. The compiler also issues a "LOOP AUTO\-PARALLELIZED" message for parallel loops.
.TP 15
2
Tells the auto\-parallelizer to report diagnostic messages for loops successfully and unsuccessfully auto\-parallelized. This is the default if \fIn\fR is not specified.
.TP 15
3
Tells the auto\-parallelizer to report the same diagnostic messages specified by 2 plus additional information about any proven or assumed dependencies inhibiting auto\-parallelization (reasons for not parallelizing).
.TP 15
4
Tells the compiler to generate a report that includes the information in level 3, but with a greater level of detail.
.TP 15
5
Tells the compiler to generate a report that includes the information in level 4, but with a greater level of detail.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No auto\-parallelizer messages are displayed.
.TP
\fBDescription:\fR 
.PP
This option controls the diagnostic information reported by the auto\-parallelizer (parallel optimizer). To use this option, you must also specify option [Q]parallel.
.NL
.PP
If this option is specified on the command line, the report is sent to stdout.
.NL
.PP
.B NOTE:
When option \-qopt\-report or /Qopt\-report is in effect, you get reports for all optimizer phases.  When you specify \-qopt\-report or /Qopt\-report along with a particular setting for option \-qopt\-report\-phase or /Qopt\-report\-phase, 
you suppress reports for the other phases.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-par\-runtime\-control[n]
.TP
.B
\-no\-par\-runtime\-control
.RS
.TP
Generates code to perform run\-time checks for loops that have symbolic loop bounds.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a  a value denoting what kind of runtime checking to perform. Possible values are:
.RS
.TP 15
0
Performs no runtime check based on auto\-parallelization. This is the same as specifying \-no\-par\-runtime\-control (Linux* OS and OS X*) or /Qpar\-runtime\-control\- (Windows* OS).
.TP 15
1
Generates runtime check code under conservative mode. This is the default if you do not specify \fIn\fR.
.TP 15
2
Generates runtime check code under heuristic mode.
.TP 15
3
Generates runtime check code under aggressive mode.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-no\-par\-runtime\-control 
.NL
The compiler uses default heuristics when checking loops.
.TP
\fBDescription:\fR 
.PP
This option generates code to perform run\-time checks for loops that have symbolic loop bounds. 
.NL
.PP
If the granularity of a loop is greater than the parallelization threshold, the loop will be executed in parallel.
.NL
.PP
If you do not specify this option, the compiler may not parallelize loops with symbolic loop bounds if the compile\-time granularity estimation of a loop can not ensure it is beneficial to parallelize the loop.
.NL
.PP
.B NOTE:
This option may behave differently on Intel(R) microprocessors than on non\-Intel microprocessors.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-par\-schedule\-keyword[=n]
.RS
.TP
Lets you specify a scheduling algorithm for loop iterations. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies the scheduling algorithm or tuning method. Possible values are:
.RS
.TP 15
auto
Lets the compiler or run\-time system determine the scheduling algorithm.
.TP 15
static
Divides iterations into contiguous pieces.
.TP 15
static\-balanced
Divides iterations into even\-sized chunks.
.TP 15
static\-steal
Divides iterations into even\-sized chunks, but allows threads to steal parts of chunks
from neighboring threads. 
.TP 15
dynamic
Gets a set of iterations dynamically.
.TP 15
guided
Specifies a minimum number of iterations.
.TP 15
guided\-analytical
Divides iterations by using exponential distribution or dynamic distribution. 
.TP 15
runtime
Defers the scheduling decision until run time.
.RE
.TP 18
\fIn\fR
.NL
Is the size of the chunk or the number of iterations for each chunk. This setting
can only be specified for static, dynamic, and guided. For more information, see
the descriptions of each keyword below. 
.TP
\fBDefault:\fR 
.TP 18
static\-balanced
.NL
Iterations are divided into even\-sized chunks and the chunks are assigned to the
threads in the team in a round\-robin fashion in the order of the thread number.
.TP
\fBDescription:\fR 
.PP
This option lets you specify a scheduling algorithm for loop iterations.
It specifies how iterations are to be divided among the threads of the team. 
.NL
.PP
This option is only useful when specified with option [Q]parallel.
.NL
.PP
This option affects performance tuning and can provide better performance during
auto\-parallelization. It does nothing if it is used with option \-qopenmp (Linux* OS and OS X*) or /Qopenmp (Windows* OS).
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
[Q]par\-schedule\-auto
.NL
Lets the compiler or run\-time system determine the scheduling algorithm. Any possible
mapping may occur for iterations to threads in the team.
.NL
.TP 18
[Q]par\-schedule\-static
.NL
Divides iterations into contiguous pieces (chunks) of size \fIn\fR. The chunks are assigned
to threads in the team in a round\-robin fashion in the order of the thread number.
Note that the last chunk to be assigned may have a smaller number of iterations.
.TP 18
If no \fIn\fR is specified, the iteration space is divided into chunks that are approximately
equal in size, and each thread is assigned at most one chunk.
.NL
.TP 18
[Q]par\-schedule\-static\-balanced
.NL
Divides iterations into even\-sized chunks. The chunks are assigned to the threads
in the team in a round\-robin fashion in the order of the thread number. 
.NL
.TP 18
[Q]par\-schedule\-static\-steal
.NL
Divides iterations into even\-sized chunks, but when a thread completes its chunk,
it can steal parts of chunks assigned to neighboring threads. 
.TP 18
Each thread keeps track
of L and U, which represent the lower and upper bounds of its chunks respectively.
Iterations are executed starting from the lower bound, and simultaneously, L is updated
to represent the new lower bound.
.NL
.TP 18
[Q]par\-schedule\-dynamic
.NL
Can be used to get a set of iterations dynamically. Assigns iterations to threads
in chunks as the threads request them. The thread executes the chunk of iterations,
then requests another chunk, until no chunks remain to be assigned.
.TP 18
As each thread finishes a piece of the iteration space, it dynamically gets the next
set of iterations. Each chunk contains \fIn\fR iterations, except for the last chunk to
be assigned, which may have fewer iterations. If no \fIn\fR is specified, the default is
1.
.NL
.TP 18
[Q]par\-schedule\-guided
.NL
Can be used to specify a minimum number of iterations. Assigns iterations to threads
in chunks as the threads request them. The thread executes the chunk of iterations,
then requests another chunk, until no chunks remain to be assigned. 
.TP 18
For a chunk of size 1, the size of each chunk is proportional to the number of unassigned
iterations divided by the number of threads, decreasing to 1.
.TP 18
For an \fIn\fR with value
\fIk\fR (greater than 1), the size of each chunk is determined in the same way with the
restriction that the chunks do not contain fewer than \fIk\fR iterations (except for the
last chunk to be assigned, which may have fewer than \fIk\fR iterations). If no \fIn\fR is specified,
the default is 1.
.NL
.TP 18
[Q]par\-schedule\-guided\-analytical
.NL
Divides iterations by using exponential distribution or dynamic distribution. The
method depends on run\-time implementation. Loop bounds are calculated with faster
synchronization and chunks are dynamically dispatched at run time by threads in the
team.
.NL
.TP 18
[Q]par\-schedule\-runtime
.NL
Defers the scheduling decision until run time. The scheduling algorithm and chunk
size are then taken from the setting of environment variable OMP_SCHEDULE.
.NL
.PP
.B NOTE:
This option may behave differently on Intel(R) microprocessors than on non\-Intel microprocessors.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-par\-threshold[n]
.RS
.TP
Sets a threshold for the auto\-parallelization of loops. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an integer whose value is the threshold for the auto\-parallelization of loops. Possible values are 0 through 100.
.IP
If \fIn\fR is 0, loops get auto\-parallelized always, regardless of computation work volume.
.IP
If \fIn\fR is 100, loops get auto\-parallelized when performance gains are predicted based on the compiler analysis data. Loops get auto\-parallelized only if profitable parallel execution is almost certain.
.IP
The intermediate 1 to 99 values represent the percentage probability for profitable speed\-up. For example, \fIn\fR=50 directs the compiler to parallelize only if there is a 50% probability of the code speeding up if executed in parallel.
.TP
\fBDefault:\fR 
.TP 18
\-par\-threshold100 
.NL
Loops get auto\-parallelized only if profitable parallel execution is almost certain. This is also the default if you do not specify \fIn\fR.
.TP
\fBDescription:\fR 
.PP
This option sets a threshold for the auto\-parallelization of loops based on the probability of profitable execution of the loop in parallel. To use this option, you must also specify option [Q]parallel.
.NL
.PP
This option is useful for loops whose computation work volume cannot be determined at compile\-time. The threshold is usually relevant when the loop trip count is unknown at compile\-time. 
.NL
.PP
The compiler applies a heuristic that tries to balance the overhead of creating multiple threads versus the amount of work available to be shared amongst the threads.
.NL
.PP
.B NOTE:
This option may behave differently on Intel(R) microprocessors than on non\-Intel microprocessors.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-pcn
.RS
.TP
Enables control of floating\-point significand precision.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the floating\-point significand precision. Possible values are:
.RS
.TP 15
32
Rounds the significand to 24 bits (single precision).
.TP 15
64
Rounds the significand to 53 bits (double precision).
.TP 15
80
Rounds the significand to 64 bits (extended precision).
.RE
.TP
\fBDefault:\fR 
.TP 18
\-pc80 
.NL
On Linux* and OS X* systems, the floating\-point significand is rounded to 64 bits. 
.TP
\fBDescription:\fR 
.PP
This option enables control of floating\-point significand precision.
.NL
.PP
Some floating\-point algorithms are sensitive to the accuracy of the significand, or fractional part of the floating\-point value. For example, iterative operations like division and finding the square root can run faster if you lower the precision with the this option.
.NL
.PP
Note that a change of the default precision control or rounding mode, for example, by using the [Q]pc32 option or by user intervention, may affect the results returned by some of the mathematical functions.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-pie
.TP
.B
\-no\-pie
.RS
.TP
Determines whether the compiler generates position\-independent code that will be linked into an executable.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
varies
.NL
On Linux* OS and on OS X* versions less than 10.7, the default is \-no\-pie. On OS X* 10.7 or greater, the default is \-pie.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler generates position\-independent code that will be linked into an executable. To enable generation of position\-independent code that will be linked into an executable, specify \-pie.
.NL
.PP
To disable generation of position\-independent code that will be linked into an executable, specify \-no\-pie.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prec\-div
.TP
.B
\-no\-prec\-div
.RS
.TP
Improves precision of floating\-point divides.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-prec\-div 
.NL
The compiler uses this method for floating\-point divides.
.TP
\fBDescription:\fR 
.PP
This option improves precision of floating\-point divides. It has a slight impact on speed.
.NL
.PP
With some optimizations, such as \-msse2 (Linux* OS) or /arch:SSE2 (Windows* OS), the compiler may change floating\-point division computations into multiplication by the reciprocal of the denominator. For example, A/B is computed as A * (1/B) to improve the speed of the computation.
.NL
.PP
However, sometimes the value produced by this transformation is not as accurate as full IEEE division. When it is important to have fully precise IEEE division, use this option to disable the floating\-point division\-to\-multiplication optimization. The result is more accurate, with some loss of performance.
.NL
.PP
If you specify \-no\-prec\-div (Linux* OS and OS X*) or /Qprec\-div\- (Windows* OS), it enables optimizations that give slightly less precise results than full IEEE division.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prec\-sqrt
.TP
.B
\-no\-prec\-sqrt
.RS
.TP
Improves precision of square root implementations.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-prec\-sqrt 
.NL
The compiler uses a faster but less precise implementation of square root.
.IP
However, the default is \-prec\-sqrt if any of the following options are specified: \-O0,  \-fltconsistency, or \-mp1 on Linux* and OS X* systems. 
.TP
\fBDescription:\fR 
.PP
This option improves precision of square root implementations. It has a slight impact on speed. 
.NL
.PP
This option inhibits any optimizations that can adversely affect the precision of a square root computation. The result is fully precise square root implementations, with some loss of performance.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-preprocess\-only
.RS
.TP
Causes the Fortran preprocessor to send output to a file.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Preprocessed source files are output to the compiler.
.TP
\fBDescription:\fR 
.PP
This option causes the Fortran preprocessor to send output to a file.
.NL
.PP
The source file is preprocessed by the Fortran preprocessor, and the result for each source file is output to a corresponding .i or .i90 file.
.NL
.PP
Note that the source file is not compiled.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-P
.NL
.RE
.TP
.B
\-print\-multi\-lib
.RS
.TP
Prints information about where system libraries should be found.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No information is printed unless the option is specified.
.TP
\fBDescription:\fR 
.PP
This option prints information about where system libraries should be found, but no compilation occurs. On Linux* systems, it is provided for compatibility with gcc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-data\-order (L*X only)
.TP
.B
\-no\-prof\-data\-order (L*X only)
.RS
.TP
Enables or disables data ordering if profiling information is enabled.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-prof\-data\-order 
.NL
Data ordering is disabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables data ordering if profiling information is enabled. It controls the use of profiling information to order static program data items. 
.NL
.PP
For this option to be effective, you must do the following:
.NL
.IP \(bu 2
For instrumentation compilation, you must specify option [Q]prof\-gen setting globdata. 
.IP \(bu 2
For feedback compilation, you must specify the [Q]prof\-use option. You must not use multi\-file optimization by specifying options such as [Q]ipo or [Q]ipo\-c. 
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-dir dir
.RS
.TP
Specifies a directory for profiling information output files.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the name of the directory. You can specify a relative pathname or an absolute pathname.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Profiling output files are placed in the directory where the program is compiled.
.TP
\fBDescription:\fR 
.PP
This option specifies a directory for profiling information output files (*.dyn and *.dpi). The specified directory must already exist.
.NL
.PP
You should specify this option using the same directory name for both instrumentation and feedback compilations. If you move the .dyn files, you need to specify the new path.
.NL
.PP
Option /Qprof\-dir is equivalent to option /Qcov\-dir. If you specify both options, the last option specified on the command line takes precedence.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-file filename
.RS
.TP
Specifies an alternate file name for the profiling summary files.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the profiling summary file.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The profiling summary files have the file name pgopti.*
.TP
\fBDescription:\fR 
.PP
This option specifies an alternate file name for the profiling summary files. The \fIfilename\fR is used as the base name for files created by different profiling passes.
.NL
.PP
If you add this option to profmerge, the .dpi file will be named \fIfilename\fR.dpi instead of pgopti.dpi.
.NL
.PP
If you specify this option with option [Q]prof\-use, the .dpi file will be named \fIfilename\fR.dpi instead of pgopti.dpi.
.NL
.PP
Option /Qprof\-file is equivalent to option /Qcov\-file. If you specify both options, the last option specified on the command line takes precedence.
.NL
.PP
.B NOTE:
When you use option [Q]prof\-file, you can only specify a file name. If you want to specify a path (relative or absolute) for \fIfilename\fR, you must also use option [Q]prof\-dir.  
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-func\-groups (L*X only)
.TP
.B
\-no\-prof\-func\-groups (L*X only)
.RS
.TP
Enables or disables function grouping if profiling information is enabled.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-prof\-func\-groups
.NL
Function grouping is disabled. 
.TP
\fBDescription:\fR 
.PP
This option enables or disables function grouping if profiling information is enabled.
.NL
.PP
A "function grouping" is a profiling optimization in which entire routines are placed either in the cold code section or the hot code section.
.NL
.PP
If profiling information is enabled by option \-prof\-use, option \-prof\-func\-groups is set and function grouping is enabled. However, if you explicitly enable \-prof\-func\-order, function ordering is performed instead of function grouping.
.NL
.PP
If you want to disable function grouping when profiling information is enabled, specify \-no\-prof\-func\-groups.
.NL
.PP
To set the hotness threshold for function grouping, use option \-prof\-hotness\-threshold.
.NL
.RE
.TP
.B
\-prof\-func\-order (L*X only)
.TP
.B
\-no\-prof\-func\-order (L*X only)
.RS
.TP
Enables or disables function ordering if profiling information is enabled.
.NL
.TP
\fBArchitecture Restrictions:\fR  Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-prof\-func\-order 
.NL
Function ordering is disabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables function ordering if profiling information is enabled.
.NL
.PP
For this option to be effective, you must do the following:
.NL
.IP \(bu 2
For instrumentation compilation, you must specify option [Q]prof\-gen setting srcpos. 
.IP \(bu 2
For feedback compilation, you must specify [Q]prof\-use. You must not use multi\-file optimization by specifying options such as [Q]ipo or [Q]ipo\-c. 
.PP
If you enable profiling information by specifying option [Q]prof\-use, option [Q]prof\-func\-groups is set and function grouping is enabled.   However, if you explicitly enable the [Q]prof\-func\-order  option, function ordering is performed instead of function grouping.
.NL
.PP
On Linux* systems, this option is only available for Linux linker 2.15.94.0.1, or later.
.NL
.PP
To set the hotness threshold for function grouping and function ordering, use option [Q]prof\-hotness\-threshold.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-gen[=keyword[, keyword],...]
.TP
.B
\-no\-prof\-gen
.RS
.TP
Produces an instrumented object file that can be used in profile guided optimization.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies details for the instrumented file. Possible values are:
.RS
.TP 15
default
Produces an instrumented object file. This is the same as specifying the [Q]prof\-gen option with no keyword.
.TP 15
srcpos
Produces an instrumented object file that includes extra source position information. 
.TP 15
globdata
Produces an instrumented object file that includes information for global data layout.
.TP 15
[no]threadsafe
Produces an instrumented object file that includes the collection of PGO data on applications that use a high level of parallelism. If [Q]prof\-gen is specified with no keyword, the default is nothreadsafe. 
.IP
On Intel(R) 64 architecture targeting Intel(R) MIC Architecture, the only valid mode is keyword threadsafe.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-no\-prof\-gen
.NL
Profile generation is disabled.
.TP
\fBDescription:\fR 
.PP
This option produces an instrumented object file that can be used in profile guided optimization. It gets the execution count of each basic block.
.NL
.PP
You can specify more than one setting for [Q]prof\-gen. For example, you can specify the following:
.NL
.PP
–prof\-gen=scrpos \-prof\-gen=threadsafe (Linux* OS and OS X*) 
\-prof\-gen=scrpos, threadsafe (this is equivalent to the above)
.PP
.PP
/Qprof\-gen:scrpos /Qprof\-gen:threadsafe (Windows* OS)
/Qprof\-gen:scrpos, threadsafe (this is equivalent to the above)
.PP
.PP
If you specify keyword srcpos or globdata, a static profile information file (.spi) is created. These settings may increase the time needed to do a parallel build using \-prof\-gen, because of contention writing the .spi file.
.NL
.PP
These options are used in phase 1 of the Profile Guided Optimizer (PGO) to instruct the compiler to produce instrumented code in your object files in preparation for instrumented execution.
.NL
.PP
When the [Q]prof\-gen option is used to produce an instrumented
binary file for profile generation, some optimizations are
disabled.  Those optimizations are not disabled for any
subsequent profile\-guided compilation with option [Q]prof\-use that makes use of the
generated profiles.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-hotness\-threshold=n (L*X only)
.RS
.TP
Lets you set the hotness threshold for function grouping and function ordering. 
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the hotness threshold. \fIn\fR is a percentage having a value between 0 and 100 inclusive. If you specify 0, there will be no hotness threshold setting in effect for function grouping and function ordering.  
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler\[aq]s default hotness threshold setting of 10 percent is in effect for function grouping and function ordering.  
.TP
\fBDescription:\fR 
.PP
This option lets you set the hotness threshold for function grouping and function ordering.
.NL
.PP
The "hotness threshold" is the percentage of functions in the application that should be placed in the application\[aq]s hot region.  The hot region is the most frequently executed part of the application.  By grouping these functions together into one hot region, they have a greater probability of remaining resident in the instruction cache. This can enhance the application\[aq]s performance.
.NL
.PP
For this option to take effect, you must specify option  [Q]prof\-use and one of the following:
.NL
.IP \(bu 2
On Linux systems: \-prof\-func\-groups or \-prof\-func\-order
.IP \(bu 2
On Windows systems: /Qprof\-func\-order
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-src\-dir
.TP
.B
\-no\-prof\-src\-dir
.RS
.TP
Determines whether directory information of the source file under compilation is considered when looking up profile data records.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
prof\-src\-dir
.NL
Directory information is used when looking up profile data records in the .dpi file.
.TP
\fBDescription:\fR 
.PP
This option determines whether directory information of the source file under compilation is considered when looking up profile data records in the .dpi file. To use this option, you must also specify the [Q]prof\-use option. 
.NL
.PP
If the option is enabled, directory information is considered when looking up the profile data records within the .dpi file. You can specify directory information by using one of the following options:
.NL
.IP \(bu 2
Linux and OS X:  \-prof\-src\-root or  \-prof\-src\-root\-cwd
.IP \(bu 2
Windows:  /Qprof\-src\-root or /Qprof\-src\-root\-cwd
.PP
If the option is disabled, directory information is ignored and only the name of the file is used to find the profile data record.
.NL
.PP
Note that option [Q]prof\-src\-dir controls how the names of the user\[aq]s source files get represented within the .dyn or .dpi files.  Option [Q]prof\-dir specifies the location of the .dyn or the .dpi files.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-src\-root=dir
.RS
.TP
Lets you use relative directory paths when looking up profile data and specifies a directory as the base.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the base for the relative paths.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The setting of relevant options determines the path used when looking up profile data records.
.TP
\fBDescription:\fR 
.PP
This option lets you use relative directory paths when looking up profile data in .dpi files. It lets you specify a directory as the base. The paths are relative to a base directory specified during the [Q]prof\-gen compilation phase. 
.NL
.PP
This option is available during the following phases of compilation:
.NL
.IP \(bu 2
Linux OS and OS X: \-prof\-gen and \-prof\-use phases
.IP \(bu 2
Windows OS: /Qprof\-gen and /Qprof\-use phases
.PP
When this option is specified during the [Q]prof\-gen phase, it stores information into the .dyn or .dpi file. Then, when .dyn files are merged together or the .dpi file is loaded, only the directory information below the root directory is used for forming the lookup key. 
.NL
.PP
When this option is specified during the [Q]prof\-use phase, it specifies a root directory that replaces the root directory specified at the [Q]prof\-gen phase for forming the lookup keys.
.NL
.PP
To be effective, this option or option [Q]prof\-src\-root\-cwd must be specified during the [Q]prof\-gen phase. In addition, if one of these options is not specified, absolute paths are used in the .dpi file.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-src\-root\-cwd
.RS
.TP
Lets you use relative directory paths when looking up profile data and specifies the current working directory as the base.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The setting of relevant options determines the path used when looking up profile data records.
.TP
\fBDescription:\fR 
.PP
This option lets you use relative directory paths when looking up profile data in .dpi files. It specifies the current working directory as the base. To use this option, you must also specify option [Q]prof\-use. 
.NL
.PP
This option is available during the following phases of compilation:
.NL
.IP \(bu 2
Linux OS and OS X: \-prof\-gen and \-prof\-use phases
.IP \(bu 2
Windows OS: /Qprof\-gen and /Qprof\-use phases
.PP
When this option is specified during the [Q]prof\-gen phase, it stores information into the .dyn or .dpi file. Then, when .dyn files are merged together or the .dpi file is loaded, only the directory information below the root directory is used for forming the lookup key. 
.NL
.PP
When this option is specified during the [Q]prof\-use phase, it specifies a root directory that replaces the root directory specified at the [Q]prof\-gen phase for forming the lookup keys.
.NL
.PP
To be effective, this option or option [Q]prof\-src\-root must be specified during the [Q]prof\-gen phase. In addition, if one of these options is not specified, absolute paths are used in the .dpi file.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-use[=keyword]
.TP
.B
\-no\-prof\-use
.RS
.TP
Enables the use of profiling information during optimization.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies additional instructions. Possible values are:
.RS
.TP 15
weighted
Tells the profmerge utility to apply a weighting to the .dyn file values when creating the .dpi file to normalize the data counts when the training runs have differentexecution durations.  This argument only has an effect when the compiler invokes the profmerge utility to create the .dpi file. This argument does not have an effect if the .dpi file was previously created without weighting.
.TP 15
[no]merge
Enables or disables automatic invocation of the profmerge utility. The default is merge. Note that you cannot specify both weighted and nomerge.  If you try to specify both values, a warning will be displayed and nomerge takes precedence.
.TP 15
default
Enables the use of profiling information during optimization. The profmerge utility is invoked by default. This value is the same as specifying [Q]prof\-use with no argument.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-no\-prof\-use
.NL
Profiling information is not used during optimization.
.TP
\fBDescription:\fR 
.PP
This option enables the use of profiling information (including function splitting and function grouping) during optimization. It enables option /Qfnsplit (Windows* OS).
.NL
.PP
This option instructs the compiler to produce a profile\-optimized executable and it merges available profiling output files into a pgopti.dpi file.
.NL
.PP
Note that there is no way to turn off function grouping if you enable it using this option.
.NL
.PP
To set the hotness threshold for function grouping and function ordering, use option [Q]prof\-hotness\-threshold.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-value\-profiling[=keyword]
.RS
.TP
Controls which values are value profiled.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Controls which type of value profiling is performed. Possible values are:
.RS
.TP 15
none
Prevents all types of value profiling.
.TP 15
nodivide
Prevents value profiling of non\-compile time constants used in division or remainder operations.
.TP 15
noindcall
Prevents value profiling of function addresses at indirect call sites.
.TP 15
all
Enables all types of value profiling.
.RE
.PP
You can specify more than one keyword, but they must be separated by commas.
.NL
.TP
\fBDefault:\fR 
.TP 18
all
.NL
All value profile types are enabled and value profiling is performed.
.TP
\fBDescription:\fR 
.PP
This option controls which features are value
profiled.
.NL
.PP
If this option is specified with option
[Q]prof\-gen, it turns
off instrumentation of operations of the specified type. This also
prevents feedback of values for the operations.
.NL
.PP
If this option is specified with option
[Q]prof\-use, it turns
off feedback of values collected of the specified type.
.NL
.PP
If you specify level 2 or higher for option\-qopt\-report (Linux* OS and OS X*) or /Qopt\-report (Windows* OS), the value profiling
specialization information will be reported within the PGO
optimization report.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-profile\-functions
.RS
.TP
Inserts instrumentation calls at a function\[aq]s entry and exit points.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No instrumentation calls are inserted at a function\[aq]s entry and exit points.
.TP
\fBDescription:\fR 
.PP
This option inserts instrumentation calls
at a function\[aq]s entry and exit points within
a single\-threaded application to collect
the cycles spent within the function to produce
reports that can help in identifying code
hotspots.
.NL
.PP
When the instrumented application is run, this
option causes the generation of a loop_prof_funcs_<name>.dump
file, where <name> is a timestamp for the
run. 
.NL
.PP
The same data values are also dumped into the file
loop_prof_<name>.xml for use with the data viewer application,
unless you turn off the output format by setting the environment
variable INTEL_LOOP_PROF_XML_DUMP to 0.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-profile\-loops=keyword
.RS
.TP
Inserts instrumentation calls at a function\[aq]s entry and exit points, and before and after instrumentable loops.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies which type of loops should have instrumentation.  Possible values are:
.RS
.TP 15
inner
Inserts instrumentation before and after inner loops.
.TP 15
outer
Inserts instrumentation before and after outer loops.
.TP 15
all
Inserts instrumentation before and after all loops.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No instrumentation calls are inserted at a function\[aq]s entry and exit points, or before and after instrumentable loop.
.TP
\fBDescription:\fR 
.PP
This option inserts instrumentation calls
at a function\[aq]s entry and exit points within
a single\-threaded application.  For unthreaded applications, it also inserts instrumentation before and after instrumentable loops of the type listed in \fIkeyword\fR.
.NL
.PP
When the instrumented application is run, this
option causes the generation of a loop_prof_funcs_<name>.dump
file and a loop_prof_funcs_<name>.dump file, where <name> is a timestamp for the
run. 
.NL
.PP
The same timestamp is used for the loop file and function file.  This identifies that the loop data and function data were from the same program run. 
.NL
.PP
The same data values are also dumped into the file
loop_prof_<name>.xml for use with the data viewer application,
unless you turn off the output format by setting the environment
variable INTEL_LOOP_PROF_XML_DUMP to 0.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-profile\-loops\-report[=n]
.RS
.TP
Controls the level of detail for the data collected when instrumentation occurs before and after certain loops.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a value denoting the level of detail  to report. Possible values are:
.RS
.TP 15
1
Reports the cycle counts on entry and exits of loops. This is the default if \fIn\fR is not specified.
.TP 15
2
Reports the level 1 default details, but also includes the loop min/max and average loop iteration counts. 
.IP
To collect the loop iteration counts, additional instrumentation is inserted. This can increase overhead in the instrumented application and slow performance.
.RE
.TP
\fBDefault:\fR 
.TP 18
1
.NL
The report shows the cycle counts on entry and exits of loops.
.TP
\fBDescription:\fR 
.PP
This option controls the level of detail for the data collected when instrumentation occurs before and after certain loops. To use this option, you must also specify option [Q]profile\-loops. 
.NL
.PP
The report appears in file loop_prof_loops_<name>.dump, where <name> is a timestamp value for the run. The columns listed in the report will be based on the level of detail that was selected during instrumentation. 
.NL
.PP
It is recommended that the same report level be used for all files that are instrumented for the application. If different files of the application were instrumented with different levels, the report will contain all the columns of the highest detail level, but with default values for unavailable fields for files that were instrumented at lower levels. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-pthread
.RS
.TP
Tells the compiler to use pthreads library for multithreading support. This is a deprecated option. The replacement option is \-reentrancy threaded.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not use pthreads library for multithreading support.
.TP
\fBDescription:\fR 
.PP
Tells the compiler to use pthreads library for multithreading support.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-reentrancy threaded
.NL
.RE
.TP
.B
\-Qinstalldir
.RS
.TP
Specifies the root directory where the compiler installation was performed.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the root directory where the installation was performed.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The default root directory for compiler installation is searched for the compiler.
.TP
\fBDescription:\fR 
.PP
This option specifies the root directory where the compiler installation was performed. It is useful if you want to use a different compiler or if you did not use the compilervars shell script to set your environment variables. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Qlocation,string,dir
.RS
.TP
Specifies the directory for supporting tools.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIstring\fR
.NL
Is the name of the tool.
.TP 18
\fIdir\fR
.NL
Is the directory (path) where the tool is located.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler looks for tools in a default area.
.TP
\fBDescription:\fR 
.PP
This option specifies the directory for supporting tools.
.NL
.PP
\fIstring\fR can be any of the following:
.NL
.IP \(bu 2
f \- Indicates the Intel(R) Fortran compiler.
.IP \(bu 2
fpp (or cpp) \- Indicates the Intel(R) Fortran preprocessor.
.IP \(bu 2
asm \- Indicates the assembler.
.IP \(bu 2
link \- Indicates the linker.
.IP \(bu 2
prof \- Indicates the profiler.
.IP \(bu 2
On Windows* systems, the following is also available:
.RS
.IP \(bu 2
masm \- Indicates the Microsoft assembler.
.RE
.IP \(bu 2
On Linux* and OS X* systems, the following are also available: 
.RS
.IP \(bu 2
as \- Indicates the assembler.
.IP \(bu 2
gas \- Indicates the GNU assembler. This setting is for Linux* only.
.IP \(bu 2
ld \- Indicates the loader.
.IP \(bu 2
gld \- Indicates the GNU loader. This setting is for Linux* only.
.IP \(bu 2
lib \- Indicates an additional library.
.IP \(bu 2
crt \- Indicates the crt%.o files linked into executables to contain the place to start execution.
.RE
.PP
On Windows and OS X* systems, you can also specify a tool command name. 
.NL
.PP
The following shows an example on OS X* systems:
.NL
.PP
\-Qlocation,ld,/usr/bin               ! This tells the driver to use /usr/bin/ld for the loader
\-Qlocation,ld,/usr/bin/gld           ! This tells the driver to use /usr/bin/gld as the loader
.PP
.PP
The following shows an example on Windows* systems:
.NL
.PP
/Qlocation,link,”c:\Program Files\tools\”            ! This tells the driver to use c:\Program Files\tools\link.exe for the loader
/Qlocation,link,”c:\Program Files\tools\my_link.exe” ! This tells the driver to use c:\Program Files\tools\my_link.exe as the loader
.PP
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qoffload[=keyword] (L*X only)
.TP
.B
\-qno\-offload (L*X only)
.RS
.TP
Lets you specify the mode for offloading or tell the compiler to ignore language constructs for offloading. This option only applies to Intel(R) MIC Architecture.  Option \-q[no\-]offload is the replacement option for \-[no\-]offload, which is deprecated.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the mode for offloading or it disables offloading. Possible values are:
.RS
.TP 15
none
Tells the compiler to ignore language
constructs for offloading. Warnings are issued by the compiler. This is equivalent to the negative form of
the option.
.TP 15
mandatory
Specifies that offloading is mandatory (required). If the target is not available, one of the following occurs:
.RS
.IP \(bu 2
If no STATUS clause is specified for the OFFLOAD directive, the program fails with an error message.
.IP \(bu 2
If the STATUS clause is specified, the program continues execution on the CPU.
.RE
.TP 15
optional
Specifies that offloading is optional (requested). If the target is not available, the program is executed on the CPU, not the target.
.RE
.TP
\fBDefault:\fR 
.TP 18
mandatory
.NL
The compiler recognizes language constructs for offloading if they are specified. If option \-qoffload  (Linux*) or /Qoffload (Windows*) is specified with no \fIkeyword\fR, the default is mandatory.
.TP
\fBDescription:\fR 
.PP
This option lets you specify the mode for
offloading or tell the compiler to
ignore language constructs for offloading.
.NL
.PP
Option \-q[no\-]offload is the replacement option for \-[no\-]offload, which is deprecated.
.NL
.PP
If no \-qoffload (Linux*) or /Qoffload (Windows*) option appears on the command line, then OFFLOAD directives are processed and:
.NL
.IP \(bu 2
The MANDATORY or OPTIONAL clauses are obeyed if present
.IP \(bu 2
If no MANDATORY or OPTIONAL clause is present, the offload is mandatory
.PP
If any of the following appears on the command line, then OFFLOAD directives are ignored:
.NL
.IP \(bu 2
Linux* OS: \-qoffload=none or \-qno\-offload
.IP \(bu 2
Windows* OS: /offload:none or /Qoffload\-
.PP
However, OpenMP* directives for coprocessor control (for example, !$OMP TARGET) are recognized if the [Q]openmp option is specified, regardless of whether or not OFFLOAD directives are recognized or ignored.
.NL
.PP
If \fIkeyword\fR mandatory or optional appears for [Q]offload, then OFFLOAD directives are processed and:
.NL
.IP \(bu 2
The MANDATORY or OPTIONAL clauses are obeyed, regardless of the \-qoffload  (Linux*) or /Qoffload (Windows*) \fIkeyword\fR
.IP \(bu 2
If no MANDATORY or OPTIONAL clause is present, then the \-qoffload  (Linux*) or /Qoffload (Windows*) \fIkeyword\fR  is obeyed
.PP
If the STATUS clause is specified for an OFFLOAD directive, it affects run\-time behavior.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qoffload\-attribute\-target=target\-name (L*X only)
.RS
.TP
Causes the compiler to flag procedures and  data objects in the source file with the offload attribute target(mic).  This option only applies to Intel(R) MIC Architecture.   Option \-qoffload\-attribute\-target is the replacement option for \-offload\-attribute\-target, which is deprecated.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fItarget\-name\fR
.NL
Is a specific target. The only supported value for this argument is mic. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not flag procedures and data objects in the source file with the offload attribute target(mic).
.TP
\fBDescription:\fR 
.PP
This option causes the compiler to flag procedures and data objects in the source file with the offload attribute target(mic).
.NL
.PP
This option is similar to using the required individual directive
ATTRIBUTES OFFLOAD:MIC to set the attribute target(mic) for all
procedures and data objects in the source file.
.NL
.PP
Individual directive ATTRIBUTES OFFLOAD:MIC  embedded in the source takes precedence over this option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qoffload\-option,target,tool,"option\-list" (L*X only)
.RS
.TP
Lets you explicitly specify options to be used for the specified target and tool. This option only applies to Intel(R) MIC Architecture.  Option \-qoffload\-option is the replacement option for \-offload\-option, which is deprecated.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fItarget\fR
.NL
Is the target architecture. The only supported value for this argument is mic.
.TP 18
\fItool\fR
.NL
Is the tool that the \fIoption\-list\fR is associated with.  It can be one of the following values: ld, link, as, or compiler.
.IP
ld is the linker tool on Linux* OS; link is the linker tool on Windows* OS.
.TP 18
\fIoption\-list\fR
.NL
Is one or more options that are specific to the tool.  The quotation mark delimiters are required. Each  option in the \fIoption\-list\fR must be separated by a space. 
.IP
For tool compiler, use compiler\-specific options; for tool ld, use linker\-specific options; for tool as, use assembler\-specific options. 
The options for the tools always use the Linux form even when compiling on Windows.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not pass additional options to the separate tools on the target architecture.
.TP
\fBDescription:\fR 
.PP
This option lets you explicitly specify options to be used for the specified target and tool. It can be specified multiple times on the command line.
.NL
.PP
When building a heterogeneous application, the driver passes all compiler options specified on the command\-line to the host compilation and only certain options to the offload compilation. To see a list of options passed to the offload compilation, specify option watch=mic\-cmd.
.NL
.PP
If you want to pass additional options to the offload compilation, or you would like to override the command line options passed to offload compilation, you must use option \-qoffload\-option (Linux*) or /Qoffload\-option (Windows*) to specify the additional or overriding options.
.NL
.PP
.B NOTE:
If you specify the options I, L, D, or U with the option \-qoffload\-option (Linux*) or /Qoffload\-option (Windows*), they override any other I, L, D, and U options that are automatically passed from host to offload compilation.
.PP
To achieve the overriding effect, the I, L, D, and U options specified using \-qoffload\-option (Linux*) or /Qoffload\-option (Windows*) are placed ahead of the I, L, D, and U options automatically copied over from the host compilation. All other options specified using \-qoffload\-option (Linux*) or /Qoffload\-option (Windows*) are placed after the options copied over from host to offload compilation.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopenmp
.TP
.B
\-qno\-openmp
.RS
.TP
Enables the parallelizer to generate multi\-threaded code based on OpenMP* directives. Option \-qopenmp is the replacement option for \-openmp, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No OpenMP* multi\-threaded code is generated by the compiler.
.TP
\fBDescription:\fR 
.PP
This option enables the parallelizer to generate multi\-threaded code based on OpenMP* directives. The code can be executed in parallel on both uniprocessor and multiprocessor systems. 
.NL
.PP
If you use this option, multithreaded libraries are used, but option fpp is not automatically invoked.
.NL
.PP
This option sets option automatic.
.NL
.PP
This option works with any optimization level. Specifying no optimization (\-O0 on Linux* OS or /Od on Windows* OS) helps to debug OpenMP applications.
.NL
.PP
To ensure that a threadsafe and/or reentrant run\-time library is linked and correctly initialized, option \-qopenmp (Linux* and OS X*) or /Qopenmp (Windows*) should also be used for the link step and for the compilation of the main routine.
.NL
.PP
.B NOTE:
On OS X* systems, when you enable OpenMP* API, you must also set the DYLD_LIBRARY_PATH environment variable within Xcode* or an error will be displayed.
.PP
.B NOTE:
Options that use OpenMP* API are available for both Intel(R) microprocessors and non\-Intel microprocessors, but these options may perform additional optimizations on Intel(R) microprocessors than they perform on non\-Intel microprocessors.  The list of major, user\-visible OpenMP constructs and features that may perform differently on Intel(R) microprocessors versus non\-Intel microprocessors include: locks (internal and user visible), the SINGLE construct, barriers (explicit and implicit), parallel loop scheduling, reductions, memory allocation, thread affinity, and binding.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-fopenmp
.NL
.RE
.TP
.B
\-qopenmp\-lib=type
.RS
.TP
Lets you specify an OpenMP* run\-time library to use for linking. Option \-qopenmp\-lib is the replacement option for \-openmp\-lib, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fItype\fR
.NL
Specifies the type of library to use; it implies compatibility levels. Currently, the only possible value is:
.RS
.TP 15
compat
Tells the compiler to use the compatibility OpenMP* run\-time library (libiomp). This setting provides compatibility with object files created using Microsoft* and GNU* compilers.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopenmp\-lib=compat 
.NL
The compiler uses the compatibility OpenMP* run\-time library (libiomp).
.TP
\fBDescription:\fR 
.PP
This option lets you specify an OpenMP* run\-time library to use for linking.
.NL
.PP
The compatibility OpenMP run\-time libraries are compatible with object files created using the Microsoft* OpenMP run\-time library (vcomp) or the GNU OpenMP run\-time library (libgomp).
.NL
.PP
To use the compatibility OpenMP run\-time library, compile and link your application using the compat setting for option \-qopenmp\-lib (Linux* and OS X*) or /Qopenmp\-lib (Windows*). To use this option, you must also specify one of the following compiler options:
.NL
.IP \(bu 2
Linux* OS: \-qopenmp  or \-qopenmp\-stubs
.IP \(bu 2
Windows* OS: /Qopenmp or /Qopenmp\-stubs
.PP
On Windows* systems, the compatibility OpenMP* run\-time library lets you combine OpenMP* object files compiled with the Microsoft* C/C++ compiler with OpenMP* object files compiled with the Intel(R) C, Intel(R) C++, or Intel(R) Fortran compilers. The linking phase results in a single, coherent copy of the run\-time library.
.NL
.PP
On Linux* systems, the compatibility Intel OpenMP* run\-time library lets you combine OpenMP* object files compiled with the GNU* gcc or gfortran compilers with similar OpenMP* object files compiled with the Intel(R) C, Intel(R) C++, or Intel(R) Fortran compilers. The linking phase results in a single, coherent copy of the run\-time library.
.NL
.PP
You cannot link object files generated by the Intel(R) Fortran compiler to object files compiled by the GNU Fortran compiler, regardless of the presence or absence of the [Q]openmp compiler option. This is because the Fortran run\-time libraries are incompatible.
.NL
.PP
.B NOTE:
The compatibility OpenMP run\-time library is not compatible with object files created using versions of the Intel compilers earlier than 10.0.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopenmp\-link=library
.RS
.TP
Controls whether the compiler links to static or dynamic OpenMP* run\-time libraries.  Option \-qopenmp\-link is the replacement option for \-openmp\-link. Both options are deprecated. There is no replacement option.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIlibrary\fR
.NL
Specifies the OpenMP library to use. Possible values are:
.RS
.TP 15
static
Tells the compiler to link to static OpenMP run\-time libraries. Note that static OpenMP libraries are deprecated.
.TP 15
dynamic
Tells the compiler to link to dynamic OpenMP run\-time libraries.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopenmp\-link=dynamic
.NL
The compiler links to dynamic OpenMP* run\-time libraries. However, if Linux* OS option \-static is specified, the compiler links to static OpenMP run\-time libraries.
.TP
\fBDescription:\fR 
.PP
This option controls whether the compiler links to static or dynamic OpenMP* run\-time libraries.
.NL
.PP
To link to the static OpenMP run\-time library (RTL) and create a purely static executable, you must specify \-qopenmp\-link=static. However, we strongly recommend you use the default setting, \-qopenmp\-link=dynamic.
.NL
.PP
.B NOTE:
Compiler options \-static\-intel and \-shared\-intel (Linux* OS and OS X*) have no effect on which OpenMP run\-time library is linked. 
.PP
.B NOTE:
On Linux* systems, \-qopenmp\-link=dynamic
cannot be used in conjunction with option \-static. If you try to specify both options together, an error will be displayed.
.PP
.B NOTE:
On Linux systems, the OpenMP runtime library depends on using libpthread and libc (libgcc when compiled with gcc). Libpthread and libc (libgcc) must both be static or both be dynamic. If both libpthread and libc (libgcc) are static, then the static version of the OpenMP runtime should be used. If both libpthread and libc (libgcc) are dynamic, then either the static or dynamic version of the OpenMP runtime may be used.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopenmp\-offload (L*X only)
.TP
.B
\-qno\-openmp\-offload (L*X only)
.RS
.TP
Enables or disables OpenMP* offloading compilation for the TARGET directives. This option only applies to Intel(R) MIC Architecture. Option \-qopenmp\-offload is the replacement option for \-openmp\-offload, which is deprecated.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qno\-openmp\-offload
.NL
OpenMP* offloading compilation is disabled. However, if option \-qopenmp (Linux* and OS X*) or 
/Qopenmp
(Windows*) is specified, the default is ON and OpenMP offloading compilation is enabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables OpenMP*
offloading compilation for the TARGET directives.
.NL
.PP
You can use this option if you want to enable
or disable the offloading feature with no impact on other OpenMP
features. In this case, no OpenMP runtime library is needed to link
and the compiler does not need to generate OpenMP runtime
initialization code.
.NL
.PP
If you specify this option with the \-qopenmp (Linux* and OS X*) or /Qopenmp (Windows*) 
option, it can impact other OpenMP features.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopenmp\-report[=n]
.RS
.TP
Controls the OpenMP* parallelizer\[aq]s level of diagnostic messages. Option \-qopenmp\-report is the replacement option for \-openmp\-report.  Both options are deprecated. The replacement options for this kind of report are \-qopt\-report \-qopt\-report\-phase=openmp (Linux* and OS X*) and /Qopt\-report /Qopt\-report\-phase:openmp (Windows*).  
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the level of diagnostic messages to display. Possible values are:
.RS
.TP 15
0
No diagnostic messages are displayed.
.TP 15
1
Diagnostic messages are displayed indicating loops, regions, and sections successfully parallelized.
.TP 15
2
The same diagnostic messages are displayed that are specified by 1.  In addition, the following are displayed: diagnostic messages indicating successful handling of MASTER constructs, SINGLE constructs, CRITICAL constructs, ORDERED constructs, ATOMIC directives, and so forth. This is the default if \fIn\fR is not specified.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No OpenMP* parallelizer  messages are displayed.
.TP
\fBDescription:\fR 
.PP
This option controls the OpenMP* parallelizer\[aq]s level of diagnostic messages. To use this option, you must also specify the \-qopenmp (Linux* and OS X*) or /Qopenmp (Windows*) option.
.NL
.PP
If this option is specified on the command line, the report is sent to stdout. 
.NL
.PP
.B NOTE:
When option \-qopt\-report or /Qopt\-report is in effect, you get reports for all optimizer phases.  When you specify \-qopt\-report or /Qopt\-report along with a particular setting for option \-qopt\-report\-phase or /Qopt\-report\-phase, 
you suppress reports for the other phases.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopenmp\-simd (L*X only)
.TP
.B
\-qno\-openmp\-simd (L*X only)
.RS
.TP
Enables or disables OpenMP* SIMD compilation. Option \-qopenmp\-simd is the replacement option for \-openmp\-simd, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qno\-openmp\-simd
.NL
OpenMP* SIMD compilation is disabled. However, if option \-qopenmp (Linux*) or /Qopenmp (Windows*) is specified, the default is ON and OpenMP SIMD compilation is enabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables OpenMP* SIMD
compilation.
.NL
.PP
You can use this option if you want to enable
or disable the SIMD support with no impact on other OpenMP
features. In this case, no OpenMP runtime library is needed to link
and the compiler does not need to generate OpenMP runtime
initialization code.
.NL
.PP
If you specify this option with the \-qopenmp (Linux*) or /Qopenmp (Windows*)
option, it can impact other OpenMP features.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopenmp\-stubs
.RS
.TP
Enables compilation of OpenMP* programs in sequential mode. Option \-qopenmp\-stubs is the replacement option for \-openmp\-stubs, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The library of OpenMP* function stubs is not linked.
.TP
\fBDescription:\fR 
.PP
This option enables compilation of OpenMP* programs in sequential mode. The OpenMP directives are ignored and a stub OpenMP library is linked. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopenmp\-threadprivate=type (L*X only)
.RS
.TP
Lets you specify an OpenMP* threadprivate implementation. Option \-qopenmp\-threadprivate is the replacement option for \-openmp\-threadprivate, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fItype\fR
.NL
Specifies the type of threadprivate implementation. Possible values are:
.RS
.TP 15
legacy
Tells the compiler to use the legacy OpenMP* threadprivate implementation used in the previous releases of the Intel(R) compiler. This setting does not provide compatibility with the implementation used by other compilers.  
.TP 15
compat
Tells the compiler to use the compatibility OpenMP* threadprivate implementation  based on applying the thread\-local attribute to each threadprivate variable. This setting provides compatibility with the implementation provided by the Microsoft* and GNU* compilers.  
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopenmp\-threadprivate=legacy 
.NL
The compiler uses the legacy OpenMP* threadprivate implementation used in the previous releases of the Intel compiler. 
.TP
\fBDescription:\fR 
.PP
This option lets you specify an OpenMP* threadprivate implementation.
.NL
.PP
The threadprivate implementation of the legacy OpenMP run\-time library may not be compatible with object files created using OpenMP run\-time libraries supported in other compilers.
.NL
.PP
To use this option, you must also specify one of the following compiler options: 
.NL
.IP \(bu 2
Linux* OS: \-qopenmp or \-qopenmp\-stubs
.IP \(bu 2
Windows* OS: /Qopenmp or /Qopenmp\-stubs
.PP
The value specified for this option is independent of the value used for the \-qopenmp\-lib (Linux*) or /Qopenmp\-lib (Windows*) option.
.NL
.PP
.B NOTE:
On Windows* OS, if you specify option /Qopenmp\-threadprivate:compat, the compiler does not generate threadsafe code for common blocks in an !$OMP THREADPRIVATE directive unless at least one element in the common block is explicitly initialized. For more information, see the article titled: /Qopenmp\-threadprivate:compat doesn\[aq]t work with uninitialized threadprivate common blocks, which is located in http://intel.ly/1aHhsjc
.PP
.B NOTE:
On OS X* systems, legacy is the only type of threadprivate supported.  Option \-qopenmp\-threadprivate
is not recognized by the compiler.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-args\-in\-regs[=keyword]
.RS
.TP
Determines whether calls to routines are optimized by passing arguments in registers instead of on the stack. Option \-qopt\-args\-in\-regs is the replacement option for \-opt\-args\-in\-regs, which is deprecated.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on IA\-32 architecture
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies whether the optimization should be performed 
and under what conditions.
Possible values are:
.RS
.TP 15
none
The optimization is not performed. No arguments
are passed in registers. They are put on the stack.
.TP 15
seen
Causes arguments
to be passed in registers when they are passed to routines whose definition can be seen in the same compilation unit.
.TP 15
all
Causes arguments
to be passed in registers, whether they are passed to routines whose definition can be seen in the same compilation unit, or not. This value is only available on Linux* systems.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopt\-args\-in\-regs=seen
.NL
Arguments
are passed in registers when they are passed to routines whose
definition is seen in the same compilation unit.
.TP
\fBDescription:\fR 
.PP
This option determines whether calls to
routines are optimized by passing arguments
in registers instead of on the stack. It also indicates the conditions when the optimization
will be performed.
.NL
.PP
This option can improve performance for
Application Binary Interfaces (ABIs) that
require arguments
to be passed in memory and compiled without
interprocedural optimization (IPO).
.NL
.PP
Note that on Linux* systems, if all is specified, a small
overhead may be paid when calling "unseen" routines that have not
been compiled with the same option. This is because the call will
need to go through a "thunk" to ensure that arguments
are placed back on the stack where the callee
expects them.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-assume\-safe\-padding (L*X only)
.TP
.B
\-qno\-opt\-assume\-safe\-padding (L*X only)
.RS
.TP
Determines whether the compiler assumes that variables and dynamically allocated memory are padded past the end of the object. This option only applies to Intel(R) MIC Architecture. Option \-qopt\-assume\-safe\-padding is the replacement option for \-opt\-assume\-safe\-padding, which is deprecated.
.NL
.TP
\fBArchitecture Restrictions:\fR  Only available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qno\-opt\-assume\-safe\-padding 
.NL
The compiler will not assume that variables and dynamically allocated memory are padded past the end of the object. It will adhere to the sizes specified in your program. 
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler assumes that variables and dynamically allocated memory are padded past the end of the object.
.NL
.PP
When you specify option \-qopt\-assume\-safe\-padding (Linux*) or /Qopt\-assume\-safe\-padding (Windows*), the compiler assumes that variables and dynamically allocated memory are padded. This means that code can access up to 64 bytes beyond what is specified in your program. 
.NL
.PP
The compiler does not add any padding for static and automatic objects when this option is used, but it assumes that code can access up to 64 bytes beyond the end of the object, wherever the object appears in the program. To satisfy this assumption, you must increase the size of static and automatic objects in your program when you use this option.
.NL
.PP
This option may improve performance of memory operations.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-block\-factor=n
.RS
.TP
Lets you specify a loop blocking factor. Option \-qopt\-block\-factor is the replacement option for \-opt\-block\-factor, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the blocking factor. It must be an integer. The compiler may ignore the blocking factor if the value is 0 or 1. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses default heuristics for loop blocking.
.TP
\fBDescription:\fR 
.PP
This option lets you specify a loop blocking factor.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-dynamic\-align
.TP
.B
\-qno\-opt\-dynamic\-align
.RS
.TP
Enables or disables dynamic data alignment optimizations. Option \-qopt\-dynamic\-align is the replacement option for \-opt\-dynamic\-align, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qopt\-dynamic\-align 
.NL
The compiler may generate code dynamically dependent on alignment. It may do optimizations based on data location for the best performance. The result of execution on some algorithms may depend on data layout.
.TP
\fBDescription:\fR 
.PP
This option enables or disables dynamic data alignment optimizations. 
.NL
.PP
If you specify \-qno\-opt\-dynamic\-align or /Qopt\-dynamic\-align\-, the compiler generates no code dynamically dependent on alignment. It will not do any optimizations based on data location and results will depend on the data values themselves.
.NL
.PP
When you specify \-qopt\-dynamic\-align or /Qopt\-dynamic\-align, the compiler may implement conditional optimizations based on dynamic alignment of the input data.  These dynamic alignment optimizations may result in different bitwise results for aligned and unaligned data with the same values. 
.NL
.PP
Dynamic alignment optimizations can improve the performance of vectorized code, especially for long trip count loops. Disabling such optimizations can decrease performance, but it may improve bitwise reproducibility of results, factoring out data location from possible sources of discrepancy.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-gather\-scatter\-unroll=n (L*X only)
.TP
.B
\-qno\-opt\-gather\-scatter\-unroll (L*X only)
.RS
.TP
Lets you specify an alternative loop unroll sequence for gather and scatter loops on Intel(R) MIC Architecture. This option only applies to Intel(R) MIC Architecture.  Option \-qopt\-gather\-scatter\-unroll is the replacement option for \-opt\-gather\-scatter\-unroll, which is deprecated.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the unroll factor for the gather and scatter loops. It must be an integer between 0 and 8. If you specify value 0 for \fIn\fR, it is the same as specifying the negative form of the option.
.TP
\fBDefault:\fR 
.TP 18
\-qno\-opt\-gather\-scatter\-unroll or /Qopt\-gather\-scatter\-unroll
.NL
The compiler uses default heuristics when unrolling gather and scatter loops.
.TP
\fBDescription:\fR 
.PP
This option lets you specify an alternative
loop unroll sequence for gather and scatter loops on Intel(R) MIC
Architecture.
.NL
.PP
This option may improve performance of
gather/scatter operations.
.NL
.PP
The value of \fIn\fR that provides the best
performance is data\-dependent.
.NL
.PP
In cases where the gather/scatter operation
accesses data in a small number of cache\-lines (such as 1 or 2),
the default sequence (using a small value for \fIn\fR) works best.
In cases where each individual data item falls in a different
cache\-line, it may be better to use a large value for
\fIn\fR.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-jump\-tables=keyword
.TP
.B
\-qno\-opt\-jump\-tables
.RS
.TP
Enables or disables generation of jump tables for switch statements. Option \-qopt\-jump\-tables is the replacement option for \-opt\-jump\-tables, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Is the instruction for generating jump tables. Possible values are: 
.RS
.TP 15
never
Tells the compiler to never generate jump tables. All switch statements are implemented as chains of if\-then\-elses. This is the same as specifying \-qno\-opt\-jump\-tables (Linux* OS and OS X*) or /Qopt\-jump\-tables\- (Windows* OS).
.TP 15
default
The compiler uses default heuristics to determine when to generate jump tables. 
.TP 15
large
Tells the compiler to generate jump tables up to a certain pre\-defined size (64K entries). 
.TP 15
n
Must be an integer. Tells the compiler to generate jump tables up to \fIn\fR entries in size. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopt\-jump\-tables=default 
.NL
The compiler uses default heuristics to determine when to generate jump tables for switch statements.
.TP
\fBDescription:\fR 
.PP
This option enables or disables generation of jump tables for switch statements. When the option is enabled, it may improve performance for programs with large switch statements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-malloc\-options=n
.RS
.TP
Lets you specify an alternate algorithm for malloc(). Option \-qopt\-malloc\-options is the replacement option for \-opt\-malloc\-options, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Specifies the algorithm to use for malloc(). Possible values are:
.RS
.TP 15
0
Tells the compiler to use the default algorithm for malloc(). This is the default.
.TP 15
1
Causes the following adjustments to the malloc() algorithm: M_MMAP_MAX=2 and M_TRIM_THRESHOLD=0x10000000.
.TP 15
2
Causes the following adjustments to the malloc() algorithm: M_MMAP_MAX=2 and M_TRIM_THRESHOLD=0x40000000.
.TP 15
3
Causes the following adjustments to the malloc() algorithm: M_MMAP_MAX=0 and M_TRIM_THRESHOLD=\-1.
.TP 15
4
Causes the following adjustments to the malloc() algorithm: M_MMAP_MAX=0, M_TRIM_THRESHOLD=\-1, M_TOP_PAD=4096.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopt\-malloc\-options=0
.NL
The compiler uses the default algorithm when malloc() is called. No call is made to mallopt().
.TP
\fBDescription:\fR 
.PP
This option lets you specify an alternate algorithm for malloc().
.NL
.PP
If you specify a non\-zero value for \fIn\fR, it causes alternate configuration parameters to be set for how malloc() allocates and frees memory. It tells the compiler to insert calls to mallopt() to adjust these parameters to malloc() for dynamic memory allocation. This may improve speed.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-matmul (L*X only)
.TP
.B
\-qno\-opt\-matmul (L*X only)
.RS
.TP
Enables or disables a compiler\-generated Matrix Multiply (matmul)
library call. Option \-qopt\-matmul is the replacement option for \-opt\-matmul, which is deprecated.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qno\-opt\-matmul 
.NL
The matmul library call optimization does not occur unless this option is enabled or certain other compiler options are specified (see below).
.TP
\fBDescription:\fR 
.PP
This option enables or disables a compiler\-generated Matrix Multiply (MATMUL)
library call.
.NL
.PP
The \-qopt\-matmul (Linux* OS) and /Qopt\-matmul (Windows* OS) options tell the compiler to identify matrix multiplication loop nests (if any) and replace them with a matmul library call for improved performance.  The resulting executable may get additional performance gain on Intel(R) microprocessors than on non\-Intel microprocessors. 
.NL
.PP
This option is enabled by default if options O3
and [Q]parallel are specified.
To disable this optimization, specify \-qno\-opt\-matmul or
/Qopt\-matmul\-.
.NL
.PP
This option has no effect unless option O2 or
higher is set.
.NL
.PP
.B NOTE:
Many routines in the MATMUL library are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-mem\-layout\-trans[=n]
.TP
.B
\-qno\-opt\-mem\-layout\-trans
.RS
.TP
Controls the level of memory layout transformations performed by the compiler. Option \-qopt\-mem\-layout\-trans is the replacement option for \-opt\-mem\-layout\-trans, which is deprecated.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the level of memory layout transformations. Possible values are:
.RS
.TP 15
0
Disables memory layout transformations. This is the same as specifying \-qno\-opt\-mem\-layout\-trans (Linux* OS and OS X*) or /Qopt\-mem\-layout\-trans\- (Windows* OS).
.TP 15
1
Enables basic memory layout transformations.
.TP 15
2
Enables more memory layout transformations. This is the same as specifying \-qopt\-mem\-layout\-trans (Linux* OS and OS X*) or /Qopt\-mem\-layout\-trans (Windows* OS) with no argument.
.TP 15
3
Enables aggressive memory layout transformations. You should only use this setting if your system has more than 4GB of physical memory per core.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopt\-mem\-layout\-trans=2
.NL
The compiler performs moderate memory layout transformations.
.TP
\fBDescription:\fR 
.PP
This option controls the level of memory layout transformations performed by the compiler. This option can improve cache reuse and cache locality.
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-multi\-version\-aggressive
.TP
.B
\-qno\-opt\-multi\-version\-aggressive
.RS
.TP
Tells the compiler to use aggressive multi\-versioning to check for pointer aliasing and scalar replacement.  Option \-qopt\-multi\-version\-aggressive is the replacement option for \-opt\-multi\-version\-aggressive, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qno\-opt\-multi\-version\-aggressive 
.NL
The compiler uses default heuristics when checking for pointer aliasing and scalar replacement.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to use aggressive multi\-versioning to check for pointer aliasing and scalar replacement. This option may improve performance.
.NL
.PP
The performance can be affected by certain options, such as /arch or /Qx (Windows OS) or \-m or \-x (Linux OS and OS X).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-prefetch[=n]
.TP
.B
\-qno\-opt\-prefetch
.RS
.TP
Enables or disables  prefetch insertion optimization. Option \-qopt\-prefetch is the replacement option for \-opt\-prefetch, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the level of software prefetching optimization desired. Possible values are:
.RS
.TP 15
0
Disables software prefetching. This is the same as specifying \-qno\-opt\-prefetch (Linux* OS and OS X*) or /Qopt\-prefetch\- (Windows* OS).  
.TP 15
1 to 4
Enables different levels of software prefetching. If you do not specify a value for \fIn\fR, the default is 2. Use lower values to reduce the amount of prefetching.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qno\-opt\-prefetch 
.NL
Prefetch insertion optimization is disabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables prefetch insertion optimization. The goal of prefetching is to reduce cache misses by providing hints to the processor about when data should be loaded into the cache.
.NL
.PP
On Intel(R) 64 architecture targeting Intel(R) MIC Architecture, option \-qopt\-prefetch=3 (Linux* OS and OS X*)  and /Qopt\-prefetch:3 (Windows* OS) are enabled by default if option O2 or higher is set. To disable prefetching at these optimization levels, specify option \-qno\-opt\-prefetch or /Qopt\-prefetch\-.
.NL
.PP
This option enables prefetching when higher optimization levels are specified.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-prefetch\-distance=n1[, n2] (L*X only)
.RS
.TP
Specifies the prefetch distance to be used for compiler\-generated prefetches inside loops. This option only applies to Intel(R) MIC Architecture. Option \-qopt\-prefetch\-distance is the replacement option for \-opt\-prefetch\-distance, which is deprecated.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIn1, n2\fR
.NL
Is the prefetch distance in terms of the number of (possibly\-vectorized) iterations. Possible values are non\-negative numbers >=0.  
.IP
\fIn2\fR is optional. 
.IP
\fIn1\fR = 0 turns off all compiler issued prefetches from memory to L2. \fIn2 \fR= 0 turns off all compiler issued prefetches from L2 to L1. If \fIn2\fR is specified and \fIn1\fR > 0,  \fIn1\fR should be >= \fIn2\fR.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses default heuristics to determine the prefetch distance.
.TP
\fBDescription:\fR 
.PP
This option specifies the prefetch distance to
be used for compiler\-generated prefetches inside loops. The unit (\fIn1\fR and optionally \fIn2\fR) is the number of iterations. If the loop is
vectorized by the compiler, the unit is the number of vectorized
iterations.
.NL
.PP
The value of \fIn1\fR will be used as the
distance for prefetches from memory to L2 (for example, the vprefetch1
instruction). If \fIn2\fR is specified, it will be used as the
distance for prefetches from L2 to L1 (for example, the vprefetch0
instruction).
.NL
.PP
This option is ignored if option \-qopt\-prefetch=0 (Linux* OS) or  /Qopt\-prefetch:0 (Windows* OS) is
specified.  On Intel(R) MIC Architecture, \-qopt\-prefetch=3 and /Qopt\-prefetch:3 is the  default at option levels O2 and above.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-ra\-region\-strategy[=keyword]
.RS
.TP
Selects the method that the register allocator uses to partition each routine into regions. Option \-qopt\-ra\-region\-strategy is the replacement option for \-opt\-ra\-region\-strategy, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Is the method used for partitioning. Possible values are: 
.RS
.TP 15
routine
Creates a single region for each routine.
.TP 15
block
Partitions each routine into one region per basic block.
.TP 15
trace
Partitions each routine into one region per trace.
.TP 15
region
Partitions each routine into one region per loop.
.TP 15
default
The compiler determines which method is used for partitioning.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopt\-ra\-region\-strategy=default 
.NL
The compiler determines which method is used for partitioning. This is also the default if keyword is not specified.
.TP
\fBDescription:\fR 
.PP
This option selects the method that the register allocator uses to partition each routine into regions.
.NL
.PP
When setting default is in effect, the compiler attempts to optimize the tradeoff between compile\-time performance and generated code performance.
.NL
.PP
This option is only relevant when optimizations are enabled (option O1 or higher).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-report[=n]
.RS
.TP
Tells the compiler to generate an optimization report. Option \-qopt\-report is the replacement option for \-opt\-report, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
(Optional) Indicates the level of detail in the report. You can specify values 0 through 5. If you specify zero, no report is generated.  For levels \fIn\fR=1 through \fIn\fR=5, each level includes all the information of the previous level, as well as potentially some additional information. Level 5 produces the greatest level of detail. If you do not specify \fIn\fR, the default is level 2, which produces a medium level of detail.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate a collection of optimization report files, one per object; this is the same output produced by option
\-qopt\-report\-per\-object (Linux* OS and OS X*) or /Qopt\-report\-per\-object (Windows* OS). 
.NL
.PP
If you prefer another form of output, you can specify option \-qopt\-report\-file or /Qopt\-report\-file.
.NL
.PP
If you specify a level (\fIn\fR) higher than 5, a warning will be displayed and you will get a level 5 report.
.NL
.PP
When optimization reporting is enabled, the default is \-qopt\-report\-phase=all (Linux* OS and OS X*) or /Qopt\-report\-phase:all (Windows* OS).
.NL
.PP
For a description of the information that each \fIn\fR level provides, see the Example section in option \-opt\-report\-phase (Linux* OS and OS X*) and /Qopt\-report\-phase (Windows* OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-report\-embed
.TP
.B
\-qno\-opt\-report\-embed
.RS
.TP
Determines whether special loop information annotations will be embedded in the object file and/or the assembly file when it is generated. Option \-qopt\-report\-embed is the replacement option for \-opt\-report\-embed, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
When an assembly file is being generated, special loop information annotations will not be embedded in the assembly file. 
.IP
However, if option \-g (Linux* OS and OS X*) or /Zi (Windows* OS) is specified, special loop information annotations will be embedded in the assembly file unless option \-qno\-opt\-report\-embed (Linux OS and OS X) or /Qopt\-report\-embed\- (Windows OS) is specified.
.TP
\fBDescription:\fR 
.PP
This option determines whether special loop information annotations will be embedded in the object file and/or the assembly file when it is generated. Specify the positive form of the option to include the annotations in the assembly file.
.NL
.PP
If an object file (or executable) is being generated, the annotations will be embedded in the object file (or executable). 
.NL
.PP
If you use this option, you do not have to specify option \-qopt\-report (Linux* OS and OS X*) or /Qopt\-report (Windows* OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-report\-file=keyword
.RS
.TP
Specifies that the output for the optimization report goes to a file, stderr, or stdout.  Option \-qopt\-report\-file is the replacement option for \-opt\-report\-file, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the output for the report.
You can specify one of the following:
.RS
.TP 15
filename
Specifies the name of the file where the output should go.
.TP 15
stderr
Indicates that the output should go to stderr.
.TP 15
stdout
Indicates that the output should go to stdout.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated.
.TP
\fBDescription:\fR 
.PP
This option specifies that the output for the optimization report goes to a file, stderr, or stdout. 
.NL
.PP
If you use this option, you do not have to specify option \-qopt\-report (Linux* OS and OS X*) or /Qopt\-report (Windows* OS).
.NL
.PP
When optimization reporting is enabled, the default is \-qopt\-report\-phase=all (Linux* OS and OS X*) or /Qopt\-report\-phase:all (Windows* OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-report\-filter=string
.RS
.TP
Tells the compiler to find the indicated parts of your application, and generate optimization reports for those parts of your application. Option \-qopt\-report\-filter is the replacement option for \-opt\-report\-filter, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIstring\fR
.NL
Is the information to search for. The \fIstring\fR must appear within quotes. It can take one or more of the following forms:
\fIfilename\fR\fIfilename\fR, \fIroutine\fR\fIfilename\fR, \fIrange\fR [, \fIrange\fR]...
\fIfilename\fR, \fIroutine\fR, \fIrange\fR
[, \fIrange\fR]...
.IP
If you specify more than one of the above forms in a string, a semicolon must appear between each form. If you specify more than one \fIrange\fR
in a string, a comma must appear between each \fIrange\fR. Optional blanks can follow each parameter in the forms above and they can also follow each form in a string.
.RS
.TP 15
\fIfilename\fR
Specifies the name of a file to be found. It
can include a path.
.IP
If you do not specify a path, the compiler
looks for the filename in the current working directory.
.TP 15
\fIroutine\fR
Specifies the name of a routine to be found.
You can include an identifying argument. 
.IP
The name, including any argument, must be enclosed in single quotes.
.IP
The compiler tries to uniquely identify the routine that corresponds to the specified routine name. 
.IP
It may select multiple routines to analyze, especially if more than one routine has the specified routine name, so the routine cannot be uniquely identified.
.TP 15
\fIrange\fR
Specifies a range of line numbers to be found in
the file or routine specified. The \fIrange\fR must be specified in
integers in the form:
.IP
\fIfirst_line_number\-last_line_number\fR
.IP
The hyphen between the line numbers is
required.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to find the indicated parts of your application, and generate optimization reports for those parts of your application.  Optimization reports will only be generated for the routines that contain the specified \fIstring\fR.
.NL
.PP
On Linux* OS and OS X*, if you specify both \-qopt\-report\-routine=string1 and \-qopt\-report\-filter=string2, it is treated as \-qopt\-report\-filter=string1;string2. On Windows* OS, if you specify both /Qopt\-report\-routines:string1 and /Qopt\-report\-filter:string2, it is treated as/Qopt\-report\-filter:string1;string2.
.NL
.PP
If you use this option, you do not have to specify option \-qopt\-report (Linux* OS and OS X*) or /Qopt\-report (Windows* OS).
.NL
.PP
When optimization reporting is enabled, the default is \-qopt\-report\-phase=all (Linux* OS and OS X*) or /Qopt\-report\-phase:all (Windows* OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-report\-format=keyword
.RS
.TP
Specifies the format for an optimization report. Option \-qopt\-report\-format is the replacement option for \-opt\-report\-format, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the format for the report.
You can specify one of the following:
.RS
.TP 15
text
Indicates that the report should be in text format.
.TP 15
vs
Indicates that the report should be in Visual Studio* (IDE) format.  The Visual Studio IDE uses the information to visualize the optimization report in the context of your program source code.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated.
.TP
\fBDescription:\fR 
.PP
This option specifies the format for an optimization report. If you use this option, you must specify either text or vs.
.NL
.PP
If you do not specify this option and another option causes an optimization report to be generated, the default format is text.
.NL
.PP
Specifying vs can change where the output goes in the following cases: 
.NL
.IP \(bu 2
If option \-qopt\-report\-file=filename (Linux* OS and OS X*) or /Qopt\-report\-file:filename (Windows* OS) is specified, output goes to the specified file.
.IP \(bu 2
If option \-qopt\-report\-file=stdout (Linux* OS and OS X*) or /Qopt\-report\-file:stdout (Windows* OS) is specified, output goes to stdout.
.IP \(bu 2
If option \-qopt\-report\-file=stderr (Linux* OS and OS X*) or /Qopt\-report\-file:stderr (Windows* OS) is specified, output goes to stderr.
.PP
If you use this option, you do not have to specify option \-qopt\-report (Linux* OS and OS X*) or /Qopt\-report (Windows* OS).
.NL
.PP
When optimization reporting is enabled, the default is \-qopt\-report\-phase=all (Linux* OS and OS X*) or /Qopt\-report\-phase:all (Windows* OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-report\-help
.RS
.TP
Displays the optimizer phases available for report generation and a short description of what is reported at each level. Option \-qopt\-report\-help is the replacement option for \-opt\-report\-help, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated.
.TP
\fBDescription:\fR 
.PP
This option displays the optimizer phases available for report generation using \-qopt\-report\-phase or /Qopt\-report\-phase, and a short description of what is reported at each level.  No compilation is performed.
.NL
.PP
To indicate where output should go, you can specify one of the following options:
.NL
.IP \(bu 2
\-qopt\-report\-file  (Linux* OS and OS X*) or /Qopt\-report\-file (Windows* OS)
.IP \(bu 2
\-qopt\-report\-per\-object (Linux* OS and OS X*) or /Qopt\-report\-per\-object (Windows* OS)
.PP
If you use this option, you do not have to specify option \-qopt\-report (Linux* OS and OS X*) or /Qopt\-report (Windows* OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-report\-names=keyword
.RS
.TP
Specifies whether mangled or unmangled names should appear in the optimization report.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the form for the names.
You can specify one of the following:
.RS
.TP 15
mangled
Indicates that the optimization report should contain mangled names.
.TP 15
unmangled
Indicates that the optimization report should contain unmangled names.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated.
.TP
\fBDescription:\fR 
.PP
This option specifies whether mangled or
unmangled names should appear in the optimization report. If you use this option, you must specify either
mangled or unmangled.
.NL
.PP
If this option is not specified, unmangled
names are used by default.
.NL
.PP
If you specify mangled, encoding (also known as
decoration) is added to names in the optimization report. This is
appropriate when you want to match annotations with the assembly listing.
.NL
.PP
If you specify unmangled, no encoding (or
decoration) is added to names in the optimization report. This is
appropriate when you want to match annotations with the source listing.
.NL
.PP
If you use this option, you do not have to
specify option \-qopt\-report (Linux* OS and OS X*) or /Qopt\-report (Windows* OS).
.NL
.PP
When optimization reporting is enabled, the default is \-qopt\-report\-phase=all (Linux* OS and OS X*) or /Qopt\-report\-phase:all (Windows* OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-report\-per\-object
.RS
.TP
Tells the compiler that optimization report information should be generated in a separate file for each object. Option \-qopt\-report\-per\-object is the replacement option for \-opt\-report\-per\-object, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler that optimization report information should be generated in a separate file for each object. 
.NL
.PP
If you specify this option for a single\-file Interprocedural Optimization (IPO) compilation, a file with a .optrpt extension is produced for every object file or assembly file that is generated by the compiler.    For a single file compilation, one file is produced for each of the multiple true objects in the compilation.  The names used are  ipo_out1.optprt, ipo_out2.optrpt, …ipo_outn.optrpt. 
.NL
.PP
The .optrpt files are written to the target directory of the compilation process.  If an object or assembly file is explicitly generated, the corresponding .optrpt file is written to the same directory where the object file is generated.  If the object file is just a temporary file and an executable is generated, the corresponding .optrpt files are placed in the directory in which the executable is placed.
.NL
.PP
If you use this option, you do not have to specify option \-qopt\-report (Linux* OS and OS X*) or /Qopt\-report (Windows* OS).
.NL
.PP
When optimization reporting is enabled, the default is \-qopt\-report\-phase=all (Linux* OS and OS X*) or /Qopt\-report\-phase:all (Windows* OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-report\-phase[=list]
.RS
.TP
Specifies one or more optimizer phases for which optimization reports are generated. Option \-qopt\-report\-phase is the replacement option for \-opt\-report\-phase, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIlist\fR
.NL
(Optional) Specifies one or more phases to generate reports for. If you specify more than one phase, they must be separated with commas. The values you can specify are:
.RS
.TP 15
cg
The phase for code generation
.TP 15
ipo
The phase for Interprocedural Optimization
.TP 15
loop
The phase for loop nest optimization
.TP 15
offload
The phase for Intel(R) MIC Architecture. 
This phase has no effect if option \-no\-qoffload or  option /Qoffload\- is specified.  
This phase only applies to Intel(R) MIC Architecture.
.TP 15
openmp
The phase for OpenMP
.TP 15
par
The phase for auto\-parallelization
.TP 15
pgo
The phase for Profile Guided Optimization
.TP 15
tcollect
The phase for trace collection
.TP 15
vec
The phase for vectorization
.TP 15
all
All optimizer phases. This is the default if you do not specify \fIlist\fR.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated.
.TP
\fBDescription:\fR 
.PP
This option specifies one or more optimizer phases for which optimization reports are generated.
.NL
.PP
Note that phase offload causes the compiler to print a report of the input or output of variables that the host sends to the offload target and variables that the host receives from the target.
.NL
.PP
For certain phases, you also need to specify other options:
.NL
.IP \(bu 2
If you specify phase par, you must also specify option [Q]parallel.
.IP \(bu 2
If you specify phase openmp, you must also specify option \-qopenmp (Linux* OS and OS X*) or /Qopenmp (Windows* OS).
.PP
To find all phase possibilities, specify option \-qopt\-report\-help (Linux* OS and OS X*) or /Qopt\-report\-help (Windows* OS).
.NL
.PP
If you use this option, you do not have to specify option \-qopt\-report (Linux* OS and OS X*) or /Qopt\-report (Windows* OS).
.NL
.PP
However, if you want to get more details for each phase, specify option \-qopt\-report (Linux* OS and OS X*) or /Qopt\-report  (Windows* OS) along with this option and indicate the level of detail you want by specifying an appropriate value for \fIn\fR. (See also the Example section below.)
.NL
.PP
When optimization reporting is enabled, the default is \-qopt\-report\-phase=all (Linux* OS and OS X*) or /Qopt\-report\-phase:all (Windows* OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-report\-routine=substring
.RS
.TP
Tells the compiler to generate an optimization report for each of the routines whose names contain the specified substring. Option \-qopt\-report\-routine is the replacement option for \-opt\-report\-routine, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIsubstring\fR
.NL
Is the text (string) to look for.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate an optimization report for each of the routines whose names contain the specified substring.
.NL
.PP
You can also specify a sequence of substrings separated by commas.  If you do this, the compiler will generate an optimization report for each of the routines whose name contains one or more of these substrings. 
.NL
.PP
If you use this option, you do not have to specify option \-qopt\-report (Linux* OS and OS X*) or /Qopt\-report (Windows* OS).
.NL
.PP
When optimization reporting is enabled, the default is \-qopt\-report\-phase=all (Linux* OS and OS X*) or /Qopt\-report\-phase:all (Windows* OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-streaming\-cache\-evict[=n] (L*X only)
.RS
.TP
Specifies the cache eviction level to be used by the compiler for streaming loads and stores. This option only applies to Intel(R) MIC Architecture. Option \-qopt\-streaming\-cache\-evict is the replacement option for \-opt\-streaming\-cache\-evict, which is deprecated.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a value denoting the cache eviction (clevict) level to use for streaming loads and stores. Possible values are:
.RS
.TP 15
0
Tells the compiler to use no cache eviction level.
.TP 15
1
Tells the compiler to use the L1 cache eviction level.
.TP 15
2
Tells the compiler to use the L2 cache eviction level.
.TP 15
3
Tells the compiler to use the L1 and L2 cache eviction level. This is the default of you do not specify \fIn\fR. 
.RE
.TP
\fBDefault:\fR 
.TP 18
2
.NL
The compiler uses the L2 cache eviction level.
.TP
\fBDescription:\fR 
.PP
This option specifies the cache eviction
(clevict) level to be used by the compiler for streaming loads and
stores.
.NL
.PP
Depending on the level used, the compiler will
generate clevict0 and/or clevict1 instructions that evict the
cache\-line (corresponding to the load or the store) from the
first\-level and second\-level caches. These
cache eviction instructions will be generated after performing the
corresponding load/store operation.
.NL
.PP
For more information on how to mark
loads/stores as streaming, see the description of the VECTOR NONTEMPORAL
directive.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-streaming\-stores =keyword
.RS
.TP
Enables generation of streaming stores for optimization. Option \-qopt\-streaming\-stores is the replacement option for \-opt\-streaming\-stores, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies whether streaming stores are generated. Possible values are:
.RS
.TP 15
always
Enables generation of streaming stores for optimization. The compiler optimizes under the assumption that the application is memory bound.
.TP 15
never
Disables generation of streaming stores for optimization. Normal stores are performed.
.TP 15
auto
Lets the compiler decide which instructions to use.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-qopt\-streaming\-stores=auto 
.NL
The compiler decides whether to use streaming stores or normal stores.
.TP
\fBDescription:\fR 
.PP
This option enables generation of streaming stores for optimization. This method stores data with instructions that use a non\-temporal buffer, which minimizes memory hierarchy pollution.
.NL
.PP
This option may be useful for applications that can benefit from streaming stores.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-subscript\-in\-range
.TP
.B
\-qno\-opt\-subscript\-in\-range
.RS
.TP
Determines whether the compiler assumes that there are no "large" integers being used or being computed inside loops. Option \-qopt\-subscript\-in\-range is the replacement option for \-opt\-subscript\-in\-range, which is deprecated.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-qno\-opt\-subscript\-in\-range 
.NL
The compiler assumes  there are "large" integers being used or being computed within loops.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler assumes that there are no "large" integers being used or being computed inside loops.
.NL
.PP
If you specify \-qopt\-subscript\-in\-range (Linux* OS and OS X*) or /Qopt\-subscript\-in\-range (Windows* OS), the compiler assumes that there are no "large" integers being used or being computed inside loops. A "large" integer is typically > 231. This feature can enable more loop transformations.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-qopt\-threads\-per\-core=n (L*X only)
.RS
.TP
Informs the compiler about the number of hardware threads per core that will be used for an application. This option only applies to Intel(R) MIC Architecture. Option \-qopt\-threads\-per\-core is the replacement option for \-opt\-threads\-per\-core, which is deprecated.
.NL
.TP
\fBArchitecture Restrictions:\fR Only available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the number of hardware threads per core that the compiler should assume that will be used while executing the application. Possible values are 1, 2, 3, or 4.
.TP
\fBDefault:\fR 
.TP 18
4
.NL
Four hardware threads per core are used for the application.
.TP
\fBDescription:\fR 
.PP
This option informs the
compiler about the number of hardware threads per core that
will be used for an application. This enables the
compiler to perform better code optimizations (such as instruction
scheduling).
.NL
.PP
You should choose a value for \fIn\fR that is
based on how many threads will be used per core while executing the
application. For example, if the application is parallelized using
OpenMP* API, use the value of \fIn\fR that uses the same number of
threads per core as the OpenMP* API affinity setting will use when
executing the application code on the Intel(R) Xeon Phi(TM)
coprocessor.
.NL
.PP
This option does not affect the number of
threads per core that will be used at run time.
.NL
.PP
Code compiled with this option can run
correctly on any (hardware\-supported) number of threads per
core.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Qoption,string,options
.RS
.TP
Passes options to a specified tool.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIstring\fR
.NL
Is the name of the tool.
.TP 18
\fIoptions\fR
.NL
Are one or more comma\-separated, valid options for the designated tool.
.IP
Note that certain tools may require that options appear within quotation marks (" ").
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No options are passed to tools.
.TP
\fBDescription:\fR 
.PP
This option passes options to a specified tool.
.NL
.PP
If an argument contains a space or tab character, you must enclose the entire argument in quotation marks (" "). You must separate multiple arguments with commas.
.NL
.PP
\fIstring\fR can be any of the following:
.NL
.IP \(bu 2
fpp (or cpp) \- Indicates the Intel(R) Fortran preprocessor.
.IP \(bu 2
asm \- Indicates the assembler.
.IP \(bu 2
link \- Indicates the linker.
.IP \(bu 2
prof \- Indicates the profiler.
.IP \(bu 2
On Windows* systems, the following is also available:
.RS
.IP \(bu 2
masm \- Indicates the Microsoft assembler.
.RE
.IP \(bu 2
On Linux* and OS X* systems, the following are also available:
.RS
.IP \(bu 2
as \- Indicates the assembler.
.IP \(bu 2
gas \- Indicates the GNU assembler.
.IP \(bu 2
ld \- Indicates the loader.
.IP \(bu 2
gld \- Indicates the GNU loader.
.IP \(bu 2
lib \- Indicates an additional library.
.IP \(bu 2
crt \- Indicates the crt%.o files linked into executables to contain the place to start execution.
.RE
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-rcd
.RS
.TP
Enables fast float\-to\-integer conversions.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Floating\-point values are truncated when a conversion to an integer is involved. 
.TP
\fBDescription:\fR 
.PP
This option enables fast float\-to\-integer conversions. It can improve the performance of code that requires floating\-point\-to\-integer conversions.
.NL
.PP
The system default floating\-point rounding mode is round\-to\-nearest. However, the Fortran language requires floating\-point values to be truncated when a conversion to an integer is involved. To do this, the compiler must change the rounding mode to truncation before each floating\-point\-to\-integer conversion and change it back afterwards.
.NL
.PP
This option disables the change to truncation of the rounding mode for all floating\-point calculations, including floating point\-to\-integer conversions. This option can improve performance, but floating\-point conversions to integer will not conform to Fortran semantics.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-real\-size size
.RS
.TP
Specifies the default KIND for real and complex declarations, constants, functions, and intrinsics.
.NL
.TP
\fBArguments:\fR 
.TP 18
size
.NL
Is the size for real and complex declarations, constants, functions, and intrinsics. Possible values are: 32, 64, or 128.
.TP
\fBDefault:\fR 
.TP 18
real\-size 32
.NL
Default real and complex declarations, constants, functions, and intrinsics are 4 bytes long (REAL(KIND=4) and COMPLEX(KIND=4)).
.TP
\fBDescription:\fR 
.PP
This option specifies the default size (in bits) for real and complex declarations, constants, functions, and intrinsics.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
real\-size 32
.NL
Makes default real and complex declarations, constants, functions, and intrinsics 4 bytes long. REAL declarations are treated as single precision REAL (REAL(KIND=4)) and COMPLEX declarations are treated as COMPLEX (COMPLEX(KIND=4)).  Real and complex constants of unspecified KIND are evaluated in single precision (KIND=4).
.NL
.TP 18
real\-size 64
.NL
Makes default real and complex declarations, constants, functions, and intrinsics 8 bytes long. REAL declarations are treated as DOUBLE PRECISION (REAL(KIND=8)) and COMPLEX declarations are treated as DOUBLE COMPLEX (COMPLEX(KIND=8)).  Real and complex constants of unspecified KIND are evaluated in double precision (KIND=8).
.NL
.TP 18
real\-size 128
.NL
Makes default real and complex declarations, constants, functions, and intrinsics 16 bytes long. REAL declarations are treated as extended precision REAL (REAL(KIND=16)); COMPLEX and DOUBLE COMPLEX declarations are treated as extended precision COMPLEX (COMPLEX(KIND=16)).  Real and complex constants of unspecified KIND are evaluated in extended precision (KIND=16).
.NL
.PP
These compiler options can affect the result type of intrinsic procedures, such as CMPLX, FLOAT, REAL, SNGL, and AIMAG, which normally produce single\-precision REAL or COMPLEX results. To prevent this effect, you must explicitly declare the kind type for arguments of such intrinsic procedures.
.NL
.PP
For example, if real\-size 64 is specified, the CMPLX intrinsic will produce a result of type DOUBLE COMPLEX (COMPLEX(KIND=8)). To prevent this, you must explicitly declare any real argument to be REAL(KIND=4), and any complex argument to be COMPLEX(KIND=4).
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
real\-size 64
.NL
Linux and OS X: \-r8, \-autodouble
.TP 18
real\-size 128
.NL
Linux and OS X: \-r16
.RE
.TP
.B
\-recursive
.TP
.B
\-norecursive
.RS
.TP
Tells the compiler that all routines should be compiled for possible recursive execution.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
norecursive
.NL
Routines are not compiled for possible recursive execution.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler that all routines should be compiled for possible recursive execution. It sets the automatic option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-reentrancy keyword
.TP
.B
\-noreentrancy
.RS
.TP
Tells the compiler to generate reentrant code to support a multithreaded application.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies details about the program. Possible values are:
.RS
.TP 15
none
Tells the run\-time library (RTL) that the program does not rely on threaded or asynchronous reentrancy. The RTL will not guard against such interrupts inside its own critical regions. This is the same as specifying noreentrancy.
.TP 15
async
Tells the run\-time library (RTL) that the program may contain asynchronous (AST) handlers that could call the RTL. This causes the RTL to guard against AST interrupts inside its own critical regions.
.TP 15
threaded
Tells the run\-time library (RTL) that the program is multithreaded, such as programs using the POSIX threads library. This causes the RTL to use thread locking to guard its own critical regions.
.RE
.TP
\fBDefault:\fR 
.TP 18
noreentrancy
.NL
The compiler does not generate reentrant code for applications.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate reentrant code to support a multithreaded application.
.NL
.PP
If you do not specify a keyword for reentrancy, it is the same as specifying reentrancy threaded.
.NL
.PP
To ensure that a threadsafe and/or reentrant run\-time library is linked and correctly initialized, option reentrancy threaded should also be used for the link step and for the compilation of the main routine.
.NL
.PP
Note that if option threads is specified, it sets option reentrancy threaded, since multithreaded code must be reentrant.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-S
.RS
.TP
Causes the compiler to compile to an assembly file only and not link.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Normal compilation and linking occur.
.TP
\fBDescription:\fR 
.PP
This option causes the compiler to compile to an assembly file only and not link.
.NL
.PP
On Linux* and OS X* systems, the assembly file name has a .s suffix. On Windows* systems, the assembly file name has an .asm suffix.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-safe\-cray\-ptr
.RS
.TP
Tells the compiler that Cray* pointers do not alias other variables.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler assumes that Cray pointers alias other variables.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler that Cray pointers do not alias (that is, do not specify sharing memory with) other variables.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-save
.RS
.TP
Causes variables to be placed in static memory.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-auto\-scalar 
.NL
Scalar variables of intrinsic types INTEGER, REAL, COMPLEX, and LOGICAL are allocated to the run\-time stack. Note that the default changes to  auto
if one of the following options are specified:
.RS
.IP \(bu 2
recursive
.IP \(bu 2
\-qopenmp
.RE
.TP
\fBDescription:\fR 
.PP
This option saves all variables in static allocation except local variables within a recursive routine and variables declared as AUTOMATIC.
.NL
.PP
If you want all local, non\-SAVEd variables to be allocated to the run\-time stack, specify option automatic.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-noauto
.NL
.RE
.TP
.B
\-save\-temps
.TP
.B
\-no\-save\-temps
.RS
.TP
Tells the compiler to save intermediate files created during compilation.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
Linux* OS and OS X*: \-no\-save\-temps 
.NL
On Linux and OS X systems, the compiler deletes intermediate files after compilation is completed. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to save intermediate files created during compilation. The names of the files saved are based on the name of the source file; the files are saved in the current working directory.
.NL
.PP
If option [Q]save\-temps is specified, the following occurs:
.NL
.IP \(bu 2
The object .o file (Linux OS and OS X) or .obj file (Windows OS) is saved.
.IP \(bu 2
The assembler .s file (Linux OS and OS X) or .asm file (Windows OS) is saved if you specified the [Q]use\-asm  option.
.IP \(bu 2
The .i or .i90 file is saved if the fpp preprocessor is invoked.
.PP
If \-no\-save\-temps is specified on Linux  or OS X systems, the following occurs:
.NL
.IP \(bu 2
The .o file is put into /tmp and deleted after calling ld.
.IP \(bu 2
The preprocessed file is not saved after it has been used by the compiler.
.PP
If /Qsave\-temps\- is specified on Windows systems, the following occurs:
.NL
.IP \(bu 2
The .obj file is not saved after the linker step.
.IP \(bu 2
The preprocessed file is not saved after it has been used by the compiler.
.PP
.B NOTE:
This option only saves intermediate files that are normally created during compilation.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-scalar\-rep
.TP
.B
\-no\-scalar\-rep
.RS
.TP
Enables or disables the scalar replacement optimization done by the compiler as part of loop transformations.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-scalar\-rep 
.NL
Scalar replacement is performed during loop transformation at optimization levels of O2 and above.
.TP
\fBDescription:\fR 
.PP
This option enables or disables the scalar replacement optimization done by the compiler as part of loop transformations. This option takes effect only if you specify an optimization level of O2 or higher.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-shared (L*X only)
.RS
.TP
Tells the compiler to produce a dynamic shared object instead of an executable.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler produces an executable.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to produce a dynamic shared object (DSO) instead of an executable. This includes linking in all libraries dynamically and passing \-shared to the linker.
.NL
.PP
You must specify option fpic for the compilation of each object file you want to include in the shared library.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-shared\-intel
.RS
.TP
Causes Intel\-provided libraries to be linked in dynamically.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Intel(R)
libraries are linked in statically, with the exception of Intel\[aq]s OpenMP* runtime support library, which is linked in dynamically.
.TP
\fBDescription:\fR 
.PP
This option causes Intel\-provided libraries to be linked in dynamically. It is the opposite of \-static\-intel.
.NL
.PP
If you specify option \-mcmodel=medium or \-mcmodel=large, it sets option \-shared\-intel. 
.NL
.PP
.B NOTE:
On OS X* systems, when you set "Intel Runtime Libraries" to "Dynamic", you must also set the DYLD_LIBRARY_PATH environment variable within Xcode* or an error will be displayed.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-shared\-libgcc (L*X only)
.RS
.TP
Links the GNU libgcc library dynamically.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-shared\-libgcc
.NL
The compiler links the libgcc library dynamically.
.TP
\fBDescription:\fR 
.PP
This option links the GNU libgcc library dynamically. It is the opposite of option static\-libgcc.
.NL
.PP
This option is useful when you want to override the default behavior of the static option, which causes all libraries to be linked statically.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-show=keyword[, keyword...]
.RS
.TP
Controls the contents of the listing generated when option list is specified.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the contents for the listing. Possible values are:
.RS
.TP 15
[no]include
Controls whether contents of files added with INCLUDE statements are included when a
listing is generated.
.TP 15
[no]map
Controls whether a symbol listing with a line number cross\-reference for each routine is 	included when a listing is generated.
.TP 15
[no]options
Controls whether a list of compiler options used for the compilation is included when a listing is generated.
.RE
.TP
\fBDefault:\fR 
.TP 18
include, map, and options
.NL
When a listing is generated, it contains the contents of INCLUDEd files, a symbol list with a line number cross reference, and a list of compiler options used.
.TP
\fBDescription:\fR 
.PP
This option controls the contents of the listing generated when option list is specified.
.NL
.PP
If you specify option show and do not specify option list, the option is ignored.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-simd
.TP
.B
\-no\-simd
.RS
.TP
Enables or disables compiler interpretation of SIMD  directives.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-simd 
.NL
SIMD directives are enabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables compiler interpretation of SIMD  directives.
.NL
.PP
To disable interpretation of SIMD directives, specify \-no\-simd (Linux* OS and OS X*) or /Qsimd\- (Windows* OS). Note that the compiler may still vectorize loops based on its own heuristics (leading to generation of SIMD instructions) even when \-no\-simd (or /Qsimd\-) is specified.
.NL
.PP
To disable all compiler vectorization, use the "\-no\-vec \-no\-simd" (Linux* OS and OS X*) or "/Qvec\- /Qsimd\-" (Windows* OS) compiler options. The option \-no\-vec (and /Qvec\-) disables all auto\-vectorization, including vectorization of array notation statements. The option \-no\-simd (and /Qsimd\-) disables vectorization of loops that have SIMD directives. 
.NL
.PP
.B NOTE:
If you specify option \-mia32 or option /arch:IA32, SIMD directives are disabled by default.  When you specify option \-mia32 or option /arch:IA32, vector instructions cannot be used. Therefore, you cannot explicitly enable SIMD directives by specifying option [Q]simd.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-sox[=keyword[,keyword]] (L*X only)
.TP
.B
\-no\-sox (L*X only)
.RS
.TP
Tells the compiler to save the compilation options and version number in the executable file.  It also lets you choose whether to include lists of certain routines.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Is the routine information to include. Possible values are:
.RS
.TP 15
inline
Includes a list of the routines that were inlined in each object.
.TP 15
profile
Includes a list of the routines that were compiled with the \-prof\-use option and for which the .dpi file had profile information, and an indication for each as to whether the profile information was USED (matched) or IGNORED (mismatched).
.RE
.TP
\fBDefault:\fR 
.TP 18
\-no\-sox
.NL
The compiler does not save these informational strings in the object file.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to save the compilation options and version number in the executable file.  It also lets you choose whether to include lists of certain routines.  The information is embedded as a string in each object file or assembly output.
.NL
.PP
If you specify option sox with no \fIkeyword\fR,
the compiler saves the compiler options and version number used in
the compilation of the objects that make up the
executable.
.NL
.PP
When you specify this option, the size of the executable on disk is
increased slightly. Each \fIkeyword\fR  you specify
increases the size of the executable.
When you link the object files into an executable file, the linker
places each of the information strings into the header of the
executable. It is then possible to use a tool, such as a strings
utility, to determine what options were used to build the
executable file.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-stand [keyword]
.TP
.B
\-nostand
.RS
.TP
Tells the compiler to issue compile\-time messages for nonstandard language elements.
.NL
.TP 18
keyword
.NL
Specifies the language to use as the standard. Possible values are:
.RS
.TP 15
none
Issues no messages for nonstandard language elements.
.TP 15
f90
Issues messages for language elements that are not standard in Fortran 90.
.TP 15
f95
Issues messages for language elements that are not standard in Fortran 95.
.TP 15
f03
Issues messages for language elements that are not standard in Fortran 2003.
.TP 15
f08
Issues messages for language elements that are not standard in Fortran 2008.
.RE
.TP
\fBDefault:\fR 
.TP 18
nostand
.NL
The compiler issues no messages for nonstandard language elements.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to issue compile\-time messages for nonstandard language elements.
.NL
.PP
If you do not specify a keyword for stand, it is the same as specifying stand f03.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
stand none
.NL
Tells the compiler to issue no messages for nonstandard language elements. This is the same as specifying nostand.
.NL
.TP 18
stand f90
.NL
Tells the compiler to issue messages for language elements that are not standard in Fortran 90.
.NL
.TP 18
stand f95
.NL
Tells the compiler to issue messages for language elements that are not standard in Fortran 95.
.NL
.TP 18
stand f03
.NL
Tells the compiler to issue messages for language elements that are not standard in Fortran 2003. This option is set if you specify warn stderrors.
.NL
.TP 18
stand f08
.NL
Tells the compiler to issue messages for language elements that are not standard in Fortran 2008.
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
stand none
.NL
Linux and OS X: \-nostand
.TP 18
stand f90
.NL
Linux and OS X: \-std90
.TP 18
stand f95
.NL
Linux and OS X: \-std95
.TP 18
stand f03
.NL
Linux and OS X: \-std03, \-stand, \-std
.TP 18
stand f08
.NL
Linux and OS X: \-std08
.RE
.TP
.B
\-standard\-semantics 
.RS
.TP
Determines whether the current Fortran Standard behavior of the compiler is fully implemented.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF 
.NL
The compiler implements most but not all of the current
Fortran Standard behavior. 
.TP
\fBDescription:\fR 
.PP
This option determines whether the current Fortran Standard behavior of the compiler is fully implemented.
.NL
.PP
If you specify option standard\-semantics, it enables all of the options that implement the current Fortran Standard behavior of the compiler, which is Fortran 2003 with some Fortran 2008 features.
.NL
.PP
Option standard\-semantics enables option fpscomp logicals and the following settings for option assume: byterecl,  fpe_summary,  ieee_fpe_flags (if the fp\-model option setting is strict or precise), minus0, noold_ldout_format, noold_maxminloc, noold_unit_star, noold_xor, protect_parens, realloc_lhs, std_intent_in, std_minus0_rounding1This is the default setting for this assume option., std_mod_proc_name, and std_value1.
.NL
.PP
If you specify option standard\-semantics and also explicitly specify a different setting for an affected assume option, the value you specify takes effect. It overrides the settings enabled by option standard\-semantics. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-static (L*X only)
.RS
.TP
Prevents linking with shared libraries.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
Linux: OFF  Windows: varies
.NL
On Linux* systems, the compiler links with shared libraries. On Windows* systems, /static is equivalent to option /MT.
.TP
\fBDescription:\fR 
.PP
This option prevents linking with shared libraries. It causes the executable to link all libraries statically.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-static\-intel
.RS
.TP
Causes Intel\-provided libraries to be linked in statically.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
ON
.NL
Intel
libraries are linked in statically, with the exception of Intel\[aq]s OpenMP* runtime support library, which is linked in dynamically.
.TP
\fBDescription:\fR 
.PP
This option causes Intel\-provided libraries to be linked in statically. It is the opposite of \-shared\-intel.
.NL
.PP
If you specify option \-static\-intel while option \-mcmodel=medium or \-mcmodel=large is set, an error will be displayed.
.NL
.PP
If you specify option static\-intel and any of the Intel\-provided libraries have no static version, a diagnostic will be displayed.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-staticlib (M*X only)
.RS
.TP
Invokes the libtool command to generate static libraries.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler produces an executable.
.TP
\fBDescription:\fR 
.PP
This option invokes the libtool command to generate static libraries. 
.NL
.PP
When passed this option, the compiler uses the libtool command to produce a static library instead of an executable when linking. 
.NL
.PP
To build dynamic libraries, you should specify option \-dynamiclib or libtool \-dynamic <objects>.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-static\-libgcc (L*X only)
.RS
.TP
Links the GNU libgcc library statically.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler links the GNU libgcc library dynamically.
.TP
\fBDescription:\fR 
.PP
This option links the GNU libgcc library statically. It is the opposite of option \-shared\-libgcc.
.NL
.PP
This option is useful when you want to override the default behavior, which causes the library to be linked dynamically.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-static\-libstdc++ (L*X only)
.RS
.TP
Links the GNU libstdc++ library statically.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler links the GNU libstdc++ library dynamically.
.TP
\fBDescription:\fR 
.PP
This option links the GNU libstdc++ library statically.
.NL
.PP
This option is useful when you want to override the default behavior, which causes the library to be linked dynamically.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-syntax\-only 
.RS
.TP
Tells the compiler to check only for correct syntax.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Normal compilation is performed.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to check only for correct syntax. It lets you do a quick syntax check of your source file.
.NL
.PP
Compilation stops after the source file has been parsed. No code is generated, no object file is produced, and some error checking done by the optimizer is bypassed.
.NL
.PP
Warnings and messages appear on stderr.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux: \-y, \-fsyntax\-only, \-syntax (this is a deprecated option)
.NL
.PP
OS X: \-y, \-fsyntax\-only
.NL
.PP
Windows: /Zs
.NL
.RE
.TP
.B
\-Tfilename (L*X only)
.RS
.TP
Tells the linker to read link commands from a file.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The linker does not read link commands from a file.
.TP
\fBDescription:\fR 
.PP
This option tells the linker to read link commands from a file.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-tcheck (L*X only)
.RS
.TP
Enables analysis of threaded applications.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Threaded applications are not instrumented by the compiler for analysis by Intel(R) Thread Checker.
.TP
\fBDescription:\fR 
.PP
This option enables analysis of threaded applications.
.NL
.PP
This thread checking feature requires installation of another product. For more information, see Feature Requirements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-tcollect[lib] (L*X only)
.RS
.TP
Inserts instrumentation probes calling the Intel(R) Trace Collector API.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIlib\fR
.NL
Is one of the Intel(R) Trace Collector libraries; for example, VT, VTcs, VTmc, or VTfs. If you do not specify \fIlib\fR, the default library is VT.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Instrumentation probes are not inserted into compiled applications.
.TP
\fBDescription:\fR 
.PP
This option inserts instrumentation probes calling the Intel(R) Trace Collector API. 
.NL
.PP
This trace analyzing/collecting feature requires installation of another product. For more information, see Feature Requirements.
.NL
.PP
This option provides a flexible and convenient way of instrumenting functions of a compiled application. For every function, the entry and exit points are instrumented at compile time to let the Intel(R) Trace Collector record functions beyond the default MPI calls. For non\-MPI applications (for example, threaded or serial), you must ensure that the Intel(R) Trace Collector is properly initialized (VT_initialize/VT_init).
.NL
.PP
.B CAUTION:
Be careful with full instrumentation because this feature can produce very large trace files.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-tcollect\-filter filename (L*X only)
.RS
.TP
Lets you enable or disable the instrumentation of specified functions.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is a configuration file that lists filters, one per line. Each filter consists of a regular expression string and a switch. Strings with leading or trailing white spaces must be quoted. Other strings do not have to be quoted. The switch value can be ON, on, OFF, or off.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Functions are not instrumented. However, if option \-tcollect (Linux) is specified, the filter setting is ".* ON" and all functions get instrumented. 
.TP
\fBDescription:\fR 
.PP
This option lets you enable or disable the instrumentation of specified functions. 
.NL
.PP
During instrumentation, the regular expressions in the file are matched against the function names. The switch specifies whether matching functions are to be instrumented or not. Multiple filters are evaluated from top to bottom with increasing precedence. 
.NL
.PP
The names of the functions to match against are formatted as follows:
.NL
.IP \(bu 2
The source file name is followed by a colon\-separated function name. Source file names should contain the full path, if available. For example: 
.IP
/home/joe/src/file.f:FOO_bar
.IP \(bu 2
Classes and function names are separated by double colons. For example:
.IP
/home/joe/src/file.fpp:app::foo::bar
.PP
You can use option \-qopt\-report (Linux* OS) or /Qopt\-report (Windows* OS) to get a full list of file and function names that the compiler recognizes from the compilation unit. This list can be used as the basis for filtering in the configuration file.
.NL
.PP
This trace analyzing/collecting feature requires installation of another product. For more information, see Feature Requirements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-threads
.TP
.B
\-nothreads
.RS
.TP
Tells the linker to search for unresolved references in a multithreaded run\-time library.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
Systems using Intel(R) 64 architecture: threads 
.NL
On systems using Intel(R) 64 architecture, the linker searches for unresolved references in a mutithreaded run\-time library. 
.TP 18
Systems using IA\-32 architecture: nothreads
.NL
On systems using IA\-32 architecture, the linker does not search for unresolved references in a mutithreaded run\-time library.
.TP
\fBDescription:\fR 
.PP
This option tells the linker to search for unresolved references in a multithreaded run\-time library.
.NL
.PP
This option sets option reentrancy threaded.
.NL
.PP
Windows systems: The following table shows which options to specify for a multithreaded run\-time library.
.NL
.PP
To ensure that a threadsafe and/or reentrant run\-time library is linked and correctly initialized, option threads should also be used for the link step and for the compilation of the main routine.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-traceback
.TP
.B
\-notraceback
.RS
.TP
Tells the compiler to generate extra information in the object file to provide source file traceback information when a severe error occurs at run time.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
notraceback
.NL
No extra information is generated in the object file to produce traceback information.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate extra information in the object file to provide source file traceback information when a severe error occurs at run time.
.NL
.PP
When the severe error occurs, source file, routine name, and line number correlation information is displayed along with call stack hexadecimal addresses (program counter trace).
.NL
.PP
Note that when a severe error occurs, advanced users can also locate the cause of the error using a map file and the hexadecimal addresses of the stack displayed when the error occurs.
.NL
.PP
This option increases the size of the executable program, but has no impact on run\-time execution speeds.
.NL
.PP
It functions independently of the debug option.
.NL
.PP
On Windows* systems, traceback sets the /Oy\- option, which forces the compiler to use EBP as the stack frame pointer.
.NL
.PP
On Windows* systems, the linker places the traceback information in the executable image, in a section named ".trace". To see which sections are in an image, use the command:
.NL
.PP
link \-dump \-summary your_app_name.exe
.PP
.PP
To see more detailed information, use the command:
.NL
.PP
link \-dump \-headers your_app_name.exe
.PP
.PP
On Windows* systems, when requesting traceback, you must set Enable Incremental Linking in the VS .NET* IDE Linker Options to No. You must also set Omit Frame Pointers (the /Oy option) in the Optimization Options to "No."
.NL
.PP
On Linux* systems, to display the section headers in the image (including the header for the .trace section, if any), use the command:
.NL
.PP
objdump \-h your_app_name.exe
.PP
.PP
On OS X* systems, to display the section headers in the image, use the command:
.NL
.PP
otool \-l your_app_name.exe
.PP
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Uname
.RS
.TP
Undefines any definition currently in effect for the specified symbol.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIname\fR
.NL
Is the name of the symbol to be undefined.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Symbol definitions are in effect until they are undefined.
.TP
\fBDescription:\fR 
.PP
This option undefines any definition currently in effect for the specified symbol. 
.NL
.PP
On Windows systems, use the /u option to undefine all previously defined preprocessor values.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.PP
Windows: /undefine:\fIname\fR
.NL
.RE
.TP
.B
\-unroll[=n]
.RS
.TP
Tells the compiler the maximum number of times to unroll loops.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the maximum number of times a loop can be unrolled. To disable loop enrolling, specify 0.
.TP
\fBDefault:\fR 
.TP 18
\-unroll 
.NL
The compiler uses default heuristics when unrolling loops.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler the maximum number of times to unroll loops.
.NL
.PP
If you do not specify \fIn\fR, the optimizer determines how many times loops can be unrolled.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-funroll\-loops
.NL
.RE
.TP
.B
\-unroll\-aggressive
.TP
.B
\-no\-unroll\-aggressive
.RS
.TP
Determines whether the compiler uses more aggressive unrolling for certain loops.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-unroll\-aggressive 
.NL
The compiler uses default heuristics when unrolling loops.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler uses more aggressive unrolling for certain loops. The positive form of the option may improve performance.
.NL
.PP
This option enables aggressive, complete unrolling for loops with small constant trip counts.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-v [filename]
.RS
.TP
Specifies that driver tool commands should be displayed and executed.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of a source file to be compiled. A space must appear before the file name.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No tool commands are shown.
.TP
\fBDescription:\fR 
.PP
This option specifies that driver tool commands should be displayed and executed. 
.NL
.PP
If you use this option without specifying a source file name, the compiler displays only the version of the compiler.
.NL
.PP
If you want to display processing information (pass information and source file names), specify keyword all for the watch option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-watch cmd
.NL
.PP
Windows: /watch:cmd
.NL
.RE
.TP
.B
\-vec
.TP
.B
\-no\-vec
.RS
.TP
Enables or disables vectorization.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-vec 
.NL
Vectorization is enabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables vectorization.
.NL
.PP
To disable vectorization, specify \-no\-vec (Linux* OS and OS X*) or /Qvec\- (Windows* OS). 
.NL
.PP
To disable interpretation of SIMD directives, specify \-no\-simd (Linux* OS and OS X*) or /Qsimd\- (Windows* OS).
.NL
.PP
To disable all compiler vectorization, use the "\-no\-vec \-no\-simd" (Linux* OS and OS X*) or "/Qvec\- /Qsimd\-" (Windows* OS) compiler options. The option \-no\-vec (and /Qvec\-) disables all auto\-vectorization, including vectorization of array notation statements. The option \-no\-simd (and /Qsimd\-) disables vectorization of loops that have SIMD directives. 
.NL
.PP
.B NOTE:
Using this option enables vectorization at default optimization levels for both Intel(R) microprocessors and non\-Intel microprocessors.  Vectorization may call library routines that
can result in additional performance gain on Intel microprocessors than on non\-Intel
microprocessors. The vectorization can also be affected by certain options, such as /arch (Windows OS),  \-m (Linux
OS and OS X), or [Q]x.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-vec\-guard\-write
.TP
.B
\-no\-vec\-guard\-write
.RS
.TP
Tells the compiler to perform a conditional check in a vectorized loop.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-vec\-guard\-write 
.NL
The  compiler  performs a conditional check in a vectorized loop.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to perform a conditional check in a vectorized loop. This checking avoids unnecessary stores and may improve performance.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-vec\-report[=n]
.RS
.TP
Controls the diagnostic information reported by the vectorizer. This is a deprecated option. The replacement options for this kind of report are \-qopt\-report \-qopt\-report\-phase=vec  (Linux* OS and OS X*) or /Qopt\-report /Qopt\-report\-phase:vec (Windows* OS). 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a value denoting which diagnostic messages to report. Possible values are:
.RS
.TP 15
0
Tells the vectorizer to report no diagnostic information.
.TP 15
1
Tells the vectorizer to report on vectorized loops.
.TP 15
2
Tells the vectorizer to report on vectorized and non\-vectorized loops. This is the default if \fIn\fR is not specified.
.TP 15
3
Tells the vectorizer to report on vectorized and non\-vectorized loops and any proven or assumed data dependences.
.TP 15
4
Tells the vectorizer to report on non\-vectorized loops.
.TP 15
5
Tells the vectorizer to report on non\-vectorized loops and the reason why they were not vectorized.
.TP 15
6
Tells the vectorizer to use greater detail when reporting on vectorized
and non\-vectorized loops and any
proven or assumed data dependences. This value is deprecated. There is no replacement. In a future release, value 5 will produce the greatest level of details.
.TP 15
7
Tells the vectorizer to emit vector code
quality message ids and corresponding data values for vectorized loops. It provides
information such as the expected speedup, memory access
patterns, and the number of vector idioms for vectorized
loops. This value is deprecated. There is no replacement. In a future release, value 5 will produce the greatest level of details.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No vectorizer messages are displayed.
.TP
\fBDescription:\fR 
.PP
This option controls the diagnostic information reported by the vectorizer. The vectorizer report is sent to stdout.
.NL
.PP
.B NOTE:
When option \-qopt\-report or /Qopt\-report is in effect, you get reports for all optimizer phases.  When you specify \-qopt\-report or /Qopt\-report along with a particular setting for option \-qopt\-report\-phase or /Qopt\-report\-phase, 
you suppress reports for the other phases.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-vec\-threshold[n]
.RS
.TP
Sets a threshold for the vectorization of loops. 
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an integer whose value is the
threshold for the vectorization of loops. Possible values are 0 through 100.
.IP
If \fIn\fR is 0, loops get vectorized always, regardless of computation work volume.
.IP
If \fIn\fR is 100, loops get vectorized when performance gains are predicted based on
the compiler analysis data. Loops get vectorized only if profitable vector\-level
parallel execution is almost certain.
.IP
The intermediate 1 to 99 values represent the percentage probability for profitable speed\-up. For example, \fIn\fR=50 directs the compiler to vectorize
only if there is a 50% probability of the code speeding up if executed in vector form.
.TP
\fBDefault:\fR 
.TP 18
\-vec\-threshold100 
.NL
Loops get vectorized only
if profitable vector\-level parallel execution is almost certain. This is also the default if you do not specify  \fIn\fR.
.TP
\fBDescription:\fR 
.PP
This option sets a threshold for the vectorization of loops based on the probability of profitable execution of the vectorized loop in parallel. 
.NL
.PP
This option is useful for loops whose computation work volume cannot be determined at compile\-time. The threshold is usually relevant when the loop trip count is unknown at compile\-time.  
.NL
.PP
The compiler applies a heuristic that tries to balance the overhead of creating multiple threads versus the amount of work available to be shared amongst the threads.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-vecabi=keyword
.RS
.TP
Determines whether the compiler uses the compatibility or legacy vector function application binary interface (ABI).
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies which vector function ABI to use.  Possible values are:
.RS
.TP 15
legacy
Tells the compiler to use the legacy vector function ABI.
.TP 15
compat
Tells the compiler to use the compatibility vector function ABI. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-vecabi=compat 
.NL
The compiler uses the compatibility vector function ABI.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler uses the compatibility or legacy vector function application binary interface (ABI).
.NL
.PP
On Linux* systems, by default, it provides compatibility with gcc\[aq]s version of the vector function ABI. You must specify \fIkeyword\fRlegacy if you need to keep the generated vector function binary backward compatible with the vectorized binary generated by the previous version of Intel(R) compilers.  
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-vms
.TP
.B
\-novms
.RS
.TP
Causes the run\-time system to behave like HP* Fortran on OpenVMS* Alpha systems and VAX* systems (VAX FORTRAN*).
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
novms
.NL
The run\-time system follows default Intel(R) Fortran behavior.
.TP
\fBDescription:\fR 
.PP
This option causes the run\-time system to behave like HP* Fortran on OpenVMS* Alpha systems and VAX* systems (VAX FORTRAN*).
.NL
.PP
It affects the following language features:
.NL
.IP \(bu 2
Certain defaults
In the absence of other options, vms sets the defaults as check format and check output_conversion.
.IP \(bu 2
Alignment
Option vms does not affect the alignment of fields in records or items in common blocks. For compatibility with HP Fortran on OpenVMS systems, use align norecords to pack fields of records on the next byte boundary.
.IP \(bu 2
Carriage control default
If option vms and option ccdefault default are specified, carriage control defaults to FORTRAN if the file is formatted and the unit is connected to a terminal.
.IP \(bu 2
INCLUDE qualifiers
/LIST and /NOLIST are recognized at the end of the file name in an INCLUDE statement at compile time. If the file name in the INCLUDE statement does not specify the complete path, the path used is the current directory. Note that if vms is not specified, the path used is the directory where the file that contains the INCLUDE statement resides.
.IP \(bu 2
Quotation mark character
A quotation mark (") character is recognized as starting an octal constant ("0..7) instead of a character literal ("...").
.IP \(bu 2
Deleted records in relative files
When a record in a relative file is deleted, the first byte of that record is set to a known character (currently \[aq]@\[aq] ). Attempts to read that record later result in ATTACCNON errors. The rest of the record (the whole record, if vms is not specified) is set to nulls for unformatted files and spaces for formatted files.
.IP \(bu 2
ENDFILE records
When an ENDFILE is performed on a sequential unit, an actual 1\-byte record containing a Ctrl/Z is written to the file. If vms is not specified, an internal ENDFILE flag is set and the file is truncated. The vms option does not affect ENDFILE on relative files: these files are truncated.
.IP \(bu 2
Implied logical unit numbers
The vms option enables Intel(R) Fortran to recognize certain environment variables at run time for ACCEPT, PRINT, and TYPE statements and for READ and WRITE statements that do not specify a unit number (such as READ (*,1000)).
.IP \(bu 2
Treatment of blanks in input
The vms option causes the defaults for the keyword BLANK in OPEN statements to become \[aq]NULL\[aq] for an explicit OPEN and \[aq]ZERO\[aq] for an implicit OPEN of an external or internal file.
.IP \(bu 2
OPEN statement effects
Carriage control defaults to FORTRAN if the file is formatted, and the unit is connected to a terminal. Otherwise, carriage control defaults to LIST. The vms option affects the record length for direct access and relative organization files. The buffer size is increased by 1 to accommodate the deleted record character.
.IP \(bu 2
Reading deleted records and ENDFILE records
The run\-time direct access READ routine checks the first byte of the retrieved record. If this byte is \[aq]@\[aq] or NULL ("\0"), then an ATTACCNON error is returned. The run\-time sequential access READ routine checks to see if the record it just read is one byte long and contains a Ctrl/Z. If this is true, it returns EOF.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wa,option1[,option2,...]
.RS
.TP
Passes options to the assembler for processing.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIoption\fR
.NL
Is an assembler option. This option is not processed by the driver and is directly passed to the assembler.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No options are passed to the assembler.
.TP
\fBDescription:\fR 
.PP
This option passes one or more options to the assembler for processing. If the assembler is not invoked, these options are ignored.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-warn [keyword[, keyword...]]
.TP
.B
\-nowarn
.RS
.TP
Specifies diagnostic messages to be issued by the compiler.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies the diagnostic messages to be issued. Possible values are:
.RS
.TP 15
none
Disables all warning messages.
.TP 15
[no]alignments
Determines whether warnings occur for data that is not naturally aligned.
.TP 15
[no]declarations
Determines whether warnings occur for any undeclared names.
.TP 15
[no]errors
Determines whether warnings are changed to errors.
.TP 15
[no]general
Determines whether warning messages and informational messages are issued by the compiler.
.TP 15
[no]ignore_loc
Determines whether warnings occur when %LOC is stripped from an actual argument.
.TP 15
[no]interfaces
Determines whether the compiler checks the interfaces of all SUBROUTINEs called and FUNCTIONs invoked in your compilation against an external set of interface blocks.
.TP 15
[no]stderrors
Determines whether warnings about Fortran standard violations are changed to errors.
.TP 15
[no]truncated_source
Determines whether warnings occur when source exceeds the maximum column width in fixed\-format files.
.TP 15
[no]uncalled
Determines whether warnings occur when a statement function is never called
.TP 15
[no]unused
Determines whether warnings occur for declared variables that are never used.
.TP 15
[no]usage
Determines whether warnings occur for questionable programming practices.
.TP 15
all
Enables all warning messages except errors and stderrors.
.RE
.TP
\fBDefault:\fR 
.TP 18
alignments
.NL
Warnings are issued about data that is not naturally aligned.
.TP 18
general
.NL
All information\-level and warning\-level messages are enabled.
.TP 18
usage
.NL
Warnings are issued for questionable programming practices.
.TP 18
nodeclarations
.NL
No warnings are issued for undeclared names.
.TP 18
noerrors
.NL
Warning\-level messages are not changed to error\-level messages.
.TP 18
noignore_loc
.NL
No warnings are issued when %LOC is stripped from an argument.
.TP 18
nointerfaces
.NL
The compiler does not check interfaces of SUBROUTINEs called and FUNCTIONs invoked in your compilation against an external set of interface blocks.
.TP 18
nostderrors
.NL
Warning\-level messages about Fortran standards violations are not changed to error\-level messages.
.TP 18
notruncated_source
.NL
No warnings are issued when source exceeds the maximum column width in fixed\-format files.
.TP 18
nouncalled
.NL
No warnings are issued when a statement function is not called.
.TP 18
nounused
.NL
No warnings are issued for variables that are declared but never used.
.TP
\fBDescription:\fR 
.PP
This option specifies the diagnostic messages to be issued by the compiler.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
warn none
.NL
Disables all warning messages. This is the same as specifying nowarn.
.NL
.TP 18
warn noalignments
.NL
Disables warnings about data that is not naturally aligned.
.NL
.TP 18
warn declarations
.NL
Enables warnings about any undeclared names. The compiler will use the default implicit data typing rules for such undeclared names.  The IMPLICIT and IMPLICIT NONE statements override this option.
.NL
.TP 18
warn errors
.NL
Tells the compiler to change all warning\-level messages to error\-level messages; this includes warnings about Fortran standards violations.
.NL
.TP 18
warn nogeneral
.NL
Disables all informational\-level and warning\-level diagnostic messages.
.NL
.TP 18
warn ignore_loc
.NL
Enables warnings when %LOC is stripped from an actual argument.
.NL
.TP 18
warn interfaces
.NL
Tells the compiler to check the interfaces of all SUBROUTINEs called and FUNCTIONs invoked in your compilation against a set of interface blocks stored separately from the source being compiled.
.TP 18
The compiler generates a compile\-time message if the interface used to invoke a routine does not match the interface defined in a .mod file external to the source (that is, in a .mod generated by option gen\-interfaces as opposed to a .mod file USEd in the source). The compiler looks for these .mods in the current directory or in the directory specified by the include (\-I) or \-module option. If interface mismatches occur, some will result in a compile\-time error,
others will only generate a warning.
.TP 18
By default, warn interfaces turns on option gen\-interfaces. You can turn off that option by explicitly specifying option /gen\-interfaces\- (Windows* OS) or \-no\-gen\-interfaces (Linux* OS and OS X*).
.NL
.TP 18
warn stderrors
.NL
Tells the compiler to change all warning\-level messages about Fortran standards violations to error\-level messages. This option sets the std03 option (Fortran 2003 standard). If you want Fortran 95 standards violations to become errors, you must specify options warn stderrors and std95.
.NL
.TP 18
warn truncated_source
.NL
Enables warnings when a source line exceeds the maximum column width in fixed\-format source files. The maximum column width for fixed\-format files is 72, 80, or 132, depending on the setting of the extend\-source option. The warn truncated_source option has no effect on truncation; lines that exceed the maximum column width are always truncated. This option does not apply to free\-format source files.
.NL
.TP 18
warn uncalled
.NL
Enables warnings when a statement function is never called.
.NL
.TP 18
warn unused
.NL
Enables warnings for variables that are declared but never used.
.NL
.TP 18
warn nousage
.NL
Disables warnings about questionable programming practices. Questionable programming practices, although allowed, often are the result of programming errors; for example: a continued character or Hollerith literal whose first part ends before the statement field and appears to end with trailing spaces. Note that the /pad\-source option can prevent this error.
.NL
.TP 18
warn all
.NL
This is the same as specifying warn. This option does not set options warn errors or warn stderrors. To enable all the additional checking to be performed and force the severity of the diagnostic messages to be severe enough to not generate an object file, specify warn allwarn errors or warn allwarn stderrors.
.TP 18
On Windows systems: In the Property Pages, \fB Custom\fR means that diagnostics will be specified on an individual basis.
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
warn none
.NL
Linux and OS X: \-nowarn, \-w, \-W0, \-warn nogeneral
.TP 18
warn declarations 
.NL
Linux and OS X: \-implicitnone, \-u
.TP 18
warn nodeclarations
.NL
Linux and OS X: None
.TP 18
warn general
.NL
Linux and OS X: \-W1
.TP 18
warn nogeneral
.NL
Linux and OS X: \-W0, \-w, \-nowarn, \-warn none
.TP 18
warn stderrors
.NL
Linux and OS X: \-e90, \-e95, \-e03
.TP 18
warn all
.NL
Linux and OS X: \-warn
.RE
.TP
.B
\-watch[=keyword[, keyword...]]
.TP
.B
\-nowatch
.RS
.TP
Tells the compiler to display certain information to the console output window.
.NL
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Determines what information is displayed. Possible values are:
.RS
.TP 15
none
Disables cmd and source.
.TP 15
[no]cmd
Determines whether driver tool commands are displayed and executed.
.TP 15
[no]source
Determines whether the name of the file being compiled is displayed.
.TP 15
mic\-cmd
Enables display of compiler options that are passed to the offload compilation. This keyword is only available on Intel(R) MIC Architecture.
.TP 15
all
Enables cmd and source.
.RE
.TP
\fBDefault:\fR 
.TP 18
nowatch
.NL
Pass information and source file names are not displayed to the console output window.
.TP
\fBDescription:\fR 
.PP
Tells the compiler to display processing information (pass information and source file names) to the console output window.
.NL
.TP 18
\fBOption watchkeyword\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
none
.NL
Tells the compiler to not display pass information and source file names to the console output window. This is the same as specifying nowatch.
.NL
.TP 18
cmd
.NL
Tells the compiler to display and execute driver tool commands.
.NL
.TP 18
source
.NL
Tells the compiler to display the name of the file being compiled.
.NL
.TP 18
mic\-cmd
.NL
Tells the compiler to display the compiler options that are passed to the offload compilation.  Only the options that are automatically passed are displayed. If this keyword is specified on an architecture other than Intel(R) MIC Architecture, results vary. It may be ignored, have no effect, or produce an error.
.NL
.TP 18
all
.NL
Tells the compiler to display pass information and source file names to the console output window. This is the same as specifying watch with no \fIkeyword\fR.  For heterogeneous compilation, the tool commands for the host and the offload compilations will be displayed.
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
watch cmd
.NL
Linux and OS X: \-v
.RE
.TP
.B
\-WB
.RS
.TP
Turns a compile\-time bounds check into a warning.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Compile\-time bounds checks are errors.
.TP
\fBDescription:\fR 
.PP
This option turns a compile\-time bounds check into a warning.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-what
.RS
.TP
Tells the compiler to display its detailed version string.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The version strings are not displayed.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to display its detailed version string.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Winline
.RS
.TP
Enables diagnostics about what is inlined and what is not inlined.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No diagnostics are produced about what is inlined and what is not inlined.
.TP
\fBDescription:\fR 
.PP
This option enables diagnostics about what is inlined and what is not inlined. The diagnostics depend on what interprocedural functionality is available.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wl,option1[,option2,...]
.RS
.TP
Passes options to the linker for processing.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIoption\fR
.NL
Is a linker option. This option is not processed by the driver and is directly passed to the linker.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No options are passed to the linker.
.TP
\fBDescription:\fR 
.PP
This option passes one or more options to the linker for processing. If the linker is not invoked, these options are ignored.
.NL
.PP
This option is equivalent to specifying option \-Qoption,link,\fIoptions\fR.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wp,option1[,option2,...]
.RS
.TP
Passes options to the preprocessor.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIoption\fR
.NL
Is a preprocessor option. This option is not processed by the driver and is directly passed to the preprocessor.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No options are passed to the preprocessor.
.TP
\fBDescription:\fR 
.PP
This option passes one or more options to the preprocessor. If the preprocessor is not invoked, these options are ignored.
.NL
.PP
This option is equivalent to specifying option \-Qoption,\fIfpp\fR\fI, options\fR.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-wrap\-margin (L*X only)
.TP
.B
\-no\-wrap\-margin (L*X only)
.RS
.TP
Provides a way to disable the right margin wrapping that occurs in Fortran list\-directed output.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
wrap\-margin
.NL
The right margin wraps at column 80 if the record length is greater than 80 characters.
.TP
\fBDescription:\fR 
.PP
This option provides a way to disable the right
margin wrapping that occurs in Fortran list\-directed output. By
default, when the record being written becomes longer than 80
characters, the record is wrapped to a new record at what is called
the "right margin".
.NL
.PP
Specify \-no\-wrap\-margin (Linux* OS) or
/wrap\-margin\- (Windows* OS) to disable this behavior.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-xcode
.RS
.TP
Tells the compiler which processor features it may target, including which instruction sets and optimizations it may generate.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fIcode\fR
.NL
Indicates to the compiler a feature set that it may target, including which instruction sets and optimizations it may generate. Many of the following descriptions refer to Intel(R) Streaming SIMD Extensions (Intel(R) SSE) and Supplemental Streaming SIMD Extensions (Intel(R) SSSE). Possible values are:
.RS
.TP 15
MIC\-AVX512
May generate Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX\-512) Foundation instructions, Intel(R) AVX\-512 Conflict Detection instructions, Intel(R) AVX\-512 Exponential and Reciprocal instructions, Intel(R) AVX\-512 Prefetch instructions for Intel(R) processors, and the instructions enabled with CORE\-AVX2. Optimizes for Intel(R) processors that support Intel(R) AVX\-512 instructions.
.TP 15
CORE\-AVX512
May generate Intel(R) Advanced Vector Extensions 512 (Intel(R) AVX\-512) Foundation instructions, Intel(R) AVX\-512 Conflict Detection instructions, Intel(R) AVX\-512 Doubleword and Quadword instructions, Intel(R) AVX\-512 Byte and Word instructions and Intel(R) AVX\-512 Vector Length extensions, as well as the instructions enabled with CORE\-AVX2. Optimizes for Intel(R) processors that support Intel(R) AVX\-512 instructions.
.TP 15
CORE\-AVX2
May generate Intel(R) Advanced Vector Extensions 2 (Intel(R) AVX2), Intel(R) AVX, SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel(R) processors.  Optimizes for Intel(R) processors that support Intel(R) AVX2 instructions.
.TP 15
CORE\-AVX\-I
May generate the RDRND instruction, Intel(R) Advanced Vector Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel(R) processors. Optimizes for Intel(R) processors that support the RDRND instruction.
.TP 15
AVX
May generate Intel(R) Advanced Vector Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel(R) processors. Optimizes for Intel processors that support Intel(R) AVX instructions. 
.TP 15
SSE4.2
May generate Intel(R) SSE4 Efficient Accelerated String and Text Processing instructions, Intel(R) SSE4 Vectorizing Compiler and Media Accelerator, and Intel(R) SSE3, SSE2, SSE, and SSSE3 instructions for Intel(R) processors. Optimizes for Intel processors that support Intel(R) SSE4.2 instructions.
.TP 15
SSE4.1
May generate Intel(R) SSE4 Vectorizing Compiler and Media Accelerator instructions for Intel(R) processors. May generate Intel(R) SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel processors that support Intel(R) SSE4.1 instructions.
.TP 15
ATOM_SSE4.2
May generate MOVBE instructions for Intel(R) processors, depending on the setting of option \-minstruction (Linux* OS and OS X*) or /Qinstruction (Windows* OS). May also generate Intel(R) SSE4.2, SSE3, SSE2, and SSE instructions for Intel processors. Optimizes for Intel(R) Atom(TM) processors that support Intel(R) SSE4.2 and MOVBE instructions. 
.TP 15
ATOM_SSSE3
May generate MOVBE instructions for Intel(R) processors, depending on the setting of option \-minstruction (Linux* OS and OS X*) or /Qinstruction (Windows* OS). May also generate SSSE3, Intel(R) SSE3, SSE2, and SSE instructions for Intel processors. Optimizes for Intel(R) Atom(TM)  processors that support Intel(R) SSSE3 and MOVBE instructions.
.TP 15
SSE3_ATOM and SSSE3_ATOM
These option settings are deprecated. They have the same effect as specifying ATOM_SSSE3.
.TP 15
SSSE3
May generate SSSE3 and Intel(R) SSE3, SSE2, and SSE instructions for Intel(R) processors. Optimizes for Intel processors that support SSSE3 instructions.  For OS X* systems, this value is only supported on Intel(R) 64 architecture. This replaces value T, which is deprecated.
.TP 15
SSE3
May generate Intel(R) SSE3, SSE2, and SSE instructions for Intel(R) processors. Optimizes for Intel processors that support  Intel(R) SSE3 instructions.  For OS X* systems, this value is only supported on IA\-32 architecture. 
.TP 15
SSE2
May generate Intel(R) SSE2 and SSE instructions for Intel(R) processors. Optimizes for Intel processors that support Intel(R) SSE2 instructions.  This value is not available on OS X*  systems.
.RE
.IP
You can also specify
Host. For more information, see option [Q]xHost.
.TP
\fBDefault:\fR 
.TP 18
Windows* systems: None Linux* systems: None OS X* systems using IA\-32 architecture: SSE3 OS X* systems using Intel(R) 64 architecture: SSSE3
.NL
On Windows systems, if neither /Qx nor /arch is specified, the
default is /arch:SSE2.
.IP
On Linux systems, if neither \-x nor \-m is specified, the default
is \-msse2.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler which processor features it may target, including which instruction sets and optimizations it may generate. It also enables optimizations in addition to Intel feature\-specific optimizations. 
.NL
.PP
The specialized code generated by this option may only run on a subset of Intel(R) processors.
.NL
.PP
The resulting executables created from these option \fIcode\fR values can only be run on
Intel(R) processors  that support the
indicated instruction set.
.NL
.PP
The binaries produced by these \fIcode\fR values will run on
Intel(R) processors that support the  specified
features.
.NL
.PP
Do not use \fIcode\fR values to create binaries that will execute on a processor that is not compatible with the targeted processor. The resulting program may fail with an illegal instruction exception or display other unexpected behavior. 
.NL
.PP
Compiling the main program with any of the \fIcode\fR values produces binaries that display a fatal run\-time error if they are executed on unsupported processors, including all non\-Intel processors. 
.NL
.PP
Compiler options m and arch produce binaries that should run on processors not made by Intel that implement the same capabilities as the corresponding Intel(R) processors.
.NL
.PP
The \-x and /Qx options enable additional optimizations not enabled with options \-m or /arch (nor with options –ax and /Qax). 
.NL
.PP
On Windows* systems, options /Qx
and /arch are mutually exclusive.
If both are specified, the compiler uses the last one specified and
generates a warning. Similarly, on Linux* and OS X* systems, options \-x
and \-m
are mutually
exclusive. If both are specified, the compiler uses the last one
specified and generates a warning.
.NL
.PP
.B NOTE:
All settings except SSE2 do a CPU check.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-X
.RS
.TP
Removes standard directories from the include file search path.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Standard directories are in the include file search path.
.TP
\fBDescription:\fR 
.PP
This option removes standard directories from the include file search path. It prevents the compiler from searching the default path specified by the CPATH environment variable.
.NL
.PP
On Linux* and OS X* systems, specifying \-X (or \-noinclude) prevents the compiler from searching in /usr/include for files specified in an INCLUDE statement. 
.NL
.PP
You can use this option with the I option to prevent the compiler from searching the default path for include files and direct it to use an alternate path.
.NL
.PP
This option affects fpp preprocessor behavior and the USE statement.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-nostdinc
.NL
.RE
.TP
.B
\-xHost
.RS
.TP
Tells the compiler to generate instructions for the highest instruction set
available on the compilation host processor.
.NL
.TP
\fBArchitecture Restrictions:\fR Not available on Intel(R) 64 architecture targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
Windows* systems: None Linux* systems: None OS X* systems using IA\-32 architecture: \-xSSE3 OS X* systems using Intel(R) 64 architecture: \-xSSSE3
.NL
On Windows systems, if neither /Qx nor /arch is specified, the
default is /arch:SSE2.
.IP
On Linux systems, if neither \-x nor \-m is specified, the default
is \-msse2.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate instructions for the highest instruction set
available on the compilation host processor.
.NL
.PP
The instructions generated by this compiler option differ
depending on the compilation host processor. 
.NL
.PP
The following table
describes the effects of specifying  the [Q]xHost option and it tells whether the
resulting executable will run on processors different from the host
processor.
.NL
.PP
Descriptions in the table refer to Intel(R) Advanced Vector Extensions 2 (Intel(R) AVX2), Intel(R)
Advanced Vector Extensions (Intel(R) AVX), Intel(R) Streaming SIMD
Extensions (Intel(R) SSE), and Supplemental Streaming SIMD
Extensions (SSSE).
.NL
.TP 18
\fBInstruction Set of Host Processor\fR
.NL
.NL
\fBEffects When the \-xHost or /QxHost Compiler Option is Specified\fR
.NL
.NL
.TP 18
Intel(R) AVX2
.NL
When compiling on Intel(R) processors:
.TP 18
Corresponds to option [Q]xCORE\-AVX2. The generated executable will not run on non\-Intel processors and it will not run on Intel(R) processors that do not support Intel(R) AVX2 instructions.
.TP 18
When compiling on non\-Intel processors:
.TP 18
Corresponds to option \-march=core\-avx2 (Linux OS and OS X) or /arch:CORE\-AVX2 (Windows OS). The 
generated executable will run on Intel(R) processors and non\-Intel processors that 
support at least Intel(R) AVX2 instructions..  You may see a run\-time error if the run\-time processor does not 
support Intel(R) AVX2 instructions.
.NL
.TP 18
Intel(R) AVX
.NL
When compiling on Intel(R) processors:
.TP 18
Corresponds to option [Q]xAVX. The generated executable will not run on non\-Intel processors and it will not run on Intel(R) processors that do not support Intel(R) AVX instructions.
.TP 18
When compiling on non\-Intel processors:
.TP 18
Corresponds to option \-mavx (Linux OS and OS X) or /arch:AVX (Windows OS). The 
generated executable will run on Intel(R) processors and non\-Intel processors that 
support at least Intel(R) AVX instructions.  You may see a run\-time error if the run\-time processor does not 
support Intel(R) AVX instructions.
.NL
.TP 18
Intel(R) SSE4.2
.NL
When compiling on Intel(R) processors:
.TP 18
Corresponds to option [Q]xSSE4.2. The generated executable will not run on non\-Intel processors and
it will not run on Intel(R) processors that do not support Intel(R)
SSE4.2 instructions.
.TP 18
When compiling on non\-Intel processors:
.TP 18
Corresponds to option \-msse4.2 (Linux OS and OS X) or /arch:SSE4.2
(Windows OS). The generated executable will run on Intel(R) processors and
non\-Intel processors that support at least Intel(R)
SSE4.2 instructions. You may see a run\-time
error if the run\-time processor does not support Intel(R) SSE4.2 instructions.
.NL
.TP 18
Intel(R) SSE4.1
.NL
When compiling on Intel(R) processors:
.TP 18
Corresponds to option [Q]xSSE4.1. The generated executable will not run on non\-Intel processors and
it will not run on Intel(R) processors that do not support Intel(R)
SSE4.1 instructions.
.TP 18
When compiling on non\-Intel processors:
.TP 18
Corresponds to option \-msse4.1 (Linux OS and OS X) or /arch:SSE4.1
(Windows OS). The generated executable will run on Intel(R) processors and
non\-Intel processors that support at least Intel(R)
SSE4.1 instructions. You may see a run\-time
error if the run\-time processor does not support Intel(R) SSE4.1
instructions.
.NL
.TP 18
SSSE3
.NL
When compiling on Intel(R) processors:
.TP 18
Corresponds to option [Q]xSSSE3. The generated executable will not run on non\-Intel processors and
it will not run on Intel(R) processors that do not support SSSE3 instructions.
.TP 18
When compiling on non\-Intel processors:
.TP 18
Corresponds to option \-mssse3 (Linux OS and OS X) or /arch:SSSE3
(Windows OS). The generated  executable will run on Intel(R) processors and
non\-Intel processors that support at least SSSE3 instructions. You may see a run\-time
error if the run\-time processor does not support SSSE3
instructions.
.NL
.TP 18
Intel(R) SSE3
.NL
When compiling on Intel(R) processors:
.TP 18
Corresponds to option [Q]xSSE3. The generated executable will not run on non\-Intel processors and
it will not run on Intel(R) processors that do not support Intel(R)
SSE3 instructions.
.TP 18
When compiling on non\-Intel processors:
.TP 18
Corresponds to option \-msse3 (Linux OS and OS X) or /arch:SSE3
(Windows OS). The generated executable will run on Intel(R) processors and
non\-Intel processors that support at least Intel(R)
SSE3 instructions. You may see a warning run\-time error if the run\-time processor does not
support Intel(R) SSE3 instructions.
.NL
.TP 18
Intel(R) SSE2
.NL
When compiling on Intel(R) processors or non\-Intel processors:
.TP 18
Corresponds to option \-msse2 (Linux* OS and OS X*) or /arch:SSE2
(Windows* OS). The generated executable will run on Intel(R) processors and
non\-Intel processors that support at least Intel(R)
SSE2 instructions. You may see a run\-time
error if the run\-time processor does not support Intel(R) SSE2
instructions.
.NL
.PP
For more information on other settings for option [Q]x, see that option description.
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Xlinker option
.RS
.TP
Passes a linker option directly to the linker.
.NL
.TP
\fBArguments:\fR 
.TP 18
\fIoption\fR
.NL
Is a linker option.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No options are passed directly to the linker.
.TP
\fBDescription:\fR 
.PP
This option passes a linker option directly to the linker.
If \-Xlinker \-shared is specified, only \-shared is passed to the linker and no special work is done to ensure proper linkage for generating a shared object. \-Xlinker just takes whatever arguments are supplied and passes them directly to the linker.
.NL
.PP
If you want to pass compound options to the linker, for example "\-L $HOME/lib", you must use the following method:
.NL
.PP
\-Xlinker \-L \-Xlinker $HOME/lib
.PP
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-zero
.TP
.B
\-nozero
.RS
.TP
Initializes to zero all local scalar variables of intrinsic type INTEGER, REAL, COMPLEX, or LOGICAL that are saved but not yet initialized. This is a deprecated option. The replacement option is /Qinit:[no]zero or \-init=[no]zero.
.NL
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-nozero
.NL
Local scalar variables are not initialized to zero.
.TP
\fBDescription:\fR 
.PP
This option initializes to zero all local scalar variables of intrinsic type INTEGER, REAL, COMPLEX, or LOGICAL that are saved but not yet initialized.
.NL
.PP
Use option [Q]save on the command line to make all local variables specifically marked as SAVE.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.SH PREDEFINED SYMBOLS
.PP
The Intel(R) Fortran documentation describes the predefined preprocessor symbols in detail. This section provides a brief summary of the supported symbols. 
.PP
You can use the 
\-U option to suppress an automatic definition of a preprocessor symbol. This option suppresses any symbol definition currently in effect for the specified name. This option performs the same function as an #undef preprocessor directive. 
.PP
The following preprocessor symbols are available: 
.PP
.SH ENVIRONMENT VARIABLES
.PP
You can customize your environment by using run\-time and compile\-time environment variables, or by using OpenMP* or Profile Guided Optimization (PGO) environment variables. 
.PP
The following table shows the compile\-time environment variables that affect the Intel(R) Fortran Compiler: 
.PP
.TP 18
\fBCompile\-Time Environment Variable 
\fR
.NL
.NL
\fBDescription 
\fR
.NL
.NL
.TP 18
IFORTCFG
.NL
Specifies a configuration file that the compiler should use instead of the default configuration file. 
.TP 18
By default, the compiler uses the default configuration file (ifort.cfg) from the same directory where the compiler executable resides. 
.NL
.TP 18
INTEL_LICENSE_FILE
.NL
Specifies the location for the Intel license file. 
.NL
.TP 18
PATH
.NL
Specifies the directories the system searches for binary executable files. 
.NL
.TP 18
TMP
.TP 18
TMPDIR
.TP 18
TEMP
.NL
Specifies the location for temporary files. If none of these are specified or if none of these are found, the compiler stores temporary files in 
/tmp (Linux, OS X) or the current directory (Windows). 
.TP 18
The compiler searches for these variables in the following order: 
TMP, 
TMPDIR, and 
TEMP. 
.NL
.TP 18
CPATH (Linux* and OS X*) 
.NL
Specifies the path for include and module files. 
.NL
.TP 18
GCCROOT (Linux*) 
.NL
Specifies the location of the gcc* binaries. 
.TP 18
Set this variable only when the compiler cannot locate the gcc binaries when using the 
\-gcc\-name option. 
.NL
.TP 18
GXX_INCLUDE (Linux*) 
.NL
Specifies the location of the gcc headers. Set this variable to specify the locations of the gcc installed files when the compiler does not find the needed values as specified by the use of 
\-gcc\-name=\fIdirectory\-name\fR/gcc. 
.NL
.TP 18
GXX_ROOT (Linux*) 
.NL
Specifies the location of the gcc binaries. Set this variable to specify the locations of the gcc installed files when the compiler does not find the needed values as specified by the use of 
\-gcc\-name=\fIdirectory\-name\fR/gcc. 
.NL
.TP 18
LIBRARY_PATH (Linux* and OS X*) 
.NL
Specifies the path for libraries to be used during the link phase.
.NL
.TP 18
LD_LIBRARY_PATH (Linux*) 
.NL
Specifies the location for shared objects (.so files). 
.NL
.TP 18
DYLD_LIBRARY_PATH (OS X*) 
.NL
Specifies the path for dynamic libraries. 
.NL
.TP 18
\fB Intel(R) MIC Architecture Environment Variables\fR
.NL
.TP 18
MIC_LIBRARY_PATH
.NL
Specifies the location on the host for target\-specific static libraries. 
LIBRARY_PATH specifies the location on the host for host\-specific static libraries. 
.NL
.NL
.PP
The following table summarizes Compiler environment variables that are recognized at run time: 
.NL
.PP
.TP 18
\fBRun\-Time Environment Variable 
\fR
.NL
.NL
\fBDescription 
\fR
.NL
.NL
.TP 18
decfort_dump_flag
.NL
Boolean. 
.TP 18
When set to TRUE, a core dump will be taken when any severe Intel(R) Fortran run\-time error occurs. 
.NL
.TP 18
F_UFMTENDIAN
.NL
This variable specifies the numbers of the units to be used for little\-endian\-to\-big\-endian conversion purposes. 
See 
F_UFMTENDIAN Method Environment Variable.
.NL
.TP 18
FOR_FMT_TERMINATOR
.NL
This variable specifies the numbers of the units to have a specific record terminator. 
See 
Record Types.
.NL
.TP 18
FORT_FMT_NO_WRAP_MARGIN
.NL
Boolean. 
.TP 18
When set to TRUE, disables column wrapping in Fortran list\-directed output when the record being written gets longer than 80 characters. 
.PP
.B NOTE:
There is no mechanism to set a value for the right margin, this just disables wrapping. 
.TP 18
\fB Default: 
\fR NO 
(Wrap margin) 
.NL
.TP 18
FOR_ACCEPT
.NL
The 
ACCEPT statement does not include an explicit logical unit number. Instead, it uses an implicit internal logical unit number and the 
FOR_ACCEPT environment variable. If 
FOR_ACCEPT is 
\fInot\fR defined, the code 
ACCEPT f,iolist reads from 
CONIN$ (standard input). If 
FOR_ACCEPT is defined (as a file name optionally containing a path), the specified file would be read. 
.NL
.TP 18
FOR_DEBUGGER_IS_PRESENT
.NL
Boolean. 
.TP 18
When set to TRUE, this variable tells the Fortran run\-time library that your program is executing under a debugger, and generates debug exceptions whenever severe or continuous errors are detected. 
.TP 18
On Linux* and OS X*, this variable must be set for debug exceptions. Setting this variable to 
\fITrue\fR when a program is 
\fInot\fR executing under a debugger will cause unpredictable behavior. 
.NL
.TP 18
FOR_DIAGNOSTIC_LOG_FILE
.NL
If this variable is set to the name of a file, diagnostic output is written to the specified file. 
.TP 18
The Fortran run\-time system attempts to open that file (append output) and write the error information (ASCII text) to the file. 
.TP 18
The setting of 
FOR_DIAGNOSTIC_LOG_FILE is independent of 
FOR_DISABLE_DIAGNOSTIC_DISPLAY, so you can disable the screen display of information but still capture the error information in a file. The text string you assign for the file name is used literally, so you must specify the full name. If the file open fails, no error is reported and the run\-time system continues diagnostic processing. 
.TP 18
See also 
Locating Run\-Time Errors and Using Traceback Information Overview. 
.NL
.TP 18
FOR_DISABLE_DIAGNOSTIC_DISPLAY
.NL
Boolean. 
.TP 18
When set to TRUE, this variable disables the display of all error information. This variable is helpful if you just want to test the error status of your program and do not want the Fortran run\-time system to display any information about an abnormal program termination. 
.TP 18
See also 
Using Traceback Information Overview. 
.NL
.TP 18
FOR_FORCE_STACK_TRACE
.NL
Boolean. 
.TP 18
When set to TRUE, this variable forces a traceback to follow any run\-time diagnostic message. 
.TP 18
If 
FOR_DISABLE_STACK_TRACE 
is also set, 
FOR_FORCE_STACK_TRACE 
takes precedence over 
FOR_DISABLE_STACK_TRACE 
. 
.NL
.TP 18
FOR_DISABLE_STACK_TRACE
.NL
Boolean. 
.TP 18
When set to TRUE, this variable disables the call stack trace information that typically follows the displayed severe error message text. 
.TP 18
The Fortran run\-time error message is displayed regardless of whether 
FOR_DISABLE_STACK_TRACE is set to true. If the program is executing under a debugger, the automatic output of the stack trace information by the Fortran library will be disabled to reduce noise. Use the debugger\[aq]s stack trace facility to view the stack trace. 
.TP 18
See also 
Locating Run\-Time Errors and Using Traceback Information Overview. 
.NL
.TP 18
FOR_IGNORE_EXCEPTIONS
.NL
Boolean. 
.TP 18
When set to TRUE, this variable disables default run\-time exception handling to allow, for example, just\-in\-time debugging. The run\-time system exception handler returns 
EXCEPTION_CONTINUE_SEARCH to the operating system, which looks for other handlers to service the exception. 
.NL
.TP 18
FOR_NOERROR_DIALOGS
.NL
Boolean. 
.TP 18
When set to TRUE, this variable disables the display of dialog boxes when certain exceptions or errors occur. This is useful when running many test programs in batch mode to prevent a failure from stopping execution of the entire test stream. 
.NL
.TP 18
FOR_PRINT
.NL
Neither the 
PRINT statement nor a 
WRITE statement with an asterisk (*) in place of a unit number includes an explicit logical unit number. Instead, both use an implicit internal logical unit number and the 
FOR_PRINT environment variable. If 
FOR_PRINT is 
\fInot\fR defined, the code 
PRINT f,iolist or 
WRITE (*,f) iolist writes to 
CONOUT$ (standard output). If 
FOR_PRINT is defined (as a file name optionally containing a path), the specified file would be written to. 
.NL
.TP 18
FOR_READ
.NL
A 
READ statement that uses an asterisk (*) in place of a unit number does not include an explicit logical unit number. Instead, it uses an implicit internal logical unit number and the 
FOR_READ environment variable. If 
FOR_READ is 
\fInot\fR defined, the code 
READ (*,f) iolist or 
READ f,iolist reads from 
CONIN$ (standard input). If 
FOR_READ is defined (as a file name optionally containing a path), the specified file would be read. 
.NL
.TP 18
FOR_TYPE
.NL
The 
TYPE statement does not include an explicit logical unit number. Instead, it uses an implicit internal logical unit number and the 
FOR_TYPE environment variable. If 
FOR_TYPE is 
\fInot\fR defined, the code 
TYPE f,iolist writes to 
CONOUT$ (standard output). If 
FOR_TYPE is defined (as a file name optionally containing a path), the specified file would be written to. 
.NL
.TP 18
FORT_BLOCKSIZE
.NL
Specifies the default BLOCKSIZE value to be used when BLOCKSIZE= is omitted on the 
OPEN statement. Valid values are 0 to 2147467264. Sizes are rounded up to the next 512\-byte boundary. 
.NL
.TP 18
FORT_BUFFERCOUNT
.NL
Specifies the default BUFFERCOUNT value to be used when BUFFERCOUNT= is omitted on the 
OPEN statement. Valid values are 0 to 127. If 0 is specified, the default value of 1 will be used. 
.NL
.TP 18
FORT_BUFFERED
.NL
Boolean. 
.TP 18
When set to TRUE, this variable specifies that buffered I/O should be used at run time for input and output on all Fortran I/O units, except those with output to the terminal. This provides a run\-time mechanism to support the 
buffered_io keyword for the 
assume compiler option. 
.NL
.TP 18
FORT_BUFFERING_THRESHOLD=n
.NL
Specifies dynamic buffering for unformatted sequential 
READ operations: 
.TP 18
.IP \(bu 2
I/O list items with a size 
<=\fIn\fR are buffered and are moved one at a time from the buffer to the I/O list item. 
.IP \(bu 2
I/O list items with a size 
>\fIn\fR are not buffered and are moved one at a time from the file to the I/O list item. 
.NL
.TP 18
FORT_CONVERT\fIn\fR
.NL
Specifies the data format for an unformatted file associated with a particular unit number (\fIn\fR), as described in 
Methods of Specifying the Data Format. 
.NL
.TP 18
FORT_CONVERT\fI.ext\fR and 
FORT_CONVERT_\fIext\fR
.NL
Specifies the data format for unformatted files with a particular file extension suffix (.ext), as described in 
Methods of Specifying the Data Format. 
.NL
.TP 18
FORT_FMT_RECL
.NL
Specifies the default record length (normally 132 bytes) for formatted files. 
.NL
.TP 18
FORT_UFMT_RECL
.NL
Specifies the default record length (normally 2040 bytes) for unformatted files. 
.NL
.TP 18
FORT\fIn\fR
.NL
Specifies the file name for a particular unit number 
\fIn\fR, when a file name is not specified in the 
OPEN statement or an implicit 
OPEN is used, and the compiler option 
fpscomp with option keyword 
filesfromcmd was not specified. Preconnected files attached to units 0, 5, and 6 are by default associated with system standard I/O files. 
.NL
.TP 18
__INTEL_PRE_FFLAGS
.TP 18
__INTEL_POST_FFLAGS
.NL
Specifies a set of compiler options to add to the compile line. 
.TP 18
This is an extension to the facility already provided in the compiler configuration file 
ifort.cfg. 
.TP 18
.PP
.B NOTE:
By default, a configuration file named 
ifort.cfg is used. This file is in the same directory as the compiler executable. To use another configuration file in another location, you can use the 
IFORTCFG environment variable to assign the directory and file name for the configuration file. 
.TP 18
You can insert command line options in the prefix position using 
__INTEL_PRE_FFLAGS, or in the suffix position using 
__INTEL_POST_FFLAGS. The command line is built as follows: 
.TP 18
\fB Syntax:\fRifort\fI<PRE flags> 
\fR\fI<flags from configuration file> 
\fR\fI<flags from the compiler invocation> 
\fR\fI<POST flags> 
\fR
.PP
.B NOTE:
The driver issues a warning that the compiler is overriding an option because of an environment variable, but only when you include the option 
/W5 (Windows*) or 
\-w3 (Linux* and OS X*). 
.NL
.TP 18
NLSPATH (Linux* and OS X*) 
.NL
Specifies the path for the Intel(R) Fortran run\-time error message catalog. 
.NL
.TP 18
TBK_ENABLE_VERBOSE_STACK_TRACE
.NL
Boolean. 
.TP 18
When set to TRUE, this variable displays more detailed call stack information in the event of an error. 
.TP 18
The default brief output is usually sufficient to determine where an error occurred. Brief output includes up to twenty stack frames, reported one line per stack frame. For each frame, the image name containing the PC, routine name, line number, and source file are given. 
.TP 18
The verbose output, if selected, will provide (in addition to the information in brief output) the exception context record if the error was a machine exception (machine register dump), and for each frame, the return address, frame pointer and stack pointer and possible parameters to the routine. This output can be quite long (but limited to 16K bytes) and use of the environment variable 
FOR_DIAGNOSTIC_LOG_FILE is recommended if you want to capture the output accurately. Most situations should not require the use of verbose output. 
.TP 18
This variable is also recognized for compatibility with Compaq* Visual Fortran. 
.TP 18
See also 
Locating Run\-Time Errors and Using Traceback Information Overview. 
.NL
.TP 18
TBK_FULL_SRC_FILE_SPEC
.NL
Boolean. 
.TP 18
When set to TRUE, this variable displays complete file name information including the path. By default, the traceback output displays only the file name and extension in the source file field. 
.TP 18
This variable is also recognized for compatibility with Compaq* Visual Fortran. 
.TP 18
See also 
Locating Run\-Time Errors and Using Traceback Information Overview. 
.NL
.TP 18
FORT_TMPDIR
.TP 18
TMP
.TP 18
TMPDIR
.TP 18
TEMP
.NL
Specifies an alternate working directory where scratch files are created. 
.NL
.TP 18
\fB GNU extensions (recognized by the Intel(R) OpenMP compatibility library)\fR
.NL
.TP 18
GOMP_CPU_AFFINITY (Linux*) 
.NL
GNU extension recognized by the Intel(R) OpenMP compatibility library. Specifies a list of OS processor IDs. 
.TP 18
\fB Default:\fR Affinity is disabled 
.NL
.TP 18
GOMP_STACKSIZE (Linux*) 
.NL
GNU extension recognized by the Intel(R) OpenMP compatibility library. Same as 
OMP_STACKSIZE.KMP_STACKSIZE overrides 
GOMP_STACKSIZE, which overrides 
OMP_STACKSIZE.
.TP 18
\fB Default:\fR See the description for 
OMP_STACKSIZE. 
.NL
.TP 18
\fB OpenMP* Environment Variables (OMP_) and Extensions (KMP_)\fR
.NL
.TP 18
OMP_CANCELLATION
.NL
Activates cancellation of the innermost enclosing region of the type specified. If set to true, the effects of the cancel construct and of cancellation points are enabled and cancellation is activated. If set to false, cancellation is disabled and the cancel construct and cancellation points are effectively ignored. 
.TP 18
.PP
.B NOTE:
Internal barrier code will work differently depending on if the cancellation is enabled. Barrier code should repeatedly check the global flag to figure out if the cancellation had been triggered. If a thread observes the cancellation it should leave the barrier prematurely with the return value 1 (probably waking up other threads). Otherwise, it should leave the barrier the usual way with the return value 0. 
.TP 18
Enables (true) or disables (false) cancellation of the innermost enclosing region of the type specified. 
.TP 18
\fB Default:\fRfalse
.TP 18
\fB Example: 
\fROMP_CANCELLATION=true
.NL
.TP 18
OMP_DYNAMIC
.NL
Enables (true) or disables (false) the dynamic adjustment of the number of threads. 
.TP 18
\fB Default:\fRfalse
.TP 18
\fB Example:\fROMP_DYNAMIC=true
.NL
.TP 18
OMP_MAX_ACTIVE_LEVELS
.NL
The maximum number of levels of parallel nesting for the program. 
.TP 18
\fB Default:\fR 1 
.TP 18
\fB Syntax:\fROMP_MAX_ACTIVE_LEVELS=value
.NL
.TP 18
OMP_NESTED
.NL
Enables (true) or disables (false) nested parallelism. 
.TP 18
\fB Default:\fRfalse
.TP 18
\fB Example:\fROMP_NESTED=value
.NL
.TP 18
OMP_NUM_THREADS
.NL
Sets the maximum number of threads to use for OpenMP* parallel regions if no other value is specified in the application. 
.TP 18
The value can be a single integer, in which case it specifies the number of threads for all parallel regions. The value can also be a comma\-separated list of integers, in which case each integer specifies the number of threads for a parallel region at a nesting level. 
.TP 18
The first position in the list represents the outer\-most parallel nesting level, the second position represents the next\-inner parallel nesting level, and so on. At any level, the integer can be left out of the list. If the first integer in a list is left out, it implies the normal default value for threads is used at the outer\-most level. If the integer is left out of any other level, the number of threads for that level is inherited from the previous level. 
.TP 18
This environment variable applies to the options 
Qopenmp (Windows) or 
qopenmp (Linux and OS X), or 
[Q]parallel. 
.TP 18
\fB Default:\fR The number of processors visible to the operating system 
. 
.TP 18
\fB Syntax:\fROMP_NUM_THREADS=value[,value]*
.NL
.TP 18
OMP_PLACES
.NL
Specifies an explicit ordered list of places, either as an abstract name describing a set of places or as an explicit list of places described by nonnegative numbers. An exclusion operator “!” can also be used to exclude the number or place immediately following the operator. 
.TP 18
For 
\fB explicit lists\fR, the meaning of the numbers and how the numbering is done for a list of nonnegative numbers are implementation defined. Generally, the numbers represent the smallest unit of execution exposed by the execution environment, typically a hardware thread. 
.TP 18
Intervals can be specified using the 
<lower\-bound> : 
<length> : 
<stride> notation to represent the following list of numbers: 
.PP
"<lower\-bound>, <lower\-bound> + <stride>, ..., 
<lower\-bound> +(<length>\-1)*<stride>."
.PP
When 
<stride> is omitted, a unit stride is assumed. Intervals can specify numbers within a place as well as sequences of places. 
.PP
# EXPLICIT LIST EXAMPLE
setenv OMP_PLACES "{0,1,2,3},{4,5,6,7},{8,9,10,11},{12,13,14,15}"
setenv OMP_PLACES "{0:4},{4:4},{8:4},{12:4}"
setenv OMP_PLACES "{0:4}:4:4"
.PP
.TP 18
The 
\fB abstract names\fR listed below should be understood by the execution and runtime environment: 
.TP 18
.IP \(bu 2
threads: Each place corresponds to a single hardware thread on the target machine. 
.IP \(bu 2
cores: Each place corresponds to a single core (having one or more hardware threads) on the target machine. 
.IP \(bu 2
sockets: Each place corresponds to a single socket (consisting of one or more cores) on the target machine. 
.TP 18
When requesting fewer places or more resources than available on the system, the determination of which resources of type 
abstract_name are to be included in the place list is implementation defined. The precise definitions of the abstract names are implementation defined. An implementation may also add abstract names as appropriate for the target platform. The abstract name may be appended by a positive number in parentheses to denote the length of the place list to be created, that is 
abstract_name(\fInum\-places\fR). 
.PP
# ABSTRACT NAMES EXAMPLE
setenv OMP_PLACES threads
setenv OMP_PLACES threads(4)
.PP
.PP
.B NOTE:
If any numerical values cannot be mapped to a processor on the target platform the behavior is implementation defined. The behavior is also implementation defined when the 
OMP_PLACES environment variable is defined using an abstract name. 
.NL
.TP 18
OMP_PROC_BIND (Windows, Linux) 
.NL
Sets the thread affinity policy to be used for parallel regions at the corresponding nested level. Enables (true) or disables (false) the binding of threads to processor contexts. If enabled, this is the same as specifying 
KMP_AFFINITY=scatter. If disabled, this is the same as specifying 
KMP_AFFINITY=none. 
.TP 18
\fB Acceptable values: 
\fRtrue, 
false, or a comma separated list, each element of which is one of the following values: 
master, 
close, 
spread. 
.TP 18
\fB Default: 
\fRfalse
.TP 18
If set to false, the execution environment may move OpenMP* threads between OpenMP* places, thread affinity is disabled, and proc_bind clauses on parallel constructs are ignored. Otherwise, the execution environment should not move OpenMP* threads between OpenMP* places, thread affinity is enabled, and the initial thread is bound to the first place in the OpenMP* place list. 
.TP 18
If set to 
master, all threads are bound to the same place as the master thread. If set to 
close, threads are bound to successive places, close to where the master thread is bound. If set to 
spread, the master thread\[aq]s partition is subdivided and threads are bound to a single place successive sub\-partitions. 
.PP
.B NOTE:
KMP_AFFINITY takes precedence over 
GOMP_CPU_AFFINITY and 
OMP_PROC_BIND. 
GOMP_CPU_AFFINITY takes precedence over 
OMP_PROC_BIND. 
.NL
.TP 18
OMP_SCHEDULE
.NL
Sets the run\-time schedule type and an optional chunk size. 
.TP 18
\fB Default:\fRSTATIC, no chunk size specified 
.TP 18
\fB Example syntax:\fROMP_SCHEDULE="kind[,chunk_size]"
.TP 18
= = = = = = = = = =
.PP
.B NOTE:
Some environment variables are available for both Intel(R) microprocessors and non\-Intel microprocessors, but may perform additional optimizations for Intel(R) microprocessors than for non\-Intel microprocessors.
= = = = = = = = = =
.NL
.TP 18
OMP_STACKSIZE
.NL
Sets the number of bytes to allocate for each OpenMP* thread to use as the private stack for the thread. Recommended size is 16M. 
.TP 18
Use the optional suffixes to specify byte units: 
B (bytes), 
K (Kilobytes), 
M (Megabytes), 
G (Gigabytes), or 
T (Terabytes) to specify the units. If you specifiy a value, the byte unit is assumed to be 
K (Kilobytes). 
.TP 18
This variable does not affect the native operating system threads created by the user program nor the thread executing the sequential part of an OpenMP* program or parallel programs created using the[Q]parallel option. 
.TP 18
The 
kmp_{set,get}_stacksize_s() routines set/retrieve the value. The 
kmp_set_stacksize_s() routine must be called from sequential part, before first parallel region is created. Otherwise, calling 
kmp_set_stacksize_s() has no effect. 
.TP 18
\fB Default (IA\-32 architecture):\fR 2M 
.TP 18
\fB Default (Intel(R) 64 architecture):\fR 4M 
.TP 18
\fB Default (Intel(R) MIC architecture):\fR4M (on supported OSes) 
.TP 18
\fB Related environment variables:\fRKMP_STACKSIZE (overrides 
OMP_STACKSIZE). 
.TP 18
\fB Syntax:\fROMP_STACKSIZE=value
.NL
.TP 18
OMP_THREAD_LIMIT
.NL
Limits the number of simultaneously executing threads in an OpenMP* program. 
.TP 18
If this limit is reached and another native operating system thread encounters OpenMP* API calls or constructs, the program can abort with an error message. If this limit is reached when an OpenMP* parallel region begins, a one\-time warning message might be generated indicating that the number of threads in the team was reduced, but the program will continue. 
.TP 18
This environment variable is only used for programs compiled with the following options: 
Qopenmp (Windows) or 
qopenmp (Linux and OS X), or 
[Q]parallel. 
.TP 18
The 
omp_get_thread_limit() routine returns the value of the limit. 
.TP 18
\fB Default:\fR No enforced limit 
.TP 18
\fB Related environment variable:\fRKMP_ALL_THREADS (overrides 
OMP_THREAD_LIMIT). 
.TP 18
\fB Example syntax:\fROMP_THREAD_LIMIT=value
.NL
.TP 18
OMP_WAIT_POLICY
.NL
Decides whether threads spin (active) or yield (passive) while they are waiting. 
.TP 18
OMP_WAIT_POLICY=ACTIVE is an alias for 
KMP_LIBRARY=turnaround, and 
OMP_WAIT_POLICY=PASSIVE is an alias for 
KMP_LIBRARY=throughtput. 
.TP 18
\fB Default: 
\fRPassive 
.TP 18
\fB Syntax:\fROMP_WAIT_POLICY=value
.NL
.TP 18
KMP_AFFINITY (Windows, Linux) 
.NL
Enables run\-time library to bind threads to physical processing units. 
.TP 18
\fB Default:\fR noverbose,warnings,respect,granularity=core,duplicates,none 
.TP 18
\fB Default (Intel(R) MIC architecture):\fR noverbose,warnings,respect,granularity=fine,duplicates,scatter,0,0 
.TP 18
= = = = = = = = = =
.PP
.B NOTE:
Some environment variables are available for both Intel(R) microprocessors and non\-Intel microprocessors, but may perform additional optimizations for Intel(R) microprocessors than for non\-Intel microprocessors.
= = = = = = = = = =
.NL
.TP 18
KMP_ALL_THREADS
.NL
Limits the number of simultaneously executing threads in an OpenMP* program. If this limit is reached and another native operating system thread encounters OpenMP* API calls or constructs, then the program may abort with an error message. If this limit is reached at the time an OpenMP* parallel region begins, a one\-time warning message may be generated indicating that the number of threads in the team was reduced, but the program will continue execution. 
.TP 18
This environment variable is only used for programs compiled with the 
qopenmp 
option. 
.TP 18
\fB Default:\fR No enforced limit. 
.NL
.TP 18
KMP_BLOCKTIME
.NL
Sets the time, in milliseconds, that a thread should wait, after completing the execution of a parallel region, before sleeping. 
.TP 18
Use the optional character suffixes: 
s (seconds), 
m (minutes), 
h (hours), or 
d (days) to specify the units. 
.TP 18
Specify 
infinite for an unlimited wait time. 
.TP 18
\fB Default:\fR 200 milliseconds 
.TP 18
\fB Related Environment Variable:\fRKMP_LIBRARY environment variable. 
.NL
.TP 18
KMP_CPUINFO_FILE
.NL
Specifies an alternate file name for file containing machine topology description. The file must be in the same format as 
/proc/cpuinfo. 
.TP 18
\fB Default:\fR None 
.TP 18
= = = = = = = = = =
.PP
.B NOTE:
Some environment variables are available for both Intel(R) microprocessors and non\-Intel microprocessors, but may perform additional optimizations for Intel(R) microprocessors than for non\-Intel microprocessors.
= = = = = = = = = =
.NL
.TP 18
KMP_DETERMINISTIC_REDUCTION
.NL
Enables (true) or disables (false) the use of a specific ordering of the reduction operations for implementing the reduction clause for an OpenMP* parallel region. This has the effect that, for a given number of threads, in a given parallel region, for a given data set and reduction operation, a floating point reduction done for an OpenMP* reduction clause has a consistent floating point result from run to run, since round\-off errors are identical. 
.TP 18
\fB Default:\fRfalse
.NL
.TP 18
KMP_DYNAMIC_MODE
.NL
Selects the method used to determine the number of threads to use for a parallel region when 
OMP_DYNAMIC=true. Possible values: (asat | 
load_balance | 
thread_limit), where, 
.IP \(bu 2
asat: estimates number of threads based on parallel start time; 
.PP
.B NOTE:
Support for 
asat 
(automatic self\-allocating threads) is now deprecated, and will be removed in a future release. 
.IP \(bu 2
load_balance: tries to avoid using more threads than available execution units on the machine; 
.IP \(bu 2
thread_limit: tries to avoid using more threads than total execution units on the machine. 
.TP 18
\fB Default (IA\-32 architecture):\fRload_balance (on all supported OSes) 
.TP 18
\fB Default (Intel(R) 64 architecture):\fRload_balance (on all supported OSes) 
.TP 18
\fB Default (Intel(R) MIC architecture):\fR thread_limit 
(on supported OSes) 
.NL
.TP 18
KMP_INHERIT_FP_CONTROL
.NL
Enables (true) or disables (false) the copying of the floating point control settings of the master thread to the floating point control settings of the OpenMP* worker threads at the start of each parallel region. 
.TP 18
\fB Default:\fRtrue
.NL
.TP 18
KMP_LIBRARY
.NL
Selects the OpenMP* run\-time library execution mode. The values for this variable are 
serial, 
turnaround, or 
throughput. 
.TP 18
\fB Default:\fRthroughput
.NL
.TP 18
KMP_MONITOR_STACKSIZE
.NL
Sets the number of bytes to allocate for the monitor thread, which is used for book\-keeping during program execution. 
.TP 18
Use the optional suffixes to specify byte units: 
B (bytes), 
K (Kilobytes), 
M (Megabytes), 
G (Gigabytes), or 
T (Terabytes) to specify the units. If you specifiy a value, the byte unit is assumed to be 
K (Kilobytes). 
.TP 18
\fB Default:\fR max (32k, system minimum thread stack size) 
.NL
.TP 18
KMP_PLACE_THREADS
.NL
This environment variable only applies to Intel(R) Many Integrated Core Architecture (Intel(R) MIC Architecture). 
.TP 18
Specifies the number of cores, with optional offset value and number of threads per core to use with an OpenMP* application, as an alternative to writing explicit affinity settings or a process affinity mask. 
.PP
value = (  int [ "C" | "T" ] [ delim ] | delim ) 
[ int [ "T" ] [ delim ] ] 
[ int [ "O" ] ];
delim = "," | "x";
.PP
.TP 18
"C" indicates cores, 
"T" indicates threads, 
"O" indicates an offset. 
.PP
.B NOTE:
Specify either cores or threads. 
.TP 18
\fB Default:\fR If omitted, the default value is the available number of cores (threads). 
.TP 18
\fB  Examples:\fR
.IP \(bu 2
\fB 5C,3T,1O: 
\fR use 5 cores with offset 1, 3 threads per core. 
.IP \(bu 2
\fB 5,3,1: 
\fR same as above. 
.IP \(bu 2
\fB 24: 
\fR use first 24 cores, all available threads per core. 
.IP \(bu 2
\fB 2T: 
\fR use all cores, 2 threads per core. 
.IP \(bu 2
\fB ,2: 
\fR same as above. 
.IP \(bu 2
\fB 3x2: 
\fR use 3 cores, 2 threads per core 
.IP \(bu 2
\fB 4C12O: 
\fR use 4 cores with offset 12, all available threads per core. 
.NL
.TP 18
KMP_SETTINGS
.NL
Enables (true) or disables (false) the printing of OpenMP* run\-time library environment variables during program execution. Two lists of variables are printed: user\-defined environment variables settings and effective values of variables used by OpenMP* run\-time library. 
.TP 18
\fB Default:\fRfalse
.NL
.TP 18
KMP_STACKSIZE
.NL
Sets the number of bytes to allocate for each OpenMP* thread to use as its private stack. 
.TP 18
Recommended size is 16m. 
.TP 18
Use the optional suffixes to specify byte units: 
B (bytes), 
K (Kilobytes), 
M (Megabytes), 
G (Gigabytes), or 
T (Terabytes) to specify the units. If you specifiy a value, the byte unit is assumed to be 
K (Kilobytes). 
.TP 18
This variable does not affect the native operating system threads created by the user program nor the thread executing the sequential part of an OpenMP* program or parallel programs created using 
[Q]parallel option. 
.TP 18
\fB Default (IA\-32 architecture):\fR 2m 
.TP 18
\fB Default (Intel(R) 64 architecture):\fR 4m 
.TP 18
\fB Default (Intel(R) MIC architecture):\fR4M (on supported OSes) 
.NL
.TP 18
KMP_VERSION
.NL
Enables (true) or disables (false) the printing of OpenMP* run\-time library version information during program execution. 
.TP 18
\fB Default:\fRfalse
.NL
.TP 18
KMP_WARNINGS
.NL
Enables (true) or disables (false) displaying warnings from the OpenMP* run\-time library during program execution. 
.TP 18
\fB Default:\fRfalse
.NL
.TP 18
\fB PGO Environment Variables\fR
.NL
.TP 18
INTEL_PROF_DUMP_CUMULATIVE
.NL
When using interval profile dumping (initiated by 
INTEL_PROF_DUMP_INTERVAL or the function 
_PGOPTI_Set_Interval_Prof_Dump) during the execution of an instrumented user application, allows creation of a single 
.dyn file to contain profiling information instead of multiple 
.dyn files. If not set, executing an instrumented user application creates a new 
.dyn file for each interval. 
.TP 18
If not set, executing an instrumented user application creates a new 
.dyn file for each interval. Setting this environment variable is useful for applications that do not terminate or those that terminate abnormally (bypass the normal exit code). 
.NL
.TP 18
INTEL_PROF_DUMP_INTERVAL
.NL
Initiates interval profile dumping in an instrumented user application. This environment variable may be used to initiate Interval Profile Dumping in an instrumented application. 
.TP 18
See Interval Profile Dumping for more information.
.NL
.TP 18
INTEL_PROF_DYN_PREFIX
.NL
Specifies the prefix to be used for the 
.dyn filename to distinguish it from the other 
.dyn 
files dumped by other PGO runs. Executing the instrumented application generates a .dyn filename as follows: 
<prefix>_<timestamp>_<pid>.dyn, where 
<prefix> is the identifier that you have specified. 
.PP
.B NOTE:
The value specified in this environment variable must not contain < > : " / \ | ? * characters. The default naming scheme is used if an invalid prefix is specified. 
.NL
.TP 18
PROF_DIR
.NL
Specifies the directory where profiling files (files with extensions 
.dyn, 
.dpi, 
.spi and so forth) are stored. The default is to store the 
.dyn files in the source directory of the file containing the first executed instrumented routine in the binary compiled with 
[Q]prof\-gen option. 
.TP 18
This variable applies to all three phases of the profiling process. 
.NL
.TP 18
PROF_DPI
.NL
Name for the 
.dpi file. 
.TP 18
\fB Default:\fRpgopti.dpi
.NL
.TP 18
PROF_DUMP_INTERVAL
.NL
Deprecated; use 
INTEL_PROF_DUMP_INTERVAL instead. 
.NL
.TP 18
PROF_NO_CLOBBER
.NL
Alters the feedback compilation phase slightly. By default, during the feedback compilation phase, the compiler merges data from all dynamic information files and creates a new 
pgopti.dpi file if the 
.dyn files are newer than an existing 
pgopti.dpi file. 
.TP 18
When this variable is set the compiler does not overwrite the existing 
pgopti.dpi file. Instead, the compiler issues a warning. You must remove the 
pgopti.dpi file if you want to use additional dynamic information files. 
.NL
.TP 18
\fB Intel(R) MIC Architecture Environment Variables\fR
.NL
.TP 18
MIC_ENV_PREFIX
.NL
Controls environment variables passed to the target. 
.TP 18
By default, all environment variables set on the host are passed to the target. Setting 
MIC_ENV_PREFIX passes only environment variables that have a prefix of the value of this variable. For example, setting 
MIC_ENV_PREFIX=ABC passes only environment variables that have a prefix of 
ABC. 
.TP 18
.PP
.B NOTE:
To change 
LD_LIBRARY_PATH on the target, use any prefix other than MIC. For example 
MIC_ENV_PREFIX=ABC and 
ABC_LD_LIBRARY_PATH=/tmp/mylibs sets 
LD_LIBRARY_PATH on the target to 
/tmp/mylibs. 
.TP 18
For information on passing environment variables to a particular coprocessor, and on passing multiple environment variables to one or all coprocessors, see 
Setting Environment Variables on the CPU to Modify the Coprocessor\[aq]s Execution Environment. 
.NL
.TP 18
MIC_HOST_LOG
.NL
Outputs traces from the host to the location specified by this environment variable string. 
.TP 18
\fB Default: 
\fR None 
.TP 18
\fB  Example: 
\fRMIC_HOST_LOG=/home/user/app/host.log
.NL
.TP 18
MIC_LD_LIBRARY_PATH
.NL
Specifies the location on the host for target\-specific shared objects that may be loaded to the target. The value is not passed to the target. See 
MIC_ENV_PREFIX for special handling of the value on the target. 
.TP 18
LD_LIBRARY_PATH specifies the location on the host for host\-specific shared objects. 
.NL
.TP 18
MIC_PROXY_IO
.NL
Enables (1) or disables (0) the proxy of stderr and stdout, and specifies whether the process wants I/O proxy support between the host and target. 
.TP 18
\fB Default:\fR1
.TP 18
\fB  Example:\fRMIC_PROXY_IO=0
.NL
.TP 18
MIC_SEP_MONITOR
.NL
Enables (1) or disables (0) SEP at offload regions. 
.TP 18
\fB Default:\fR0
.TP 18
\fB  Example:\fRMIC_SEP_MONITOR=1
.NL
.TP 18
MIC_STACKSIZE
.NL
Specifies the stack size of the main thread for the offload. This value is typically much larger than the stack size for individual threads. It corresponds to what you would set with 
.B ulimit
\-s (BASH shell) or 
.B limit stacksize
(C shell) if you were running natively on either the target or the host. 
.TP 18
Set this variable to 
\fIinteger\fRB|K|M|G|T, where: 
.RS
.IP \(bu 2
\fIB\fR = bytes 
.IP \(bu 2
\fIK\fR = kilobytes 
.IP \(bu 2
\fIM\fR = megabytes 
.IP \(bu 2
\fIG\fR = gigabytes 
.IP \(bu 2
\fIT\fR = terabytes 
.RE
.TP 18
\fB Default: 
\fR12M
.TP 18
\fB  Example:\fRMIC_STACKSIZE=16M
.NL
.TP 18
MIC_USE_2MB_BUFFERS
.NL
Use 2M pages for (size > 
MIC_USE_2MB_BUFFERS). 
Variables with the ALLOCATABLE or POINTER attribute 
whose runtime length exceeds the value of this environment variable are allocated in large pages. 
.TP 18
Set this variable to 
\fIinteger\fRB|K|M|G|T, where: 
.RS
.IP \(bu 2
\fIB\fR = bytes 
.IP \(bu 2
\fIK\fR = kilobytes 
.IP \(bu 2
\fIM\fR = megabytes 
.IP \(bu 2
\fIG\fR = gigabytes 
.IP \(bu 2
\fIT\fR = terabytes 
.RE
.TP 18
\fB  Example:\fRMIC_USE_2MB_BUFFERS=64K
.NL
.TP 18
OFFLOAD_DEVICES
.NL
Restricts the offload process to use only the coprocessors specified as the value of the variable. 
.TP 18
Set this variable to a comma separated list of target device numbers in the range 0 to (\fInumber_of_devices_in_the_system\fR \-1), where 0 is the first coprocessor in the system, and (\fInumber_of_devices_in_the_system\fR \-1) is the last coprocessor in the system. 
.TP 18
Coprocessors available for offloading are numbered logically. The function 
OFFLOAD_NUMBER_OF_DEVICES returns the number of available coprocessors. Coprocessor indices that you use in the 
target specifier of the offload 
directives are in the range 0 to 
\fInumber_of_devices_in_the_system\fR\-1. 
.TP 18
\fB Default:\fR The offload process uses all devices. 
.TP 18
\fB  Example:\fROFFLOAD_DEVICES = 1,2
.TP 18
On a system with more than two coprocessors installed, this setting enables the application to use only coprocessors 1 and 2. Offloads to coprocessors 0 or 1 are performed on the second and third physical coprocessors. Offloads to target numbers higher than 1 wrap\-around so that all offloads remain within coprocessors 0 and 1. The function 
OFFLOAD_NUMBER_OF_DEVICES executed on a coprocessor return 0 or 1, when the offload is running on the first or second coprocessor. 
.NL
.TP 18
OFFLOAD_INIT
.NL
Specifies a hint to the offload runtime when to initialize targets. 
.TP 18
Supported values: 
.IP \(bu 2
on_start: All available coprocessors are initialized before entering 
the main program. 
.IP \(bu 2
on_offload: The target is initialized immediately before the first offload to it. Initialization is done only on the target that handles the offload. 
.IP \(bu 2
on_offload_all: All available targets are initialized immediately before the first offload in an application. 
.TP 18
\fB Default:\fRon_offload_all
.TP 18
\fB  Example:\fROFFLOAD_INIT=on_start
.NL
.TP 18
OFFLOAD_REPORT
.NL
Controls printing offload execution time, in seconds, and the amount of data transferred, in bytes. This environment variable is equivalent to using the 
__Offload_report API. 
.TP 18
Supported values: 
.IP \(bu 2
1: Prints the offload computation time, in seconds. 
.IP \(bu 2
2: In addition to the information produced at value 1, adds the amount of data transferred between the CPU and the target, in bytes. 
.IP \(bu 2
3: In addition to the information produced at value 2, gives additional details on offload activity, including device initialization, and individual variable transfers. 
.TP 18
\fB Default:\fR None 
.TP 18
\fB  Example:\fROFFLOAD_REPORT=1
.NL
.NL
.SH TECHNICAL SUPPORT
.PP
The Intel(R) Compiler product web site offers timely and comprehensive product information, including product features, white papers, and technical articles. 
.PP
For the latest information, visit http://www.intel.com/software/products/. 
.PP
For support information, see the Release Notes. For general support information, visit http://www.intel.com/software/products/support/. 
.PP
For licensing and registration information, visit https://registrationcenter.intel.com/. 
.SH SEE ALSO
.PP
ifort(1), ld(1) 
.PP
The Intel(R) Fortran Compiler Documentation has additional reference material on features of the Intel(R) Fortran Compiler.
.SH LEGAL INFORMATION
.PP
By using this document, in addition to any agreements you have with Intel, you accept the terms set forth below.
.PP
You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non\-exclusive, royalty\-free license to any patent claim thereafter drafted which includes subject matter disclosed herein.
.PP
INFORMATION IN THIS DOCUMENT IS PROVIDED IN CONNECTION WITH INTEL(R) PRODUCTS. NO LICENSE, EXPRESS OR IMPLIED, BY ESTOPPEL OR OTHERWISE, TO ANY INTELLECTUAL PROPERTY RIGHTS IS GRANTED BY THIS DOCUMENT. EXCEPT AS PROVIDED IN INTEL\[aq]S TERMS AND CONDITIONS OF SALE FOR SUCH PRODUCTS, INTEL ASSUMES NO LIABILITY WHATSOEVER, AND INTEL DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY, RELATING TO SALE AND/OR USE OF INTEL PRODUCTS INCLUDING LIABILITY OR WARRANTIES RELATING TO FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABILITY, OR INFRINGEMENT OF ANY PATENT, COPYRIGHT OR OTHER INTELLECTUAL PROPERTY RIGHT. 
.PP
A "Mission Critical Application" is any application in which failure of the Intel(R) Product could result, directly or indirectly, in personal injury or death. SHOULD YOU PURCHASE OR USE INTEL\[aq]S PRODUCTS FOR ANY SUCH MISSION CRITICAL APPLICATION, YOU SHALL INDEMNIFY AND HOLD INTEL AND ITS SUBSIDIARIES, SUBCONTRACTORS AND AFFILIATES, AND THE DIRECTORS, OFFICERS, AND EMPLOYEES OF EACH, HARMLESS AGAINST ALL CLAIMS COSTS, DAMAGES, AND EXPENSES AND REASONABLE ATTORNEYS\[aq] FEES ARISING OUT OF, DIRECTLY OR INDIRECTLY, ANY CLAIM OF PRODUCT LIABILITY, PERSONAL INJURY, OR DEATH ARISING IN ANY WAY OUT OF SUCH MISSION CRITICAL APPLICATION, WHETHER OR NOT INTEL OR ITS SUBCONTRACTOR WAS NEGLIGENT IN THE DESIGN, MANUFACTURE, OR WARNING OF THE INTEL PRODUCT OR ANY OF ITS PARTS. 
.PP
Intel may make changes to specifications and product descriptions at any time, without notice. Designers must not rely on the absence or characteristics of any features or instructions marked "reserved" or "undefined." Intel reserves these for future definition and shall have no responsibility whatsoever for conflicts or incompatibilities arising from future changes to them. The information here is subject to change without notice. Do not finalize a design with this information. 
.PP
The products described in this document may contain design defects or errors known as errata which may cause the product to deviate from published specifications. Current characterized errata are available on request. 
.PP
Contact your local Intel sales office or your distributor to obtain the latest specifications and before placing your product order. 
.PP
Copies of documents which have an order number and are referenced in this document, or other Intel literature, may be obtained by calling 1\-800\-548\-4725, or go to: http://www.intel.com/design/literature.htm 
.PP
Intel processor numbers are not a measure of performance. Processor numbers differentiate features within each processor family, not across different processor families. Go to: Learn About Intel(R) Processor Numbers (http://www.intel.com/products/processor_number). 
.PP
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. Notice revision #20110804 
.PP
Intel, Intel Atom, Intel Core, Intel Cilk, Intel VTune , Itanium, MMX, Pentium, Xeon, and Intel Xeon Phi are trademarks of Intel Corporation in the U.S. and/or other countries. 
.PP
* Other names and brands may be claimed as the property of others. 
.PP
Copyright (C) 1996\-2014, Intel Corporation. All rights reserved. 
.PP
Portions Copyright (C) 2001, Hewlett\-Packard Development Company, L.P. 
